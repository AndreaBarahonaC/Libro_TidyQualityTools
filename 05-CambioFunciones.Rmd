# Cambio de Funciones

```{css, echo=FALSE}
.scroll-100 {
  max-height: 100px;
  overflow-y: auto;
  background-color: inherit;
}
```


```{r, warning=FALSE, message=FALSE, collapse=TRUE, echo=FALSE}
# install.packages("ggplot2")
# install.packages("patchwork")
# install.packages("gridExtra")
library(R6)
library(tidyverse)
library(ggplot2)
library(patchwork)
library(gridExtra)
library(dplyr)
library(tidyr)
library(tibble)
library(scales)
library(plotly)
```


## Fase 1: Definir

### 1. Función Pareto

```{r, class.output="scroll-100", echo=FALSE}
# Nueva Función (se quita argumento `las`)
ParetoChart_ <- function (x, weight, showTable = TRUE, showPlot = TRUE, main, col, border, xlab, ylab = "Frequency", percentVec, ...)
{
  varName = deparse(substitute(x))[1]
  corp.col = "#C4B9FF"
  corp.border = "#9E0138"
  if (!is.vector(x) & !is.data.frame(x) & !is.table(x))
    stop("x should be a vector, dataframe or a table")
  if (is.table(x)) {
    xtable = x
  }
  if (is.vector(x)) {
    if (!is.null(names(x)))
      xtable = as.table(x)
    else xtable = table(x)
  }
  if (!missing(weight)) {
    if (!is.numeric(weight))
      stop("weight must be numeric!")
    if (is.null(names(weight)))
      stop("weight is missing names for matching!")
    else {
      if (FALSE %in% (sort(names(weight)) == sort(names(xtable))))
        stop("names of weight and table do not match!")
      else {
        for (i in 1:length(xtable)) {
          xtable[i] = weight[names(weight) == names(xtable)[i]] *
            xtable[i]
        }
      }
    }
  }
  else {
    weight = FALSE
  }
  if (missing(showTable))
    showTable = TRUE
  if (missing(xlab))
    xlab = ""
  if (missing(main))
    main = paste("Pareto Chart for", varName)
  if (missing(col))
    col = corp.col
  if (missing(border))
    border = corp.border
  if (missing(percentVec))
    percentVec = seq(0, 1, by = 0.25)
  call <- match.call(expand.dots = TRUE)
  # Plot
  if (length(xtable) > 1) {
    ylim = c(min(xtable), max(xtable) * 1.025)
    xtable = c(sort(xtable, decreasing = TRUE, na.last = TRUE))
    cumFreq = cumsum(xtable)
    sumFreq = sum(xtable)
    percentage = xtable/sum(xtable) * 100
    cumPerc = cumFreq/sumFreq * 100
    
    
    data <- data.frame(Frequency = xtable,
                       Cum.Frequency = cumFreq,
                       Percentage = round(percentage, digits = 2),
                       Cum.Percentage = round(cumPerc, digits = 2))
    tabla <- t(data)
    
    p <- ggplot(data, aes(x = reorder(names(xtable), -xtable), y = Frequency)) +
      geom_col(aes(fill = "Frequency"), width = 0.7) +
      geom_point(aes(y = Cum.Frequency, color = "Cumulative Percentage"), size = 3) +
      geom_line(aes(y = Cum.Frequency, group = 1, color = "Cumulative Percentage")) +
      scale_y_continuous(name = ylab,
                         sec.axis = sec_axis(~ . / sum(xtable),
                                             name = "Cumulative Percentage",
                                             labels = percentVec)) +
      scale_x_discrete(name = xlab) +
      scale_color_manual(values = c(border, border)) +
      scale_fill_manual(values = col) +
      theme(legend.position = "none") +
      labs(title = main)+
      theme_minimal() +
      theme(plot.title = element_text(hjust = 0.5,face = "bold"))
  }
  else {
    warning("data should have at least two categories!")
  }
  if(showPlot == TRUE){
    if(showTable == TRUE){
      show(p/tableGrob(tabla))
    }
    else {
      show(p)
    }
  }
  else{
    show(tabla)
  }
}
```

* Resultados antes:

```{r}
defectos <-c(rep("E",62),rep("B",15),rep("F",3),rep("A",10),rep("C",20),rep("D",10))

qualityTools::paretoChart(defectos)
```

* Resultados ahora:

```{r}
ParetoChart_(defectos)
```

Podemos utilizar parámetros para mostrar la tabla o la gráfica:

```{r}
# Mostrar solo la gráfica
ParetoChart_(defectos, showTable = FALSE)

# Mostrar solo la tabla
ParetoChart_(defectos, showPlot = FALSE)
```

Podemos cambiar los colores de los puntos y las barras:

```{r}
ParetoChart_(defectos, col='blue', border='green')
```

## Fase 2: Medir

### Capacidad de Calibre - MSA Tipo I 

Para poder implementar esta función `cg`, primero debemos modificar 3 funciones que se utilizan en esta función macro.

Además utilizaremos los siguientes datos de pruebas:

```{r}
x <- c(9.991, 10.013, 10.001, 10.007, 10.010, 10.013, 10.008, 10.017, 10.005, 10.005, 10.002, 10.017, 10.005, 10.002, 9.996, 10.011, 10.009, 10.006, 10.008, 10.003, 10.002, 10.006, 10.010, 9.992, 10.013)

target = 10.003
tolerance = c(9.903, 10.103)
ref.interval = pnorm(3) - pnorm(-3)
facCg = 0.2
facCgk = 0.1 
n = 0.2
type = "b"
col = "black"
pch = 19
#xlim = NULL
#ylim = NULL
conf.level = 0.95
cex.val = 1.5
```

```{r}
sd = sd(x)
mean = mean(x)
ref.ar = qnorm(ref.interval, mean, sd) - qnorm(1 - ref.interval,mean, sd)
quant1 = qnorm((1 - ref.interval)/2, mean, sd)
quant2 = qnorm(ref.interval + (1 - ref.interval)/2, mean,sd)
xlim = c(0, length(x))
ylim = c(min(x, target - n/2 * (abs(diff(tolerance))), quant1, quant2),
         max(x, target + n/2 * (abs(diff(tolerance))), quant1, quant2))
```

#### CgRunChart

```{r, echo=FALSE}
cg_RunChart <- function (x, target, tolerance, ref.interval, facCg, facCgk,
                         n = 0.2, type = "b", col = "black", pch = 19,
                         xlim = NULL, ylim = NULL, main = "Run Chart",
                         conf.level = 0.95, cgOut = TRUE)
{
  if (missing(x)) {
    stop("x must be given as a vector")
  }

  if (missing(target)) {
    target <- mean(x)
    targetmissing <- FALSE
  } else {
    targetmissing <- TRUE
  }

  if (missing(ref.interval)) {
    ref.interval <- qnorm(0.99865) - qnorm(0.00135)
  }

  sd <- sd(x)
  mean <- mean(x)
  ref.ar <- qnorm(ref.interval, mean, sd) - qnorm(1 - ref.interval, mean, sd)

  if (missing(facCg)) {
    facCg <- 0.2
  }

  if (missing(facCgk)) {
    facCgk <- 0.1
  }

  if (missing(tolerance)) {
    width <- ref.ar/facCg
    tolerance <- numeric(2)
    tolerance[1] <- mean - width/2
    tolerance[2] <- mean + width/2
  }

  quant1 <- qnorm((1 - ref.interval)/2, mean, sd)
  quant2 <- qnorm(ref.interval + (1 - ref.interval)/2, mean, sd)

  if (length(tolerance) != 2) {
    stop("tolerance has wrong length")
  }

  if (missing(xlim)) {
    xlim <- c(0, length(x))
  }

  if (missing(ylim)) {
    ylim <- c(min(x, target - n/2 * (abs(diff(tolerance))), quant1, quant2),
              max(x, target + n/2 * (abs(diff(tolerance))), quant1, quant2))
  }

  if (missing(main)) {
    main <- "Run Chart"
  }

  Cg <- (facCg * tolerance[2]-tolerance[1])/ref.interval
  Cgk <- (facCgk * abs(target-mean(x))/(ref.interval/2))

  # Create a data frame for plotting
  df <- data.frame(x = x, y = x)

  # Add target line
  df$y_target <- target

  # Calculate the upper and lower control limits
  df$y_lower <- quant1
  df$y_upper <- quant2
  # Calculate the tolerance limits
  df$y_tolerance_lower <- tolerance[1]
  df$y_tolerance_upper <- tolerance[2]

  # Calculate the mean
  df$y_mean <- mean

  # Calculate the Cg and Cgk values
  df$Cg <- Cg
  df$Cgk <- Cgk

  # Create the ggplot
  # 1. Principal plot and target line
  p <- ggplot(df, aes(x = seq_along(x), y = x)) +
    geom_point(color = col, shape = pch) +
    geom_line(color = col, linetype = "solid") +
    scale_x_continuous(limits = c(xlim[1] - 0.05 * xlim[2], xlim[2]), expand = c(0, 0)) +
    labs(title = main, x = "Index", y = "x") +
    theme_minimal() + theme(plot.title = element_text(hjust = 0.5,face = "bold"))+
    geom_hline(aes(yintercept = target)) # Linea target

  # 2. Red Plot (Lowess)
  p <- p + geom_smooth(method = "loess", color = "red", se = FALSE, span = 1.25, size = 0.25,)

  # 3. Green lines
  p <- p + geom_hline(aes(yintercept = mean), linetype = "dashed", color = "seagreen")+  #center line
    geom_hline(aes(yintercept = quant1), linetype = "dashed", color = "seagreen") + # Bottom line
    geom_hline(aes(yintercept = quant2), linetype = "dashed", color = "seagreen")   # Top line
  # 4. Xtar +- 0.1
  p <- p + geom_hline(yintercept = c(target + n/2 * (abs(diff(tolerance))), target - n/2 * (abs(diff(tolerance)))), color = "#012B78", linetype = "solid") # Agregar líneas
  #Label
  p <- p + scale_y_continuous(limits = ylim, expand = c(0, 0),sec.axis =
                                sec_axis(~ .,breaks = c(target,mean,quant1,quant2,target + n/2 * (abs(diff(tolerance))),
                                                        target - n/2 * (abs(diff(tolerance)))),
                                         labels=c("target",
                                                  expression(bar(x)),
                                                  substitute(x[a * b], list(a = round(((1 - ref.interval)/2) * 100, 3), b = "%")),
                                                  substitute(x[a * b], list(a = round(((ref.interval + (1 - ref.interval)/2)) * 100,3), b = "%")),
                                                  substitute(x[tar] + a, list(a = round(n/2, 4))),
                                                  substitute(x[tar] - a, list(a = round(n/2, 4)))))) +
    theme(axis.text.y.right = element_text(size = 15))

  # Label  Cg and Cgk
  if (cgOut == TRUE) {
    caja <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.border = element_blank()
      ) +
      xlim(c(0.25,0.26)) + ylim(c(0.24, 0.31))

    caja <- caja +
      annotate('text', x = 0.25, y = 0.30,
               label = paste("Cg: ", round(Cg,digits = 6)),
               parse = TRUE, size = 3, hjust = 0) +
      annotate('text', x = 0.25, y = 0.25,
               label = paste("Cgk:", round(Cgk,digits = 6)),
               parse = TRUE, size = 3, hjust = 0)

    p <- p + inset_element(caja, left = 0.7, right = 1, top = 1, bottom = 0.75)
    suppressMessages(show(p))
  }
  else{
    suppressMessages(show(p))
  }
  invisible(list(Cg, Cgk))
}
```

* Resultados antes:

```{r}
qualityTools::cgRunChart(x = x, target = target, tolerance = tolerance, 
           ref.interval = ref.interval, facCg = facCg, facCgk = facCgk, 
           n = n, type = type, col = col, pch = pch, xlim = xlim, 
           ylim = ylim, main = "Run Chart", conf.level = conf.level, cgOut = FALSE)
```

* Resultados Ahora:

```{r}
cg_RunChart(x = x, target = target, tolerance = tolerance, 
                    ref.interval = ref.interval, facCg = facCg, facCgk = facCgk, 
                    n = n, type = type, col = col, pch = pch, xlim = xlim, 
                    ylim = ylim, main = "Run Chart", conf.level = conf.level, cgOut = FALSE)
```

#### cgHist

```{r, echo=FALSE}
# Nueva función
cg_HistChart <- function (x, target, tolerance, ref.interval, facCg, facCgk,
                          n = 0.2, col, xlim, ylim, main, conf.level = 0.95, cgOut = TRUE)
{
  if (missing(x))
    stop("x must be given as a vector")
  if (missing(target)) {
    target = mean(x)
    targetmissing = FALSE
  }
  else targetmissing = TRUE
  if (missing(ref.interval))
    ref.interval = pnorm(3) - pnorm(-3)
  sd = sd(x)
  mean = mean(x)
  ref.ar = qnorm(ref.interval, mean, sd) - qnorm(1 - ref.interval,
                                                 mean, sd)
  if (missing(facCg))
    facCg = 0.2
  if (missing(facCgk))
    facCgk = 0.1
  if (missing(tolerance))
    warning("Missing tolerance! The specification limits are choosen to get Cg = 1")
  if (missing(tolerance)) {
    width = ref.ar/facCg
    tolerance = numeric(2)
    tolerance[1] = mean(x) - width/2
    tolerance[2] = mean(x) + width/2
  }
  quant1 = qnorm((1 - ref.interval)/2, mean, sd)
  quant2 = qnorm(ref.interval + (1 - ref.interval)/2, mean,
                 sd)
  if (length(tolerance) != 2)
    stop("tolerance has wrong length")
  if (missing(col))
    col = "lightblue"
  if (missing(xlim))
    xlim = c(0, length(x))
  if (missing(ylim))
    ylim = c(min(x, target - n/2 * (abs(diff(tolerance))),
                 quant1, quant2), max(x, target + n/2 * (abs(diff(tolerance))),
                                      quant1, quant2))
  if (missing(main))
    main = paste("Histogram of", deparse(substitute(x)),
                 "- target")

  Cg <- (facCg * tolerance[2]-tolerance[1])/ref.interval
  Cgk <- (facCgk * abs(target-mean(x))/(ref.interval/2))

  # Calculos previos
  x.c <- x - target
  temp <- hist(x.c, plot = FALSE)
  # Obtenemos la información para el histograma
  df <- data.frame(
    mid = temp$mids,
    density = temp$density
  )
  width <- diff(df$mid)[1] # Ancho de cada barra
  # Histograma
  p <- ggplot(df, aes(x = mid, y = density)) +
    geom_bar(stat = "identity", width = width, fill = "lightblue", color = "black", alpha = 0.5) +
    labs(y = "Density", x = "x.c", title = main) +
    theme_minimal() + theme(plot.title = element_text(hjust = 0.5,face = "bold"))+
    guides(color = guide_legend(title.position = "top", title.hjust = 0.5))
  # Linea x=0
  p <- p + geom_vline(xintercept = 0, color = "red")
  # Intervalos de Confianza - Azules
  test = t.test(x.c, mu = 0, conf.level = conf.level)
  p <- p + geom_vline(aes(xintercept = test$conf.int[1], color = "Confidence interval"), linetype = "dashed", col = "blue") +
    geom_vline(aes(xintercept = test$conf.int[2], color = "Confidence interval"), linetype = "dashed", col = "blue") +
    theme(legend.position = "none")
  # Curva de densidad
  p <- p + geom_line(data = data.frame(x = density(x.c)$x, y = density(x.c)$y), aes(x = x, y = y), color = "black", linewidth = 0.5)

  # Hipotesis, P_val y t_val
  caja <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
    theme_bw() +
    theme(
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.title = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.background = element_rect(fill = "transparent", color = NA),
      plot.background = element_rect(fill = "transparent", color = NA),
      panel.border = element_blank()
    ) +
    xlim(c(0.25,0.26)) + ylim(c(0.24, 0.36))

  caja <- caja +
    annotate('text', x = 0.25, y = 0.35,
             label = paste("H[0]==", "0"),
             parse = TRUE, size = 3, hjust = 0) +
    annotate('text', x = 0.25, y = 0.30,
             label = paste("t-value: ", round(test$statistic, digits = 3)),
             parse = TRUE, size = 3, hjust = 0) +
    annotate('text', x = 0.25, y = 0.25,
             label = paste("p-value: ", round(test$p.value, 3)),
             parse = TRUE, size = 3, hjust = 0)

  p <- p + inset_element(caja, left = 0, right = 0.35, top = 1, bottom = 0.65)

  # Añadir label del Cg y Cgk
  if (cgOut == TRUE) {
    caja <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.border = element_blank()
      ) +
      xlim(c(0.25,0.26)) + ylim(c(0.24, 0.31))

    caja <- caja +
      annotate('text', x = 0.25, y = 0.30,
               label = paste("Cg: ", round(Cg,digits = 6)),
               parse = TRUE, size = 3, hjust = 0) +
      annotate('text', x = 0.25, y = 0.25,
               label = paste("Cgk:", round(Cgk,digits = 6)),
               parse = TRUE, size = 3, hjust = 0)

    p <- p + inset_element(caja, left = 0.7, right = 1, top = 1, bottom = 0.75)
    show(p)
  }
  else{
    caja <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.border = element_blank()
      ) +
      xlim(c(0.25,0.26)) + ylim(c(0.24, 0.31))

    caja <- caja +
      annotate('text', x = 0.25, y = 0.30,
               label = "----- conf. int", size = 3, hjust = 0, colour = "blue")

    p <- p + inset_element(caja, left = 0.75, right = 1, top = 1, bottom = 0.75)
    show(p)
  }
  invisible(list(Cg, Cgk))
}
```

* Resultados Anteriores:

```{r}
qualityTools::cgHist(x = x, target = target, tolerance = tolerance, ref.interval = ref.interval, 
       facCg = facCg, facCgk = facCgk, n = n, col = "lightblue", 
       xlim = xlim, ylim = ylim, main = paste("Histogram of", 
                                              deparse(substitute(x)), "- target"), conf.level
       = conf.level, cgOut = FALSE)
```

* Resultados Ahora:

```{r}
cg_HistChart(x = x, target = target, tolerance = tolerance, ref.interval = ref.interval, 
            facCg = facCg, facCgk = facCgk, n = n, col = "lightblue", 
            xlim = xlim, ylim = ylim, main = paste("Histogram of", 
                                                   deparse(substitute(x)), "- target"),
            conf.level = conf.level, cgOut = FALSE)
```


#### cgToleranceView

```{r, echo=FALSE}
# Nueva Función
cg_ToleranceChart <- function (x, target, tolerance, ref.interval, facCg, facCgk,
                               n = 0.2, type, col, pch, xlim, ylim, main, conf.level = 0.95,
                               cgOut = TRUE)
{
  if (missing(x))
    stop("x must be given as a vector")
  if (missing(target)) {
    target = mean(x)
    targetmissing = FALSE
  }
  else targetmissing = TRUE
  if (missing(ref.interval))
    ref.interval = pnorm(3) - pnorm(-3)
  sd = sd(x)
  mean = mean(x)
  ref.ar = qnorm(ref.interval, mean, sd) - qnorm(1 - ref.interval,
                                                 mean, sd)
  if (missing(facCg))
    facCg = 0.2
  if (missing(facCgk))
    facCgk = 0.1
  if (missing(tolerance))
    warning("Missing tolerance! The specification limits are choosen to get Cg = 1")
  if (missing(tolerance)) {
    width = ref.ar/facCg
    tolerance = numeric(2)
    tolerance[1] = mean(x) - width/2
    tolerance[2] = mean(x) + width/2
  }
  quant1 = qnorm((1 - ref.interval)/2, mean, sd)
  quant2 = qnorm(ref.interval + (1 - ref.interval)/2, mean,
                 sd)
  if (length(tolerance) != 2)
    stop("tolerance has wrong length")
  if (missing(type))
    type = "b"
  if (missing(col))
    col = 1
  if (missing(pch))
    pch = 19
  if (missing(xlim))
    xlim = c(0, length(x))
  if (missing(ylim))
    ylim = c(min(x, target - n/2 * (abs(diff(tolerance))),
                 quant1, quant2), max(x, target + n/2 * (abs(diff(tolerance))),
                                      quant1, quant2))
  if (missing(main))
    main = "Tolerance View"
  Cg <- (facCg * tolerance[2]-tolerance[1])/ref.interval
  Cgk <- (facCgk * abs(target-mean(x))/(ref.interval/2))

  # Gráfica
  p <- ggplot(data.frame(x = 1:length(x), y = x), aes(x = x, y = y)) +
    geom_point(color = col, shape = pch) +
    geom_line(color = col, linetype = "solid")+
    geom_hline(aes(yintercept = target), linetype = "dashed", color = "red") +
    geom_hline(aes(yintercept = tolerance[1]), linetype = "dashed", color = "blue") +
    geom_hline(aes(yintercept = tolerance[2]), linetype = "dashed", color = "blue") +
    geom_hline(aes(yintercept = (target + n/2 * (tolerance[2] - tolerance[1]))), color = "black") +
    geom_hline(aes(yintercept = (target - n/2 * (tolerance[2] - tolerance[1]))), color = "black") +
    scale_color_manual(values = c("Data" = col)) +
    labs(x = "", y = "x", color = "Variable", title = main)+
    theme_bw()+theme(plot.title = element_text(hjust = 0.5,face = "bold"))+
    theme(legend.position = "none")

  if (cgOut == TRUE) {
    caja <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.border = element_blank()
      ) +
      xlim(c(0.25,0.26)) + ylim(c(0.24, 0.31))

    caja <- caja +
      annotate('text', x = 0.25, y = 0.30,
               label = paste("Cg: ", round(Cg,digits = 6)),
               parse = TRUE, size = 3, hjust = 0) +
      annotate('text', x = 0.25, y = 0.25,
               label = paste("Cgk:", round(Cgk,digits = 6)),
               parse = TRUE, size = 3, hjust = 0)

    p <- p + inset_element(caja, left = 0.7, right = 1, top = 1, bottom = 0.75)
    show(p)
  }
  else{
    show(p)
  }
  invisible(list(Cg, Cgk))
}
```

* Resultados Antes:

```{r}
qualityTools::cgToleranceView(x = x, target = target, tolerance = tolerance, 
                ref.interval = ref.interval, facCg = facCg, facCgk = facCgk, 
                n = n, type = type, col = col, pch = pch, xlim = xlim, 
                ylim = ylim, main = "Tolerance View", conf.level = conf.level, cgOut = TRUE)
```

* Resultados Ahora:

```{r}
cg_ToleranceChart(x = x, target = target, tolerance = tolerance, 
                 ref.interval = ref.interval, facCg = facCg, facCgk = facCgk, 
                 n = n, type = type, col = col, pch = pch, xlim = xlim, 
                 ylim = ylim, main = "Tolerance View", conf.level = conf.level, cgOut = TRUE)
```

#### Funcion cg

Ahora la función `cg` se modificará de la siguiente forma: 

```{r, echo=FALSE}
# Funcion Nueva
cg_ <- function (x, target, tolerance, ref.interval, facCg, facCgk, n = 0.2,
                   type, col, pch, xlim, ylim, conf.level = 0.95, cex.val = 1.5)
{
    old.par <- par(no.readonly = TRUE)
    if (missing(x))
      stop("x must be given as a vector")
    if (missing(target)) {
      target = mean(x)
      targetmissing = FALSE
    }
    else
      targetmissing = TRUE
    if (missing(ref.interval))
      ref.interval = pnorm(3) - pnorm(-3)
    sd = sd(x)
    mean = mean(x)
    ref.ar = qnorm(ref.interval, mean, sd) - qnorm(1 - ref.interval,
                                                   mean, sd)
    if (missing(facCg))
      facCg = 0.2
    if (missing(facCgk))
      facCgk = 0.1
    if (missing(tolerance))
      warning("Missing tolerance! The specification limits are choosen to get Cg = 1")
    if (missing(tolerance)) {
      width = ref.ar / facCg
      tolerance = numeric(2)
      tolerance[1] = mean(x) - width / 2
      tolerance[2] = mean(x) + width / 2
    }
    quant1 = qnorm((1 - ref.interval) / 2, mean, sd)
    quant2 = qnorm(ref.interval + (1 - ref.interval) / 2, mean,
                   sd)
    if (length(tolerance) != 2)
      stop("tolerance has wrong length")
    if (missing(type))
      type = "b"
    if (missing(col))
      col = 1
    if (missing(pch))
      pch = 19
    if (missing(xlim))
      xlim = c(0, length(x))
    if (missing(ylim))
      ylim = c(min(x, target - n / 2 * (abs(diff(
        tolerance
      ))),
      quant1, quant2),
      max(x, target + n / 2 * (abs(diff(
        tolerance
      ))),
      quant1, quant2))
    Cg <- (facCg * tolerance[2] - tolerance[1]) / ref.interval
    Cgk <- (facCgk * abs(target - mean(x)) / (ref.interval / 2))

    # Plots

    # RunChart
    df1 <- data.frame(x = x, y = x)
    df1$y_target <- target
    df1$y_lower <- quant1
    df1$y_upper <- quant2
    df1$y_tolerance_lower <- tolerance[1]
    df1$y_tolerance_upper <- tolerance[2]
    df1$y_mean <- mean
    df1$Cg <- Cg
    df1$Cgk <- Cgk
    p1 <- ggplot(df1, aes(x = seq_along(x), y = x)) +
      geom_point(color = col, shape = pch) +
      geom_line(color = col, linetype = "solid") +
      scale_x_continuous(limits = c(xlim[1] - 0.05 * xlim[2], xlim[2]),
                         expand = c(0, 0)) +
      labs(title = "Run Chart", x = "Index", y = "x") +
      theme_minimal() + theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
      geom_hline(aes(yintercept = target)) +
      geom_smooth(
        method = "loess",
        color = "red",
        se = FALSE,
        span = 1.25,
        size = 0.25
      ) +
      geom_hline(aes(yintercept = mean),
                 linetype = "dashed",
                 color = "seagreen") +  #center line
      geom_hline(aes(yintercept = quant1),
                 linetype = "dashed",
                 color = "seagreen") + # Bottom line
      geom_hline(aes(yintercept = quant2),
                 linetype = "dashed",
                 color = "seagreen") +
      geom_hline(
        yintercept = c(target + n / 2 * (abs(diff(
          tolerance
        ))), target - n / 2 * (abs(diff(
          tolerance
        )))),
        color = "#012B78",
        linetype = "solid"
      ) +
      scale_y_continuous(
        limits = ylim,
        expand = c(0, 0),
        sec.axis =
          sec_axis(
            ~ .,
            breaks = c(
              target,
              mean,
              quant1,
              quant2,
              target + n / 2 * (abs(diff(tolerance))),
              target - n / 2 * (abs(diff(tolerance)))
            ),
            labels = c(
              "target",
              expression(bar(x)),
              substitute(x[a * b], list(a = round(((1 - ref.interval) / 2
              ) * 100, 3), b = "%")),
              substitute(x[a * b], list(a = round(((ref.interval + (1 - ref.interval) /
                                                      2)
              ) * 100,
              3), b = "%")),
              substitute(x[tar] + a, list(a = round(n / 2, 4))),
              substitute(x[tar] - a, list(a = round(n / 2, 4)))
            )
          )
      ) + theme(axis.text.y.right = element_text(size = 15))

    # HistChart
    x.c <- x - target
    temp <- hist(x.c, plot = FALSE)
    df3 <- data.frame(mid = temp$mids,
                      density = temp$density)
    width <- diff(df3$mid)[1] # Ancho de cada barra
    p3 <- ggplot(df3, aes(x = mid, y = density)) +
      geom_bar(
        stat = "identity",
        width = width,
        fill = "lightblue",
        color = "black",
        alpha = 0.5
      ) +
      labs(y = "Density", x = "x.c", title = paste("Histogram of",deparse(substitute(x)),"- target")) +
      theme_minimal() + theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
      guides(color = guide_legend(title.position = "top", title.hjust = 0.5)) +
      geom_vline(xintercept = 0, color = "red")

    test = t.test(x.c, mu = 0, conf.level = conf.level)
    p3 <-
      p3 + geom_vline(
        aes(xintercept = test$conf.int[1], color = "Confidence interval"),
        linetype = "dashed",
        col = "blue"
      ) +
      geom_vline(
        aes(xintercept = test$conf.int[2], color = "Confidence interval"),
        linetype = "dashed",
        col = "blue"
      ) +
      theme(legend.position = "none") +
      geom_line(
        data = data.frame(x = density(x.c)$x, y = density(x.c)$y),
        aes(x = x, y = y),
        color = "black",
        linewidth = 0.5
      )

    p3 <-
      p3 + annotation_custom(grob = grid::textGrob(
        label = c(expression(paste(H[0], " : Bias = 0"))),
        x = unit(0.05, "npc") + unit(0.05, "cm"),
        y = unit(1, "npc") - unit(0.05, "cm"),
        just = c("left", "top"),
        gp = grid::gpar(fontsize = 6, fontface = "bold")
      )) +
      annotation_custom(grob = grid::textGrob(
        label = c(paste("t-value: ", round(test$statistic, 3))),
        x = unit(0.05, "npc") + unit(0.05, "cm"),
        y = unit(1, "npc") - unit(0.4, "cm"),
        just = c("left", "top"),
        gp = grid::gpar(fontsize = 6)
      )) +
      annotation_custom(grob = grid::textGrob(
        label = c(paste("p-value: ", round(test$p.value, 3))),
        x = unit(0.05, "npc") + unit(0.05, "cm"),
        y = unit(1, "npc") - unit(0.65, "cm"),
        just = c("left", "top"),
        gp = grid::gpar(fontsize = 6)
      ))

    # Tolerance View
    p4 <-
      ggplot(data.frame(x = 1:length(x), y = x), aes(x = x, y = y)) +
      geom_point(color = col, shape = pch) +
      geom_line(color = col, linetype = "solid") +
      geom_hline(aes(yintercept = target),
                 linetype = "dashed",
                 color = "red") +
      geom_hline(aes(yintercept = tolerance[1]),
                 linetype = "dashed",
                 color = "blue") +
      geom_hline(aes(yintercept = tolerance[2]),
                 linetype = "dashed",
                 color = "blue") +
      geom_hline(aes(yintercept = (target + n / 2 * (
        tolerance[2] - tolerance[1]
      ))), color = "black") +
      geom_hline(aes(yintercept = (target - n / 2 * (
        tolerance[2] - tolerance[1]
      ))), color = "black") +
      scale_color_manual(values = c("Data" = col)) +
      labs(
        x = "",
        y = "x",
        color = "Variable",
        title = "Tolerance View"
      ) +
      theme_minimal() + theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
      theme(legend.position = "none")

    # Data Box
    p2 <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      annotate(
        'text',
        x = 0.25,
        y = 0.40,
        label = paste("bar(x)==", round(mean, 2)),
        parse = TRUE,
        size = 3,
        hjust = 0
      ) +
      annotate(
        'text',
        x = 0.25,
        y = 0.35,
        label = paste("s==", round(sd, 2)),
        parse = TRUE,
        size = 3,
        hjust = 0
      ) +
      annotate(
        'text',
        x = 0.25,
        y = 0.3,
        label = paste("target==", round(target, 5)),
        parse = TRUE,
        size = 3,
        hjust = 0
      ) +
      annotate(
        'text',
        x = 0.25,
        y = 0.25,
        label = paste("C[g]==", round(Cg, 2)),
        parse = TRUE,
        size = 3,
        hjust = 0
      ) +
      annotate(
        'text',
        x = 0.25,
        y = 0.20,
        label = paste("C[gk]==", round(Cgk, 2)),
        parse = TRUE,
        size = 3,
        hjust = 0
      ) +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
      ) +
      xlim(c(0.15, 0.5)) + ylim(c(0.1, 0.5))

    design <- "
  112
  113
  114
  "
    p <- p1 + p2 + p3 + p4 + plot_layout(design = design)

    suppressMessages(show(p))

    invisible(list(Cg, Cgk))
  }

```

* Resultados Antes:

```{r}
x <- c ( 9.991, 10.013, 10.001, 10.007, 10.010, 10.013, 10.008, 10.017, 10.005, 10.005, 10.002,
         10.017, 10.005, 10.002, 9.996, 10.011, 10.009 , 10.006, 10.008, 10.003, 10.002, 10.006, 
         10.010, 9.992, 10.013)

qualityTools::cg(x, target = 10.003, tolerance = c(9.903, 10.103))
```

* Resultados Ahora:

```{r}
cg_(x, target = 10.003, tolerance = c(9.903, 10.103))
```


### Repetibilidad y reproducibilidad del calibre - MSA Tipo II

Dado que en la industriia se realiza un análisis Gage R&R para evaluar la repetibilidad y reproducibilidad de un sistema de medición, fue necesario en esta sección la creación de la clase `gageRR`, con una amplia gama de métodos entre ellos `plot`, además de la creación de dos funciones `gageRRDesign` y `gageRR_`, los resultados se muestran a continuación con la aplicación de un pequeño ejemplo:

```{r, echo=FALSE}
# Funciones auxiliares --------------
.aip <- function(x.factor, trace.factor, response, type = c("l", "p", "b"), legend = TRUE, trace.label = NULL,
                 fixed = FALSE, xlab = deparse(substitute(x.factor)), ylab ="Measurement" , ylim = NULL, lty = 1:length(unique(trace.factor)),
                 col = 1, pch = c(1L:9, 0, letters), xpd = NULL, leg.bg = par("bg"), leg.bty = "o", xtick = FALSE, xaxt = par("xaxt"), axes = TRUE, title = "", plot = TRUE, ...) {
  ylabel <- paste(ylab )
  type <- match.arg(type)

  # Asegurarse de que los factores son realmente factores
  x.factor <- factor(x.factor)
  trace.factor <- factor(trace.factor)

  # Calcular los valores de celda
  cellNew <- tapply(response, list(x.factor, trace.factor), mean)
  cellNew <- as.data.frame(as.table(cellNew))
  colnames(cellNew) <- c("x.factor", "trace.factor", "response")

  # Convertir x.factor a numérico sólo para la visualización, pero mantenerlo como factor en los datos
  cellNew$x.numeric <- as.numeric(cellNew$x.factor)

  # Crear el gráfico
  p <- ggplot(cellNew, aes(x = x.numeric, y = response, group = trace.factor, color = trace.factor, shape = trace.factor, linetype = trace.factor)) +
    geom_line() +
    geom_point(size = 2) +
    # geom_text(aes(label = round(response, 2)), vjust = -0.5) +  # Comentar o eliminar esta línea para ocultar números
    scale_x_continuous(breaks = unique(cellNew$x.numeric), labels = levels(cellNew$x.factor)) +  # Etiquetas de x.factor
    labs(x = xlab, y = ylabel, title = title, color = trace.label, shape = trace.label, linetype = trace.label) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))

  if (!is.null(ylim)) {
    p <- p + ylim(ylim)
  }

  if (legend) {
    p <- p + theme(legend.position="right",
                   legend.background = element_rect(fill = "white", colour = "black"))
  } else {
    p <- p + theme(legend.position = "none")
  }
  if(plot){
    print(p)
  }
  invisible(list(plot = p))
}

.c4 = function(n) {
  if (n > 1 && n < 342)
    sqrt(2/(n - 1)) * (factorial(n/2 - 1)/factorial((n - 1)/2 - 1))
  else stop("n needs to be bigger than 1 and smaller than 342")
}

.mapping = function(x, oldValues, newValues) {
  if (length(oldValues) != length(newValues)) {
    print("old and new")
    print(oldValues)
    print(newValues)
    warning(paste("unequal length of", deparse(substitute(oldValues)), "and", deparse(substitute(newValues))))
  }
  out = numeric(length(x))
  for (i in seq(along = newValues)) {
    index = (x == oldValues[i])
    out[index] = newValues[i]
  }
  return(out)
}

# Definición de la clase gageRR ------------------
gageRR <- R6Class("gageRR",
                  public = list(
                    X = NULL,
                    ANOVA = NULL,
                    RedANOVA = NULL,
                    method = NULL,
                    Estimates = NULL,
                    Varcomp = NULL,
                    Sigma = NULL,
                    GageName = NULL,
                    GageTolerance = NULL,
                    DateOfStudy = NULL,
                    PersonResponsible = NULL,
                    Comments = NULL,
                    b = NULL,
                    a = NULL,
                    y = NULL,
                    facNames = NULL,
                    numO = NULL,
                    numP = NULL,
                    numM = NULL,
                    initialize = function(X, ANOVA = NULL, RedANOVA = NULL, method = NULL, Estimates = NULL, Varcomp = NULL,
                                          Sigma = NULL, GageName = NULL, GageTolerance = NULL, DateOfStudy = NULL,
                                          PersonResponsible = NULL, Comments = NULL, b = NULL, a = NULL, y = NULL,
                                          facNames = NULL, numO = NULL, numP = NULL, numM = NULL) {
                      self$X <- X
                      self$ANOVA <- ANOVA
                      self$RedANOVA <- RedANOVA
                      self$method <- method
                      self$Estimates <- Estimates
                      self$Varcomp <- Varcomp
                      self$Sigma <- Sigma
                      self$GageName <- GageName
                      self$GageTolerance <- GageTolerance
                      self$DateOfStudy <- DateOfStudy
                      self$PersonResponsible <- PersonResponsible
                      self$Comments <- Comments
                      self$b <- b
                      self$a <- a
                      self$y <- y
                      self$facNames <- facNames
                      self$numO <- numO
                      self$numP <- numP
                      self$numM <- numM
                    },
                    show = function() {
                      print(as.data.frame(self$X))
                    },
                    subset = function(i, j) {
                      return(self$X[i, j])
                    },
                    summary = function() {
                      if (all(is.na(self$X$Measurement))) {
                        cat("Gage R&R Summary\n")
                        cat("-----------------\n")
                        cat("Method: ", self$method, "\n")
                        cat("Sigma: ", self$Sigma, "\n")
                        cat("Gage Name: ", self$GageName, "\n")
                        cat("Gage Tolerance: ", self$GageTolerance, "\n")
                        cat("Date of Study: ", self$DateOfStudy, "\n")
                        cat("Person Responsible: ", self$PersonResponsible, "\n")
                        cat("Comments: ", self$Comments, "\n")
                        cat("Operators: ", self$numO, "\n")
                        cat("Parts: ", self$numP, "\n")
                        cat("Measurements per Part: ", self$numM, "\n")
                      } else {
                        cat("\n")
                        cat("Operators:\t", self$numO, "\tParts:\t", self$numP, "\n")
                        cat("Measurements:\t", self$numM, "\tTotal:\t", nrow(self$X), "\n")
                        cat("----------\n")
                      }
                      return(invisible(self))
                    },
                    response = function() {
                      return(self$X$Measurement)
                    },
                    replace_response = function(value) {
                      self$X$Measurement = value
                      return(self)
                    },
                    names = function() {
                      return(names(as.data.frame(self)))
                    },
                    as_data_frame = function() {
                      return(as.data.frame(self))
                    },
                    get_tolerance = function() {
                      return(unlist(self$GageTolerance))
                    },
                    set_tolerance = function(value) {
                      if (!is.numeric(value))
                        stop("GageTolerance needs to be numeric")
                      self$GageTolerance = value
                      return(self)
                    },
                    get_sigma = function() {
                      return(unlist(self$Sigma))
                    },
                    set_sigma = function(value) {
                      if (!is.numeric(value))
                        stop("Sigma needs to be numeric")
                      self$Sigma = value
                      return(self)
                    },
                    plot = function(x, y, main=NULL, xlab=NULL, ylab=NULL, col, lwd, fun = mean, ...){
                      x = self
                      gdo <- x
                      yName <- x$facNames[1]
                      aName <- x$facNames[2]
                      bName <- x$facNames[3]
                      abName <- paste(aName, ":", bName, sep = "")
                      if (missing(col))
                        col <- 2:(length(unique(gdo$b)) + 1)
                      if (missing(lwd))
                        lwd <- 1
                      temp <- NULL
                      Source <- names(gdo$Varcomp)
                      VarComp <- round(as.numeric(gdo$Varcomp), 3)
                      Contribution <- round(as.numeric(gdo$Varcomp) / as.numeric(gdo$Varcomp[length(gdo$Varcomp)]), 3)
                      VarComp <- t(data.frame(gdo$Varcomp))
                      VarCompContrib <- VarComp / gdo$Varcomp$totalVar
                      Stdev <- sqrt(VarComp)
                      StudyVar <- Stdev * gdo$Sigma
                      StudyVarContrib <- StudyVar / StudyVar["totalVar", ]
                      if ((length(gdo$GageTolerance) > 0) && (gdo$GageTolerance > 0)) {
                        ptRatio <- StudyVar / gdo$GageTolerance
                        temp <- data.frame(VarComp, VarCompContrib, Stdev, StudyVar, StudyVarContrib, ptRatio)
                        contribFrame <- data.frame(VarCompContrib, StudyVarContrib, ptRatio)
                        names(temp)[6] <- c("P/T Ratio")
                        row.names(temp) <- c(Source)
                        SNR <- sqrt(2 * (temp["bTob", "VarComp"] / temp["totalRR", "VarComp"]))
                      } else {
                        temp <- data.frame(VarComp, VarCompContrib, Stdev, StudyVar, StudyVarContrib)
                        contribFrame <- data.frame(VarCompContrib, StudyVarContrib)
                      }
                      bTob <- paste(bName, "To", bName, sep = "")
                      Source[Source == "bTob"] <- bTob
                      row.names(contribFrame) <- Source
                      if (gdo$method == "crossed")
                        contribFrame <- contribFrame[-match(c("totalVar", "a", "a_b"), row.names(temp)), ]
                      else contribFrame <- contribFrame[-match(c("totalVar"), row.names(temp)), ]
                      numBars <-ncol(contribFrame)
                      
                      contrib_df <- as.data.frame(contribFrame)
                      contrib_df$component <- rownames(contribFrame)
                      contrib_df <- contrib_df %>% rownames_to_column(var = "Source") %>% filter(Source != "totalVar")
                      ymax <- max(max(contribFrame))
                      main1 <- NA
                      
                      contribFrame_long <- as.data.frame(contribFrame)
                      contribFrame_long$Component <- rownames(contribFrame_long)
                      contribFrame_long <- tidyr::gather(contribFrame_long, key = "Metric", value = "Value", -Component)
                      # 1. Components of Variation --------------------------------------------------
                      p1 <- ggplot(contribFrame_long, aes(x = Component, y = Value, fill = Metric)) +
                        geom_bar(stat = "identity", position = "dodge") +
                        labs(title = ifelse(is.null(main[1]), "Components of Variation", main[1]),
                             x = ifelse(is.null(xlab[1]), "Component", xlab[1]),
                             y = ifelse(is.null(ylab[1]), "", ylab[1])) +
                        theme_bw() +
                        scale_fill_manual(values = col[1:nlevels(factor(contribFrame_long$Metric))]) +
                        theme(legend.position = "top",
                              legend.background = element_rect(fill = "white", colour = "black"),
                              legend.key.size = unit(0.5, "cm"), # reduce the size of the legend key
                              legend.text = element_text(size = 8), # reduce the size of the legend text
                              legend.box.spacing = unit(0.1, 'cm'),
                              plot.title = element_text(hjust = 0.5)
                        )
                      
                      # ----------------------
                      if (gdo$method == "crossed") {
                        # 2. Measurement by part -----------------------------------------
                        main2 <- NA
                        if (missing(main) || is.na(main[2]))
                          main2 <- paste(yName, "by", bName)
                        else main2 <- main[2]
                        xlab2 <- NA
                        if (missing(xlab) || is.na(xlab[2]))
                          xlab2 <- bName
                        else xlab2 <- xlab[2]
                        ylab2 <- NA
                        if (missing(ylab) || is.na(ylab[2]))
                          ylab2 <- yName
                        else ylab2 <- ylab[2]
                        
                        p2 <- suppressWarnings(
                          ggplot(gdo$X, aes_string(x = bName, y = yName)) +
                          geom_boxplot() +
                          stat_summary(fun = median, geom = "line", aes(group = 1), color = "red", linewidth = lwd) +
                          stat_summary(fun = median, geom = "point", color = "red") +
                          labs(title = ifelse(is.null(main2), paste(yName, "by", bName), main2),
                               x = ifelse(is.null(xlab2), bName, xlab2),
                               y = ifelse(is.null(ylab2), yName, ylab2)) +
                          theme_bw() +
                          theme(plot.title = element_text(hjust = 0.5))
                          )
                        
                        # 3. Measurement by operator --------------------------------------------------
                        main3 = NA
                        if (missing(main) || is.na(main[3]))
                          main3 = paste(yName, "by", aName)
                        else main3 = main[3]
                        xlab3 = NA
                        if (missing(xlab) || is.na(xlab[3]))
                          xlab3 = aName
                        else xlab3 = xlab[3]
                        ylab3 = NA
                        if (missing(ylab) || is.na(ylab[3]))
                          ylab3 = yName
                        else ylab3 = ylab[3]
                        
                        p3 <- ggplot(gdo$X, aes_string(x = aName, y = yName)) +
                          geom_boxplot(aes(fill = factor(gdo$X[, 3]))) +
                          stat_summary(fun = median, geom = "line", aes(group = 1), color = "red", linewidth = lwd) +
                          stat_summary(fun = median, geom = "point", color = "red", size = 3) +
                          labs(title = ifelse(is.null(main[3]), paste(yName, "by", aName), main[3]),
                               x = ifelse(is.null(xlab[3]), aName, xlab[3]),
                               y = ifelse(is.null(ylab[3]), yName, ylab[3]),
                               fill = "Factor") +
                          theme_bw() +
                          scale_fill_manual(values = col) +
                          theme(plot.title = element_text(hjust = 0.5), legend.position='none')
                        
                        # 4. X_mean Chart -------------------------------------------------------------------------------
                        agg = aggregate(gdo$X[, yName], list(gdo$X[, aName], gdo$X[, bName]), FUN = mean)
                        tab = table(agg[, 2])
                        sgSize = tab[1]
                        aggSd = aggregate(gdo$X[, yName], list(gdo$X[, bName], gdo$X[, aName]), FUN = sd)
                        tab = table(aggSd[, 2])
                        sm = mean(aggSd[, 3])
                        aggMean = aggregate(gdo$X[, yName], list(gdo$X[, bName], gdo$X[, aName]), FUN = mean)
                        xm = mean(agg[, 3])
                        UCL = xm + ((3 * sm)/(.c4(sgSize) * sqrt(sgSize)))
                        LCL = xm - ((3 * sm)/(.c4(sgSize) * sqrt(sgSize)))
                        values = c(UCL, xm, LCL)
                        
                        p4 <- ggplot(data.frame(x = 1:length(aggMean[, 3]), y = aggMean[, 3]), aes(x, y)) +
                          geom_point(shape = 1) +
                          geom_line() +
                          geom_hline(yintercept = xm, color = 3) +                          # línea xm
                          geom_hline(yintercept = UCL, color = "red") +                     # línea UCL
                          geom_hline(yintercept = LCL, color = "red") +                     # línea LCL
                          labs(x = aName, y = expression(bar(x))) +                         # títulos ejes
                          ggtitle(expression(paste(bar(x), " Chart"))) +                    # título
                          geom_vline(xintercept = cumsum(tab) - 0.5, linetype = "dashed") + # divide categorías A,B C
                          scale_x_continuous(breaks = cumsum(tab), labels = names(tab)) +   # y pone los nombres de las secciones
                          theme_minimal() +
                          theme(plot.title = element_text(hjust = 0.5)) +
                          scale_y_continuous(expand = c(0, 0),
                                             sec.axis = sec_axis(~ ., breaks = c(UCL, xm, LCL),
                                                                 labels= c(paste("UCL =", round(UCL, 2)),
                                                                           paste("X_mean =", round(xm,2)),
                                                                           paste("UCL =", round(UCL, 2))
                                                                 ) )) +
                          theme(axis.text.y.right = element_text(size = 8))
                        
                        # 5. Interaction Operator  -------------------------------------------------
                        main4 <- NA
                        fun = mean
                        if (missing(main) || is.na(main[4]))
                          main4 <- paste("Interaction", abName)
                        else main4 <- main[4]
                        xlab4 <- NA
                        if (missing(xlab) || is.na(xlab[4]))
                          xlab4 <- colnames(gdo$X)[4]
                        else xlab4 <- xlab[4]
                        ylab4 <- NA
                        if (missing(ylab) || is.na(ylab[4]))
                          ylab4 <- paste("mean of", colnames(gdo$X)[5])
                        else ylab4 <- ylab[4]
                        p5 <- .aip(gdo$X[, 4], gdo$X[, 3], response = gdo$X[, 5], xlab = xlab4, ylab = ylab4, title = "Interaction Operator: Part", legend = TRUE,col = col, type = "b", plot = FALSE)
                        
                        # 6. R chart -------------------------------------------------
                        D3 <- c(0, 0, 0, 0, 0, 0.076, 0.136, 0.184, 0.223, 0.256, 0.284, 0.308, 0.329, 0.348)
                        D4 <- c(0, 3.267, 2.574, 2.282, 2.115, 2.004, 1.924, 1.864, 1.816, 1.777, 1.744, 1.716, 1.692, 1.671, 1.652)
                        helpRange = function(x) {
                          return(diff(range(x)))
                        }
                        aggForLimits <- aggregate(gdo$X[, yName], list(gdo$X[, aName], gdo$X[, bName]), FUN = helpRange)
                        Rm <- mean(aggForLimits[, 3])
                        sgSize <- length(unique(gdo$X[, bName]))
                        UCL <- D4[sgSize] * Rm
                        LCL <- D3[sgSize] * Rm
                        agg <- aggregate(gdo$X[, yName], list(gdo$X[, bName], gdo$X[, aName]), FUN = helpRange)
                        agg$Group.1 <- factor(agg$Group.1, levels = unique(agg$Group.1))
                        tab = table(agg[, 2])
                        sgSize = tab[1]
                        
                        p6 <-  ggplot(data.frame(x = 1:length(agg[, 3]), y = agg[, 3]), aes(x, y)) +
                          geom_point(shape = 1) +
                          geom_line() +
                          geom_hline(yintercept = Rm, color = 3) +                          # línea xm
                          geom_hline(yintercept = UCL, color = "red") +                     # línea UCL
                          geom_hline(yintercept = LCL, color = "red") +                     # línea LCL
                          labs(x = aName, y = "R") +                                        # títulos ejes
                          ggtitle("R Chart") +                                              # título
                          geom_vline(xintercept = cumsum(tab) - 0.5, linetype = "dashed") + # divide categorías A,B C
                          scale_x_continuous(breaks = cumsum(tab), labels = names(tab)) +   # y pone los nombres de las secciones
                          theme_bw() +
                          theme(plot.title = element_text(hjust = 0.5)) +
                          scale_y_continuous(expand = c(0, 0),
                                             sec.axis = sec_axis(~ ., breaks = c(UCL, Rm, LCL),
                                                                 labels= c(paste("UCL =", round(UCL, 2)),
                                                                           paste("R_mean =", round(Rm,2)),
                                                                           paste("UCL =", round(UCL, 2))
                                                                 ) )) +
                          theme(axis.text.y.right = element_text(size = 8))
                        
                        # UNION PLOTS -------------
                        p <- p1 + p3 + p5$plot + p2 + p4 + p6 + plot_layout(nrow = 3, byrow = FALSE)
                        
                      }
                      
                      if(gdo$method == "nested"){
                        # 2. Measurement by Part within operator --------------
                        main2 = NA
                        if (missing(main) || is.na(main[2]))
                          main2 = paste(yName, "By", bName, "Within", aName)
                        else main2 = main[2]
                        xlab2 = NA
                        if (missing(xlab) || is.na(xlab[2]))
                          xlab2 = NA
                        else xlab2 = xlab[2]
                        ylab2 = NA
                        if (missing(ylab) || is.na(ylab[2]))
                          ylab2 = yName
                        else ylab2 = ylab[2]
                        agg = aggregate(gdo$X[, yName], list(gdo$X[, bName], gdo$X[, aName]), FUN = function(x){return(x)})
                        
                        plot(1:nrow(agg), main = main2, xlab = xlab2, ylab = ylab2, ylim = range(agg[, 3]), axes = FALSE)
                        axis(2)
                        box()
                        label2 = ""
                        for (i in 1:nrow(agg)) {
                          points(rep(i, length(agg[i, 3])), agg[i, 3])
                          axis(1, at = i, labels = agg[i, 1])
                          if (agg[i, 2] != label2) {
                            axis(1, at = i, labels = agg[i, 2], line = 1, tick = FALSE)
                            label2 = agg[i, 2]
                          }
                        }
                        aggm = aggregate(gdo$X[, yName], list(gdo$X[, bName], gdo$X[, aName]), FUN = mean)
                        lines(aggm[, 3])
                        points(aggm[, 3], pch = 13, cex = 2)
                        
                        # 3. Box Blot Measurement by Operator -----------------
                        main3 = NA
                        if (missing(main) || is.na(main[3]))
                          main3 = paste(yName, "by", aName)
                        else main3 = main[3]
                        xlab3 = NA
                        if (missing(xlab) || is.na(xlab[3]))
                          xlab3 = aName
                        else xlab3 = xlab[3]
                        ylab3 = NA
                        if (missing(ylab) || is.na(ylab[3]))
                          ylab3 = yName
                        else ylab3 = ylab[3]
                        
                        p3 <- ggplot(gdo$X, aes_string(x = aName, y = yName)) +
                          geom_boxplot(aes(fill = factor(gdo$X[, 3]))) +
                          stat_summary(fun = median, geom = "line", aes(group = 1), color = "red", linewidth = lwd) +
                          stat_summary(fun = median, geom = "point", color = "red", size = 3) +
                          labs(title = ifelse(is.null(main[3]), paste(yName, "by", aName), main[3]),
                               x = ifelse(is.null(xlab[3]), aName, xlab[3]),
                               y = ifelse(is.null(ylab[3]), yName, ylab[3]),
                               fill = "Factor") +
                          theme_bw() +
                          scale_fill_manual(values = col) +
                          theme(plot.title = element_text(hjust = 0.5), legend.position='none')
                        
                        
                        
                        
                        # 4. X_mean Chart ----------------------
                        agg = aggregate(gdo$X[, yName], list(gdo$X[, aName], gdo$X[, bName]), FUN = mean)
                        tab = table(agg[, 2])
                        sgSize = tab[1]
                        aggSd = aggregate(gdo$X[, yName], list(gdo$X[, bName], gdo$X[, aName]), FUN = sd)
                        tab = table(aggSd[, 2])
                        sm = mean(aggSd[, 3])
                        aggMean = aggregate(gdo$X[, yName], list(gdo$X[, bName], gdo$X[, aName]), FUN = mean)
                        xm = mean(agg[, 3])
                        UCL = xm + ((3 * sm)/(.c4(sgSize) * sqrt(sgSize)))
                        LCL = xm - ((3 * sm)/(.c4(sgSize) * sqrt(sgSize)))
                        values = c(UCL, xm, LCL)
                        
                        p4 <- ggplot(data.frame(x = 1:length(aggMean[, 3]), y = aggMean[, 3]), aes(x, y)) +
                          geom_point(shape = 1) +
                          geom_line() +
                          geom_hline(yintercept = xm, color = 3) +                          # línea xm
                          geom_hline(yintercept = UCL, color = "red") +                     # línea UCL
                          geom_hline(yintercept = LCL, color = "red") +                     # línea LCL
                          labs(x = aName, y = expression(bar(x))) +                         # títulos ejes
                          ggtitle(expression(paste(bar(x), " Chart"))) +                    # título
                          geom_vline(xintercept = cumsum(tab) - 0.5, linetype = "dashed") + # divide categorías A,B C
                          scale_x_continuous(breaks = cumsum(tab), labels = names(tab)) +   # y pone los nombres de las secciones
                          theme_minimal() +
                          theme(plot.title = element_text(hjust = 0.5)) +
                          scale_y_continuous(expand = c(0, 0),
                                             sec.axis = sec_axis(~ ., breaks = c(UCL, xm, LCL),
                                                                 labels= c(paste("UCL =", round(UCL, 2)),
                                                                           paste("X_mean =", round(xm,2)),
                                                                           paste("UCL =", round(UCL, 2))
                                                                 ) )) +
                          theme(axis.text.y.right = element_text(size = 8))
                        # 5. R Chart --------------------------------------
                        D3 = c(0, 0, 0, 0, 0, 0.076, 0.136, 0.184, 0.223, 0.256, 0.284, 0.308, 0.329, 0.348)
                        D4 = c(0, 3.267, 2.574, 2.282, 2.115, 2.004, 1.924, 1.864, 1.816, 1.777, 1.744, 1.716, 1.692, 1.671, 1.652)
                        helpRange = function(x) {
                          return(diff(range(x)))
                        }
                        aggForLimits = aggregate(gdo$X[, yName], list(gdo$X[, aName], gdo$X[, bName]), FUN = helpRange)
                        Rm = mean(aggForLimits[, 3])
                        UCL = D4[sgSize] * Rm
                        LCL = D3[sgSize] * Rm
                        agg = aggregate(gdo$X[, yName], list(gdo$X[, bName], gdo$X[, aName]), FUN = helpRange)
                        tab = table(agg[, 2])
                        sgSize = tab[1]
                        
                        p5 <-  ggplot(data.frame(x = 1:length(agg[, 3]), y = agg[, 3]), aes(x, y)) +
                          geom_point(shape = 1) +
                          geom_line() +
                          geom_hline(yintercept = Rm, color = 3) +                          # línea xm
                          geom_hline(yintercept = UCL, color = "red") +                     # línea UCL
                          geom_hline(yintercept = LCL, color = "red") +                     # línea LCL
                          labs(x = aName, y = "R") +                                        # títulos ejes
                          ggtitle("R Chart") +                                              # título
                          geom_vline(xintercept = cumsum(tab) - 0.5, linetype = "dashed") + # divide categorías A,B C
                          scale_x_continuous(breaks = cumsum(tab), labels = names(tab)) +   # y pone los nombres de las secciones
                          theme_minimal() +
                          theme(plot.title = element_text(hjust = 0.5)) +
                          scale_y_continuous(expand = c(0, 0),
                                             sec.axis = sec_axis(~ ., breaks = c(UCL, Rm, LCL),
                                                                 labels= c(paste("UCL =", round(UCL, 2)),
                                                                           paste("R_mean =", round(Rm,2)),
                                                                           paste("UCL =", round(UCL, 2))
                                                                 ) )) +
                          theme(axis.text.y.right = element_text(size = 8))
                        
                        # UNION PLOTS -----------------------
                        p <- p1 / (p2 + p3) / (p4 + p5) # p2 falta cambiar a ggplot2
                      }
                      
                      show(p)
                      invisible(list(plot = p))
                    }
                  )
)

# función gageRRdesign modificada -------------
gageRRDesign = function(Operators = 3, Parts = 10, Measurements = 3, method = "crossed", sigma = 6, randomize = TRUE) {
  # Validación de argumentos
  if (!is.numeric(sigma))
    stop("sigma needs to be numeric")
  if (method != "nested" && method != "crossed")
    stop("Unknown method specified. Use 'method = nested' or 'method = crossed'.")
  Measurements <- as.integer(Measurements)
  if (!is.numeric(Measurements) || Measurements <= 0)
    stop("Number of Measurements per Part must be a positive integer.")


  opvec <- factor()
  partvec <- factor()

  yName <- "Measurement"
  aName <- "Operator"
  bName <- "Part"
  abName <- "Operator:Part"

  Operators <- unique(Operators)
  Parts <- unique(Parts)

  if (is.numeric(Operators))
    opvec <- factor(LETTERS[1:Operators[1]])
  if (is.character(Operators))
    opvec <- factor(Operators)

  if (length(unique(opvec)) > 26)
    stop("Too many Operators!")
  if (length(unique(opvec)) < 2)
    stop("Not enough Operators")

  if (is.numeric(Parts))
    partvec <- factor(LETTERS[1:Parts[1]])
  if (is.character(Parts))
    partvec <- factor(Parts)

  if (length(unique(partvec)) > 26)
    stop("Too many Parts!")
  if (length(unique(partvec)) < 2)
    stop("Too few Parts")

  Measurement <- rep(NA, (length(opvec) * length(partvec) * Measurements))
  outFrame <- data.frame()

  if (method == "crossed") {
    temp <- expand.grid(opvec, partvec)
    o <- rep(temp[, 1], Measurements)
    p <- rep(temp[, 2], Measurements)
  } else {
    p <- rep(sort(rep(partvec, length(opvec))), Measurements)
    o <- (rep(opvec, length(Measurement) / length(opvec)))
    p <- p[order(o,p)]
    o <- o[order(o,p)]
  }

  if (randomize)
    outFrame <- data.frame(StandardOrder = 1:length(Measurement), RunOrder = sample(1:length(Measurement), length(Measurement)), Operator = factor(o), Part = factor(p), Measurement)
  else
    outFrame <- data.frame(StandardOrder = 1:length(Measurement), RunOrder = 1:length(Measurement), Operator = factor(o), Part = factor(p), Measurement)

  outFrame <- outFrame[order(outFrame$RunOrder), ]
  # Valores predeterminados
  gageRRObj <- gageRR$new(
    X = outFrame,
    ANOVA = NULL,
    RedANOVA = NULL,
    method = method,
    Estimates = NULL,
    Varcomp = NULL,
    Sigma = sigma,
    GageName = NULL,
    GageTolerance = NULL,
    DateOfStudy = Sys.Date(),
    PersonResponsible = NULL,
    Comments = NULL,
    b = factor(p),
    a = factor(o),
    y = as.numeric(Measurement),
    facNames = c(yName, aName, bName, abName),
    numO = length(unique(opvec)),  # Número de operadores
    numP = length(unique(partvec)),  # Número de partes
    numM = Measurements  # Número de mediciones
  )

  return(gageRRObj)
}

gageRR_ = function(gdo, method = "crossed", sigma = 6, alpha = 0.25, DM = NULL, HM = NULL, tolerance = NULL, dig = 3, ...) {
  method <- method

  yName <- "Measurement"
  aName <- "Operator"
  bName <- "Part"

  abName <- if(method == "crossed") paste(aName, ":", bName, sep = "")
  else if(method == "nested") paste(bName, "(", aName, ")", sep = "")
  else NA

  bTobName <- paste(bName, "to", bName, sep = " ")

  if (is.null(tolerance)) tolerance <- gdo$get_tolerance()

  y <- gdo$X[[yName]]
  a <- gdo$X[[aName]]
  b <- gdo$X[[bName]]

  nestedFormula <- as.formula(paste(yName, "~", aName, "/", bName))
  crossedFormula <- as.formula(paste(yName, "~", aName, "*", bName))
  reducedFormula <- as.formula(paste(yName, "~", aName, "+", bName))

  if (method == "nested") {
    numA <- nlevels(a)
    numB <- nlevels(b)
    numMPP <- length(y) / (numB * numA)

    gdo$numO <- numA
    gdo$numP <- numB
    gdo$numM <- numMPP

    fit <- aov(nestedFormula, data = gdo$X)
    meanSq <- anova(fit)[, 3]

    gdo$ANOVA <- fit
    gdo$method <- "nested"

    MSa <- meanSq[1]
    MSab <- meanSq[2]
    MSe <- meanSq[3]

    Cerror <- MSe
    Cb <- (MSab - MSe) / numMPP
    Ca <- (MSa - MSab) / (numB * numMPP)

    if (Ca <= 0) Ca <- 0
    if (Cb <= 0) Cb <- 0

    Cab <- 0
    totalRR <- Ca + Cab + Cerror
    repeatability <- Cerror
    reproducibility <- Ca
    bTob <- Cb
    totalVar <- Cb + Ca + Cab + Cerror

    estimates <- list(Cb = Cb, Ca = Ca, Cab = Cab, Cerror = Cerror)
    varcomp <- list(totalRR = totalRR, repeatability = repeatability, reproducibility = reproducibility, bTob = bTob, totalVar = totalVar)

    gdo$Estimates <- estimates
    gdo$Varcomp <- varcomp
  }

  if (method == "crossed") {
    numA <- nlevels(a)
    numB <- nlevels(b)
    numMPP <- length(a) / (numA * numB)

    gdo$numO <- numA
    gdo$numP <- numB
    gdo$numM <- numMPP

    fit <- aov(crossedFormula, data = gdo$X)
    model <- anova(fit)

    gdo$ANOVA <- fit
    gdo$method <- "crossed"

    MSb <- MSa <- MSab <- MSe <- 0

    if (bName %in% row.names(model)) MSb <- model[bName, "Mean Sq"]
    else warning(paste("missing factor", bName, "in model"))

    if (aName %in% row.names(model)) MSa <- model[aName, "Mean Sq"]
    else warning(paste("missing factor", aName, "in model"))

    if (abName %in% row.names(model)) MSab <- model[abName, "Mean Sq"]
    else warning(paste("missing interaction", abName, "in model"))

    if ("Residuals" %in% row.names(model)) MSe <- model["Residuals", "Mean Sq"]
    else warning("missing Residuals in model")

    Cb <- Ca <- Cab <- Cerror <- 0

    Cb <- (MSb - MSab) / (numA * numMPP)
    Ca <- (MSa - MSab) / (numB * numMPP)
    Cab <- (MSab - MSe) / numMPP
    Cerror <- (MSe)

    gdo$RedANOVA <- gdo$ANOVA

    if ((Cab < 0) || (model[abName, "Pr(>F)"] >= alpha)) {
      redFit <- aov(reducedFormula, data = gdo$X)
      model <- anova(redFit)

      MSb <- MSa <- MSab <- MSe <- 0

      if (bName %in% row.names(model)) MSb <- model[bName, "Mean Sq"]
      else warning(paste("missing factor", bName, "in model"))

      if (aName %in% row.names(model)) MSa <- model[aName, "Mean Sq"]
      else warning(paste("missing factor", aName, "in model"))

      if ("Residuals" %in% row.names(model)) MSe <- model["Residuals", "Mean Sq"]
      else warning("missing Residuals in model")

      Cb <- Ca <- Cab <- Cerror <- 0

      Cb <- (MSb - MSe) / (numA * numMPP)
      Ca <- (MSa - MSe) / (numB * numMPP)
      Cab <- 0
      Cerror <- (MSe)

      gdo$RedANOVA <- redFit
    }

    gdo$method <- "crossed"
    Ca <- max(0, Ca)
    Cb <- max(0, Cb)
    Cab <- max(0, Cab)

    totalRR <- Ca + Cab + Cerror
    repeatability <- Cerror
    reproducibility <- Ca + Cab
    bTob <- max(0, Cb)
    totalVar <- Cb + Ca + Cab + Cerror

    estimates <- list(Cb = Cb, Ca = Ca, Cab = Cab, Cerror = Cerror)
    varcomp <- list(totalRR = totalRR, repeatability = repeatability, reproducibility = reproducibility, a = Ca, a_b = Cab, bTob = bTob, totalVar = totalVar)

    gdo$Estimates <- estimates
    gdo$Varcomp <- varcomp
  }

  cat("\n")
  cat(paste("AnOVa Table - ", gdo$method, "Design\n"))
  print(summary(gdo$ANOVA))
  cat("\n")
  cat("----------\n")

  if (!identical(gdo$RedANOVA, gdo$ANOVA) && gdo$method == "crossed") {
    cat(paste("AnOVa Table Without Interaction - ", gdo$method, "Design\n"))
    print(summary(gdo$RedANOVA))
    cat("\n")
    cat("----------\n")
  }

  Source <- names(gdo$Varcomp)
  Source[Source == "repeatability"] <- " repeatability"
  Source[Source == "reproducibility"] <- " reproducibility"
  Source[Source == "a_b"] <- paste("  ", abName)
  Source[Source == "a"] <- paste("  ", aName)
  Source[Source == "bTob"] <- bTobName

  VarComp <- round(as.numeric(gdo$Varcomp[c(1:length(gdo$Varcomp))]), 3)
  Contribution <- round(as.numeric(gdo$Varcomp[c(1:length(gdo$Varcomp))]) / as.numeric(gdo$Varcomp[length(gdo$Varcomp)]), 3)
  VarComp <- t(data.frame(gdo$Varcomp))
  VarCompContrib <- VarComp / gdo$Varcomp$totalVar
  Stdev <- sqrt(VarComp)
  StudyVar <- Stdev * gdo$Sigma
  StudyVarContrib <- StudyVar / StudyVar["totalVar", ]
  SNR <- 1
  ptRatio <- NULL
  temp <- NULL

  if ((length(gdo$GageTolerance) > 0) && (gdo$GageTolerance > 0)) {
    ptRatio <- StudyVar / gdo$GageTolerance
    temp <- data.frame(VarComp, VarCompContrib, Stdev, StudyVar, StudyVarContrib, ptRatio)
    names(temp)[6] <- c("P/T Ratio")
    row.names(temp) <- c(Source)
  } else {
    temp <- data.frame(VarComp, VarCompContrib, Stdev, StudyVar, StudyVarContrib)
    row.names(temp) <- c(Source)
  }

  cat("\n")
  cat("Gage R&R\n")
  tempout <- temp
  print(format(tempout, digits = dig))
  cat("\n")
  cat("---\n")
  cat(" * Contrib equals Contribution in %\n")

  SNRTemp <- sqrt(2) * (temp[bTobName, "Stdev"] / temp["totalRR", "Stdev"])
  if (SNRTemp > 1) SNR <- SNRTemp

  cat(paste(" **Number of Distinct Categories (truncated signal-to-noise-ratio) =", floor(SNR), "\n"))
  cat("\n")
  invisible(gdo)
}
```

* Crear un objeto de la clase 'gageRR'

```{r}
mi_gageRR <- gageRR$new(
  X = data.frame(
    Operator = factor(c("A", "B", "C", "A", "B")),
    Part = factor(c("P1", "P1", "P2", "P2", "P3")),
    Measurement = c(10, 12, 11, 13, 9)
  ),
  ANOVA = NULL,  # Esto puede ser NULL inicialmente y luego calcularlo
  RedANOVA = NULL,  # Igual que ANOVA, puede ser NULL inicialmente
  method = "crossed",
  Estimates = list(),
  Varcomp = list(),
  Sigma = 0.5,
  GageName = "Gage1",
  GageTolerance = 0.1,
  DateOfStudy = "2024-05-15",
  PersonResponsible = "John Doe",
  Comments = "Sample gage R&R study",
  b = factor(c("A", "A", "B", "B", "C")),
  a = factor(c("P1", "P1", "P2", "P2", "P3")),
  y = c(10, 12, 11, 13, 9),
  facNames = c("Measurement", "Operator", "Part"),
  numO = 3,
  numP = 3,
  numM = 2
)
```

* Crear el objeto gageRRObj
```{r}
design_example <- gageRRDesign(
  Operators = 3,
  Parts = 10,
  Measurements = 3,
  method = "crossed",
  sigma = 6,
  randomize = TRUE
)
```

* Crear un diseño para el estudio Gage

```{r}
design <- gageRRDesign(Operators = 3, Parts = 10, Measurements = 3, method = "crossed", sigma = 6, randomize = TRUE)
design$X$Measurement <- rnorm(nrow(design$X), mean = 10, sd = 2)

```

* Ejecutar la función `gageRR_`

```{r}
result <- gageRR_(
  gdo = design,
  method = "crossed",   #  método "crossed"
  sigma = 6,            #  sigma
  alpha = 0.25,         # Nivel de significancia
  tolerance = NULL,     # Tolerancia
  dig = 3               # Número de dígitos a mostrar en los resultados
)
```
* Plot del Objeto `gageRR`

```{r}
# verificar que objeto es
class(result)

# Plot
result$plot()
```




## Fase 3: Analizar

#### Capacidad del proceso:

```{r, echo=FALSE}
# -------------- internals.r --------------
.confintbeta= function(xs, thethas, varmatrix, alpha) {
  
  th1= thethas[[1]]
  th2 =  thethas[[2]]
  
  prozent=ppoints(xs)
  
  perzentile=qbeta(prozent, th1, th2)
  
  h=1e-6
  dFdth1=(qbeta(prozent, th1, th2)-qbeta(prozent, th1+h, th2))/h
  dFdth2=(qbeta(prozent, th1, th2)-qbeta(prozent, th1, th2+h))/h
  
  Var = varmatrix[[1, 1]]*dFdth1^2 + 2*varmatrix[[1, 2]]*dFdth1*dFdth2 + varmatrix[[2, 2]]*dFdth2^2
  zalpha=qnorm(1-alpha/2)
  halfwidth = zalpha*sqrt(Var)
  
  lci=perzentile-halfwidth
  uci=perzentile+halfwidth
  
  bounds = list(lci, uci, perzentile)
  
  
  return (bounds)
}
.confintcauchy = function(xs, thethas, varmatrix, alpha) {
  
  th1= thethas[[1]]
  th2 =  thethas[[2]]
  
  prozent=ppoints(xs)
  
  perzentile=qcauchy(prozent, th1, th2)
  
  h=1e-6
  dFdth1=(qcauchy(prozent, th1, th2)-qcauchy(prozent, th1+h, th2))/h
  dFdth2=(qcauchy(prozent, th1, th2)-qcauchy(prozent, th1, th2+h))/h
  
  Var = varmatrix[[1, 1]]*dFdth1^2 + 2*varmatrix[[1, 2]]*dFdth1*dFdth2 + varmatrix[[2, 2]]*dFdth2^2
  zalpha=qnorm(1-alpha/2)
  halfwidth = zalpha*sqrt(Var)
  
  lci=perzentile-halfwidth
  uci=perzentile+halfwidth
  
  bounds = list(lci, uci, perzentile)
  
  return (bounds)
}
.confintexp=function(xs, thethas, varmatrix, alpha) {
  lambda=thethas[[1]]
  prozent=ppoints(xs)
  perzentile=qexp(prozent, lambda)
  logPerzentile = log(perzentile)
  zalpha=qnorm(1-alpha/2)
  halfwidth = zalpha*sqrt(varmatrix[[1, 1]]/lambda^2)
  lci = exp(logPerzentile - halfwidth);
  uci = exp(logPerzentile + halfwidth);
  
  bounds = list(lci, uci, perzentile)
  
  return (bounds)
  
}
.confintgamma= function(xs, thethas, varmatrix, alpha) {
  th1= thethas[[1]]
  th2 =  thethas[[2]]
  prozent=ppoints(xs)
  perzentile=qgamma(prozent, th1, th2)
  
  h=1e-6
  dFdth1=(qgamma(prozent, th1, th2)-qgamma(prozent, th1+h, th2))/h
  dFdth2=(qgamma(prozent, th1, th2)-qgamma(prozent, th1, th2+h))/h
  
  Var = varmatrix[[1, 1]]*dFdth1^2 + 2*varmatrix[[1, 2]]*dFdth1*dFdth2 + varmatrix[[2, 2]]*dFdth2^2
  zalpha=qnorm(1-alpha/2)
  halfwidth = zalpha*sqrt(Var)
  
  lci=perzentile-halfwidth
  uci=perzentile+halfwidth
  
  bounds = list(lci, uci, perzentile)
  
  return (bounds)
}
.confintlnorm=function(xs, thethas, varmatrix, alpha){
  th1= thethas[[1]]
  th2 =  thethas[[2]]
  
  prozent=ppoints(xs)
  
  perzentile=qlnorm(prozent, th1, th2)
  
  zp=qnorm(prozent)
  
  varPerzentile = varmatrix[[1, 1]]+2*varmatrix[[1, 2]]*zp+varmatrix[[2, 2]]*zp*zp
  
  zalpha=qnorm(1-alpha/2)
  lci=log(perzentile)-zalpha*sqrt(varPerzentile)
  uci=log(perzentile)+zalpha*sqrt(varPerzentile)
  
  bounds = list(exp(lci), exp(uci), perzentile)
  
  return (bounds)
  
}
.confintlogis= function(xs, thethas, varmatrix, alpha) {
  
  th1= thethas[[1]]
  th2 =  thethas[[2]]
  
  prozent=ppoints(xs)
  
  
  perzentile=qlogis(prozent, th1, th2)
  
  h=1e-6
  dFdth1=(qlogis(prozent, th1, th2)-qlogis(prozent, th1+h, th2))/h
  dFdth2=(qlogis(prozent, th1, th2)-qlogis(prozent, th1, th2+h))/h
  
  Var = varmatrix[[1, 1]]*dFdth1^2 + 2*varmatrix[[1, 2]]*dFdth1*dFdth2 + varmatrix[[2, 2]]*dFdth2^2
  zalpha=qnorm(1-alpha/2)
  halfwidth = zalpha*sqrt(Var)
  
  lci=perzentile-halfwidth
  uci=perzentile+halfwidth
  
  bounds = list(lci, uci, perzentile)
  
  return (bounds)
}
.confintnorm=function(xs, thethas, varmatrix, alpha){
  
  prozent=ppoints(xs)
  
  zp=qnorm(prozent)
  perzentile=qnorm(prozent, thethas[[1]], thethas[[2]])
  
  varPerzentile = varmatrix[[1, 1]]+2*varmatrix[[1, 2]]*zp+varmatrix[[2, 2]]*zp*zp
  
  zalpha=qnorm(1-alpha/2)
  lci=perzentile-zalpha*sqrt(varPerzentile)
  uci=perzentile+zalpha*sqrt(varPerzentile)
  
  bounds = list(lci, uci, perzentile)
  
  return (bounds)
}
.confintweibull= function(xs, thethas, varmatrix, alpha) {
  th1= thethas[[1]]
  th2 =  thethas[[2]]
  
  prozent=ppoints(xs)
  
  perzentile=qweibull(prozent, th1, th2)
  q=-log(1-prozent)
  logPerzentile=log(perzentile)
  logq=log(q)
  dB=1/th2
  dA=-1/(th1^2)
  
  Var = varmatrix[[1, 1]]*(dA*logq)^2 + 2*varmatrix[[1, 2]]*dB*dA*logq + varmatrix[[2, 2]]*dB^2
  zalpha=qnorm(1-alpha/2)
  halfwidth = zalpha*sqrt(Var)
  
  
  lci=exp(logPerzentile-halfwidth)
  uci=exp(logPerzentile+halfwidth)
  
  bounds = list(lci, uci, perzentile)
  
  # print(data.frame(prozent, uci, perzentile, lci))
  
  return (bounds)
}
.gamma3 = function(data) {
  n=length(data)
  data=sort(data)
  
  pEmp= (seq(1:n)-0.5)/n
  
  weight = 1 / sqrt(pEmp*(1-pEmp))
  
  thld = .99*min(data)
  shape=1
  scale=1
  
  gammaEst = function(param) {
    return( sum(weight*(pgamma(data-param[3], shape = exp(param[1]), scale = exp(param[2]))-pEmp)^2) )
  }
  
  paramEst = optim(c(shape, scale, thld), gammaEst, method = "Nelder-Mead")
  paramEst = paramEst$par
  return(list(shape = exp(paramEst[1]), scale = exp(paramEst[2]), threshold = paramEst[3]))
}
.lognormal3 = function(data) {
  
  n=length(data)
  data=sort(data)
  #compute the empirical cumulative distribution function of the data
  pEmp= (seq(1:n)-0.5)/n
  # will minimize the weighted sum of squared distances
  # so compute weights
  weight = 1 / sqrt(pEmp*(1-pEmp))
  
  # initial values for optimization
  thld = .99*min(data)
  mu0 = mean(log(data-thld))
  sigma0 = sd(log(data-thld))
  
  
  lnEst = function(param) {
    return( sum(weight*(plnorm(data-param[3], meanlog = param[1], sdlog = exp(param[2]))-pEmp)^2) )
  }
  
  logSigma0=log(sigma0)
  # optimize gammaEst using optim function
  paramEst = optim(c(mu0,logSigma0, thld), lnEst, method = "Nelder-Mead")
  param = paramEst$par
  
  return(list(meanlog = param[1], sdlog = exp(param[2]), threshold = param[3]))
}
.weibull3 = function(x){
  if(any(x < 0))
    stop("x must be positive")
  
  n = length(x)
  x = sort(x)
  p = ((1:n)-0.5)/n
  interval = c(0.75*min(x), 0.9999*min(x))
  
  wb3RSquared = function(th)
  {
    return(summary(lm(log(x-th) ~ log(-log(1-p))))$r.squared)
  }
  
  th = (optimize(wb3RSquared, interval = interval, maximum = TRUE))$maximum
  
  lm.1 = lm(log(x-th) ~ log(-log(1-p)))
  estimates = list(shape = 1/coef(lm.1)[[2]], scale = exp(coef(lm.1)[[1]]), threshold = th)
  return(estimates)
}
.charToDistFunc = function(distribution, type = "q") {                                                           
  fun = NULL
  if (identical("beta", distribution))
    fun = eval(parse(text = paste(type, "beta", sep = "")))
  if (identical("cauchy", distribution))
    fun = eval(parse(text = paste(type, "cauchy", sep = "")))
  if (identical("chi-squared", distribution))
    fun = eval(parse(text = paste(type, "chisq", sep = "")))
  if (identical("exponential", distribution))
    fun = eval(parse(text = paste(type, "exp", sep = "")))
  if (identical("f", distribution))
    fun = eval(parse(text = paste(type, "f", sep = "")))
  if (identical("geometric", distribution))
    fun = eval(parse(text = paste(type, "geom", sep = "")))
  if (identical("log-normal", distribution) || identical("lognormal", distribution))         ####
    fun = eval(parse(text = paste(type, "lnorm", sep = "")))
  if (identical("log-normal3", distribution) || identical("lognormal3", distribution))       ####
    fun = eval(parse(text = paste(type, "lnorm3", sep = "")))                              ####
  if (identical("logistic", distribution))
    fun = eval(parse(text = paste(type, "logis", sep = "")))
  if (identical("negative binomial", distribution))
    fun = eval(parse(text = paste(type, "nbinom", sep = "")))
  if (identical("normal", distribution))
    fun = eval(parse(text = paste(type, "norm", sep = "")))
  if (identical("poisson", distribution))
    fun = eval(parse(text = paste(type, "pois", sep = "")))
  if (identical("t", distribution))
    fun = eval(parse(text = paste(type, "t", sep = "")))
  if (identical("weibull", distribution))
    fun = eval(parse(text = paste(type, "weibull", sep = "")))
  if (identical("weibull3", distribution))                                                   ####
    fun = eval(parse(text = paste(type, "weibull3", sep = "")))                            ####
  if (identical("gamma", distribution))
    fun = eval(parse(text = paste(type, "gamma", sep = "")))
  if (identical("gamma3", distribution))
    fun = eval(parse(text = paste(type, "gamma3", sep = "")))
  return(fun)
}
# Funcion FitDistr y .MyADtest----
FitDistr <- function (x, densfun, start, ...){
  myfn <- function(parm, ...) -sum(log(dens(parm, ...)))
  mylogfn <- function(parm, ...) -sum(dens(parm, ..., log = TRUE))
  mydt <- function(x, m, s, df, log) dt((x - m)/s, df, log = TRUE) -
    log(s)
  Call <- match.call(expand.dots = TRUE)
  if (missing(start))
    start <- NULL
  dots <- names(list(...))
  dots <- dots[!is.element(dots, c("upper", "lower"))]
  if (missing(x) || length(x) == 0L || mode(x) != "numeric")
    stop("'x' must be a non-empty numeric vector")
  if (any(!is.finite(x)))
    stop("'x' contains missing or infinite values")
  if (missing(densfun) || !(is.function(densfun) || is.character(densfun)))
    stop("'densfun' must be supplied as a function or name")
  control <- list()
  n <- length(x)
  if (is.character(densfun)) {
    distname <- tolower(densfun)
    densfun <- switch(distname, beta = dbeta, cauchy = dcauchy,
                      `chi-squared` = dchisq, exponential = dexp, f = df,
                      gamma = dgamma, geometric = dgeom, `log-normal` = dlnorm,
                      lognormal = dlnorm, logistic = dlogis, `negative binomial` = dnbinom,
                      normal = dnorm, poisson = dpois, t = mydt, weibull = dweibull,
                      NULL)
    if (is.null(densfun))
      stop("unsupported distribution")
    if (distname %in% c("lognormal", "log-normal")) {
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "log-Normal"), domain = NA)
      if (any(x <= 0))
        stop("need positive values to fit a log-Normal")
      lx <- log(x)
      sd0 <- sqrt((n - 1)/n) * sd(lx)
      mx <- mean(lx)
      estimate <- c(mx, sd0)
      sds <- c(sd0/sqrt(n), sd0/sqrt(2 * n))
      names(estimate) <- names(sds) <- c("meanlog", "sdlog")
      vc <- matrix(c(sds[1]^2, 0, 0, sds[2]^2), ncol = 2,
                   dimnames = list(names(sds), names(sds)))
      names(estimate) <- names(sds) <- c("meanlog", "sdlog")
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dlnorm(x, mx, sd0, log = TRUE))), class = "FitDistr"))
    }
    if (distname == "normal") {
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "Normal"), domain = NA)
      sd0 <- sqrt((n - 1)/n) * sd(x)
      mx <- mean(x)
      estimate <- c(mx, sd0)
      sds <- c(sd0/sqrt(n), sd0/sqrt(2 * n))
      names(estimate) <- names(sds) <- c("mean", "sd")
      vc <- matrix(c(sds[1]^2, 0, 0, sds[2]^2), ncol = 2,
                   dimnames = list(names(sds), names(sds)))
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dnorm(x, mx,
                                                                 sd0, log = TRUE))), class = "FitDistr"))
    }
    if (distname == "poisson") {
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "Poisson"), domain = NA)
      estimate <- mean(x)
      sds <- sqrt(estimate/n)
      names(estimate) <- names(sds) <- "lambda"
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("lambda",
                                                              "lambda"))
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dpois(x, estimate,
                                                                 log = TRUE))), class = "FitDistr"))
    }
    if (distname == "exponential") {
      if (any(x < 0))
        stop("Exponential values must be >= 0")
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "exponential"), domain = NA)
      estimate <- 1/mean(x)
      sds <- estimate/sqrt(n)
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("rate",
                                                              "rate"))
      names(estimate) <- names(sds) <- "rate"
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dexp(x, estimate,
                                                                log = TRUE))), class = "FitDistr"))
    }
    if (distname == "geometric") {
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "geometric"), domain = NA)
      estimate <- 1/(1 + mean(x))
      sds <- estimate * sqrt((1 - estimate)/n)
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("prob",
                                                              "prob"))
      names(estimate) <- names(sds) <- "prob"
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dgeom(x, estimate,
                                                                 log = TRUE))), class = "FitDistr"))
    }
    if (distname == "weibull" && is.null(start)) {
      if (any(x <= 0))
        stop("Weibull values must be > 0")
      lx <- log(x)
      m <- mean(lx)
      v <- var(lx)
      shape <- 1.2/sqrt(v)
      scale <- exp(m + 0.572/shape)
      start <- list(shape = shape, scale = scale)
      start <- start[!is.element(names(start), dots)]
    }
    if (distname == "gamma" && is.null(start)) {
      if (any(x < 0))
        stop("gamma values must be >= 0")
      m <- mean(x)
      v <- var(x)
      start <- list(shape = m^2/v, rate = m/v)
      start <- start[!is.element(names(start), dots)]
      control <- list(parscale = c(1, start$rate))
    }
    if (distname == "negative binomial" && is.null(start)) {
      m <- mean(x)
      v <- var(x)
      size <- if (v > m)
        m^2/(v - m)
      else 100
      start <- list(size = size, mu = m)
      start <- start[!is.element(names(start), dots)]
    }
    if (is.element(distname, c("cauchy", "logistic")) &&
        is.null(start)) {
      start <- list(location = median(x), scale = IQR(x)/2)
      start <- start[!is.element(names(start), dots)]
    }
    if (distname == "t" && is.null(start)) {
      start <- list(m = median(x), s = IQR(x)/2, df = 10)
      start <- start[!is.element(names(start), dots)]
    }
  }
  if (is.null(start) || !is.list(start))
    stop("")
  nm <- names(start)
  f <- formals(densfun)
  args <- names(f)
  m <- match(nm, args)
  if (any(is.na(m)))
    stop("'start' specifies names which are not arguments to 'densfun'")
  formals(densfun) <- c(f[c(1, m)], f[-c(1, m)])
  dens <- function(parm, x, ...) densfun(x, parm, ...)
  if ((l <- length(nm)) > 1L)
    body(dens) <- parse(text = paste("densfun(x,", paste("parm[",
                                                         1L:l, "]", collapse = ", "), ", ...)"))
  Call[[1L]] <- quote(stats::optim)
  Call$densfun <- Call$start <- NULL
  Call$x <- x
  Call$par <- start
  Call$fn <- if ("log" %in% args)
    mylogfn
  else myfn
  Call$hessian <- TRUE
  if (length(control))
    Call$control <- control
  if (is.null(Call$method)) {
    if (any(c("lower", "upper") %in% names(Call)))
      Call$method <- "L-BFGS-B"
    else if (length(start) > 1L)
      Call$method <- "BFGS"
    else Call$method <- "Nelder-Mead"
  }
  res <- eval.parent(Call)
  if (res$convergence > 0L)
    stop("optimization failed")
  vc <- solve(res$hessian)
  sds <- sqrt(diag(vc))
  structure(list(estimate = res$par, sd = sds, vcov = vc,
                 loglik = -res$value, n = n), class = "FitDistr")
}
.myADTest = function(x, distribution, ...) {                                                                     ####   .MYADTESTS-FUNCTION
  #require(MASS, quietly = TRUE)
  if (missing(distribution)) 
    distribution = "normal"
  data.name = names(x)
  if (is.data.frame(x)) 
    x = x[, 1]
  dots = list()
  parameter = NULL
  smaller = NULL
  pFun = NULL
  tableValue = FALSE
  A = 0
  x <- sort(x[complete.cases(x)])
  n = length(x)
  if (n < 8) 
    stop("sample size must be greater than 7")
  if (n > 40) 
    warning("sample size is greater than 40")
  if (is.character(distribution)) {
    pFun = .charToDistFunc(distribution, type = "p")
    distribution = tolower(distribution)
    if (is.null(pFun)) 
      stop(paste(deparse(substitute(distribution)), " is not supported!"))
  }
  else {
    pFun = match.fun(distribution)
  }                                                                      ####
  if (length(dots) == 0) {
    fittedDistr = MASS::fitdistr(x, distribution)
    parameter = fittedDistr$estimate
    if (distribution == "normal") {
      parameter["mean"] = mean(x)
      parameter["sd"] = sd(x)
    }
    p = do.call(pFun, c(list(x), as.list(parameter)))
  }
  else {
    p = pFun(x, ...)
  }
  h = (2 * seq(1:n) - 1) * (log(p) + log(1 - rev(p)))
  A = -n - mean(h)
  AA = (1 + 0.75/n + 2.25/n^2) * A
  if (AA < 0.2) {
    pval <- 1 - exp(-13.436 + 101.14 * AA - 223.73 * AA^2)
  }
  else if (AA < 0.34) {
    pval <- 1 - exp(-8.318 + 42.796 * AA - 59.938 * AA^2)
  }
  else if (AA < 0.6) {
    pval <- exp(0.9177 - 4.279 * AA - 1.38 * AA^2)
  }
  else {
    pval <- exp(1.2937 - 5.709 * AA + 0.0186 * AA^2)
  }
  if (identical(distribution, "cauchy")) {
    pval = NA
  }
  if (identical(distribution, "beta")) {
    pval = NA
  }
  if (identical(distribution, "chi-squared")) {
    pval = NA
  }
  if (identical(distribution, "f")) {
    pval = NA
  }
  if (identical(distribution, "t")) {
    pval = NA
  }
  if (identical(distribution, "geometric")) {
    pval = NA
  }
  if (identical(distribution, "poisson")) {
    pval = NA
  }
  if (identical(distribution, "negative-binomial")) {
    pval = NA
  }
  if (identical(distribution, "weibull")) {
    AWei = A * (1 + 1/sqrt(n))
    tableValue = TRUE
    smaller = TRUE
    if (AWei < 0.474) {
      pval = 0.25
      smaller = FALSE
    }
    if (AWei >= 0.474) 
      pval = 0.25
    if (AWei >= 0.637) 
      pval = 0.1
    if (AWei >= 0.757) 
      pval = 0.05
    if (AWei >= 0.877) 
      pval = 0.025
    if (AWei >= 1.038) 
      pval = 0.01
  }
  if (identical(distribution, "exponential")) {
    AExp = A * (1 + 0.6/n)
    pval = NA
    if (0.95 < AExp) {
      pval = exp(0.731 - 3.009 * AExp + 0.15 * AExp^2)
    }
    if (0.51 < AExp & AExp < 0.95) {
      pval = exp(0.9209 - 3.353 * AExp + 0.3 * AExp^2)
    }
    if (0.26 < AExp & AExp < 0.51) {
      pval = 1 - exp(-6.1327 + 20.218 * AExp - 18.663 * AExp^2)
    }
    if (AExp < 0.26) {
      pval = 1 - exp(-12.2204 + 67.459 * AExp - 110.3 * AExp^2)
    }
  }
  if (identical(distribution, "logistic")) {
    ALogist = A * (1 + 0.25/n)
    tableValue = TRUE
    smaller = TRUE
    if (ALogist < 0.426) {
      pval = 0.25
      smaller = FALSE
    }
    if (ALogist >= 0.426) {
      pval = 0.25
    }
    if (ALogist >= 0.563) {
      pval = 0.1
    }
    if (ALogist >= 0.66) {
      pval = 0.05
    }
    if (ALogist >= 0.769) {
      pval = 0.025
    }
    if (ALogist >= 0.906) {
      pval = 0.01
    }
    if (ALogist >= 1.1) {
      pval = 0.005
    }
  }
  if (identical(distribution, "gamma")) {
    tableValue = TRUE
    gammaDF = data.frame(c(1, 2, 3, 4, 5, 6, 8, 10, 12, 15, 20, Inf), c(0.486, 0.477, 0.475, 
                                                                        0.473, 0.472, 0.472, 0.471, 0.471, 0.471, 0.47, 0.47, 0.47), c(0.657, 0.643, 0.639, 0.637, 
                                                                                                                                       0.635, 0.635, 0.634, 0.633, 0.633, 0.632, 0.632, 0.631), c(0.786, 0.768, 0.762, 0.759, 
                                                                                                                                                                                                  0.758, 0.757, 0.755, 0.754, 0.754, 0.754, 0.753, 0.752), c(0.917, 0.894, 0.886, 0.883, 
                                                                                                                                                                                                                                                             0.881, 0.88, 0.878, 0.877, 0.876, 0.876, 0.875, 0.873), c(1.092, 1.062, 1.052, 1.048, 
                                                                                                                                                                                                                                                                                                                       1.045, 1.043, 1.041, 1.04, 1.039, 1.038, 1.037, 1.035), c(1.227, 1.19, 1.178, 1.173, 
                                                                                                                                                                                                                                                                                                                                                                                 1.17, 1.168, 1.165, 1.164, 1.163, 1.162, 1.161, 1.159))
    names(gammaDF) = c("m", 0.75, 0.9, 0.95, 0.975, 0.99, 0.995)
    critCheck <- gammaDF[min(which(gammaDF$m >= parameter["shape"])), 2:length(gammaDF)] > A
    if (any(critCheck)) {
      firPos <- min(which(critCheck))
    }
    else {
      firPos <- length(gammaDF)
    }
    if (firPos == 1) {
      pValue <- 1 - as.numeric(names(gammaDF)[2])
      pval = pValue
      pValue <- paste(">", pValue)
      smaller = FALSE
    }
    else {
      pValue <- 1 - as.numeric(names(gammaDF)[firPos])
      pval = pValue
      pValue <- paste("<=", pValue)
      smaller = TRUE
    }
  }
  out = list()
  out$data.name = data.name
  out$statistic = as.vector(data.frame(A = A))
  out$parameter = parameter
  out$p.value = as.vector(data.frame(p = pval))
  out$smaller = smaller
  out$tableValue = tableValue
  out$conf.int = NULL
  out$estimate = NULL
  temp = NULL
  if (is.character(distribution)) 
    temp = as.vector(distribution)
  else temp = deparse(substitute(distribution))
  names(temp) = "distribution"
  out$null.value = temp
  out$method = paste("Anderson Darling Test for", temp, "distribution")
  out$class = "adtest"
  invisible(out)
}

# print.adtest ---------------------
print.adtest <- function(x, digits = 4, quote = TRUE, prefix = "", ...) {
  cat("\n")
  cat(strwrap(x$method, prefix = "\t"), sep = "\n")
  cat("\n")
  cat("data: ", x$data.name, "\n")
  out <- character()
  if (!is.null(x$statistic)) 
    out <- c(out, paste(names(x$statistic), "=", format(round(x$statistic[[1]], 4))))
  if (!is.null(x$parameter)) 
    out <- c(out, paste(names(x$parameter), "=", format(round(x$parameter, 3))))
  if (!is.null(x$p.value)) {
    fp <- format.pval(x$p.value[[1]], digits = digits)
    if (x$tableValue) {
      if (x$smaller) 
        out <- c(out, paste("p-value", if (substr(fp, 1L, 1L) == "<") fp else paste("<=", fp)))
      else out <- c(out, paste("p-value", if (substr(fp, 1L, 1L) == "=") fp else paste(">", fp)))
    }
    else {
      out <- c(out, paste("p-value", if (substr(fp, 1L, 1L) == "<") fp else paste("=", fp)))
    }
  }
  cat(strwrap(paste(out, collapse = ", ")), sep = "\n")
  cat("alternative hypothesis: ")
  if (!is.null(x$null.value)) {
    if (length(x$null.value) == 1) {
      cat("true", names(x$null.value), "is not equal to", x$null.value, "\n")
    }
    else {
      cat(x$alternative, "\nnull values:\n")
      print(x$null.value, ...)
    }
  }
  if (!is.null(x$conf.int)) {
    cat(format(100 * attr(x$conf.int, "conf.level")), "percent confidence interval:\n", format(c(x$conf.int[1L], x$conf.int[2L])), "\n")
  }
  if (!is.null(x$estimate)) {
    cat("sample estimates:\n")
    print(x$estimate, ...)
  }
  cat("\n")
  invisible(x)
} 

# Class Distr ----
Distr <- R6Class("Distr",
                 public = list(
                   x = NULL,
                   name = NULL,
                   parameters = NULL,
                   sd = NULL,
                   n = NULL,
                   loglik = NULL,
                   
                   initialize = function(x, name, parameters, sd, n, loglik) {
                     self$x <- x
                     self$name <- name
                     self$parameters <- parameters
                     self$sd <- sd
                     self$n <- n
                     self$loglik <- loglik
                   },
                   
                   plot = function(main = NULL, xlab = NULL, xlim = NULL, ylim = NULL, ylab = NULL, line.col = "red", box=TRUE,line.width = 1, ...)
                   {
                     object <- self
                     xVals <- object$x
                     parameters <- object$parameters
                     lq <- NULL
                     uq <- NULL
                     y <- NULL
                     
                     if (missing(line.col)) {
                       line.col <- "red"
                     }
                     if (missing(line.width)) {
                       line.width <- 1
                     }
                     if (missing(main)) {
                       main <- object$name
                     }
                     if (missing(xlab)) {
                       xlab <- "x"
                     }
                     if (missing(ylab)) {
                       ylab <- "Density"
                     }
                     
                     distr <- object$name
                     qFun <- .charToDistFunc(distr, type = "q")
                     dFun <- .charToDistFunc(distr, type = "d")
                     adTestStats <- .myADTest(xVals, distr)
                     
                     if (class(adTestStats) == "adtest") {
                       A <- adTestStats$statistic
                       p <- adTestStats$p.value
                     } else {
                       A <- NA
                       p <- NA
                     }
                     
                     histObj <- hist(xVals, plot = FALSE)
                     df <- data.frame(
                       mid = histObj$mids,
                       density = histObj$density
                     )
                     width <- diff(df$mid)[1]
                     
                     if (missing(xlim)) {
                       lq <- do.call(qFun, c(list(1e-04), as.list(parameters)))
                       uq <- do.call(qFun, c(list(0.9999), as.list(parameters)))
                       xlim <- range(lq, uq, xVals)
                     }
                     
                     xPoints <- seq(xlim[1], xlim[2], length = 200)
                     yPoints <- do.call(dFun, c(list(xPoints), as.list(parameters)))
                     
                     if (missing(ylim)) {
                       ylim <- range(0, histObj$density, yPoints)
                     }
                     
                     # Histograma
                     p1 <- ggplot(df, aes(x = mid, y = density)) +
                       geom_bar(stat = "identity", width = width, fill = "lightblue", color = "black", alpha = 0.5) +
                       labs(y = ylab, x = xlab, title = main) + xlim(xlim) + ylim(ylim) +
                       theme_minimal() + theme(plot.title = element_text(hjust = 0.5,face = "bold"))+
                       guides(color = guide_legend(title.position = "top", title.hjust = 0.5))+
                       geom_line(data = data.frame(x = xPoints, y = yPoints), aes(x = x, y = y), color = line.col, linewidth = line.width) + # densidad
                       theme(legend.position = "none")
                     
                     # Caja de Info
                     if (box==FALSE) {
                       p1
                     }
                     else {
                       p2 <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
                         theme_bw() +
                         theme(
                           axis.text = element_blank(),
                           axis.ticks = element_blank(),
                           axis.title = element_blank(),
                           panel.grid.major = element_blank(),
                           panel.grid.minor = element_blank()
                         ) +
                         xlim(c(0.25,0.26)) + ylim(c(0.19, 0.36))
                       {
                         # n y A
                         p2 <- p2 +
                           annotate('text', x = 0.25, y = 0.25,
                                    label = paste("A==", round(as.numeric(A), digits = 3)),
                                    parse = TRUE, size = 3, hjust = 0)
                         # p
                         if (!is.null(adTestStats$smaller) && adTestStats$smaller){
                           p2 <- p2 +
                             annotate('text',x = 0.25,y = 0.20,
                                      label = paste("p<", round(as.numeric(p), digits =3)),
                                      parse = TRUE,size = 3,hjust = 0)
                         }
                         if (!is.null(adTestStats$smaller) && !adTestStats$smaller){
                           p2 <- p2 +
                             annotate('text',x = 0.25, y = 0.20,
                                      label = paste("p>=", round(as.numeric(p),digits = 3)),
                                      parse = TRUE,size = 3,hjust = 0)
                         }
                         if (is.null(adTestStats$smaller)){
                           p2 <- p2 +
                             annotate('text',x = 0.25,y = 0.20,
                                      label = paste("p==", round(as.numeric(p), digits = 3)),
                                      parse = TRUE,size = 3,hjust = 0)
                         }
                         
                         # mean y sd
                         p2 <- p2 + annotate('text', x = 0.25, y = 0.35,
                                             label = paste("mean==", round(self$parameters[[1]], digits = 3)),
                                             parse = TRUE, size = 3, hjust = 0) +
                           annotate('text', x = 0.25, y = 0.30,
                                    label = paste("sd==", round(self$parameters[[2]], digits = 3)),
                                    parse = TRUE, size = 3, hjust = 0)
                         }
                       
                       p1 + inset_element(p2, left = 0.7, right = 1, top = 1, bottom = 0.60)
                     }
                   }
                 )
)

# Class DistrCollection ----
DistrCollection <- R6::R6Class("DistrCollection",
                               public = list(
                                 distr = NULL,
                                 initialize = function() {
                                   self$distr <- list()
                                 },
                                 add = function(distr) {
                                   self$distr <- append(self$distr, list(distr))
                                 },
                                 get = function(i) {
                                   self$distr[[i]]
                                 },
                                 show = function() {
                                   cat("\n")
                                   for (i in seq_along(self$distr)) {
                                     temp <- self$distr[[i]]
                                     cat("\n")
                                     cat("fitted distribution is", temp$name, ":\n")
                                     print(temp$parameters)
                                     cat("\n")
                                   }
                                 },
                                 summary = function() {
                                   numDist <- length(self$distr)
                                   gofMatrix <- data.frame(matrix(nrow = numDist, ncol = 3))
                                   names(gofMatrix) <- c("Distribution", "A", "p.value")
                                   cat("\n------ Fitted Distribution and estimated parameters ------\n")
                                   for (i in seq_along(self$distr)) {
                                     distrObj <- self$distr[[i]]
                                     x <- distrObj$x
                                     distribution <- distrObj$name
                                     parameters <- distrObj$parameters
                                     statistic <- NA
                                     p.value <- NA
                                     temp <- .myADTest(x, distribution)
                                     try(statistic <- as.numeric(temp$statistic), silent = TRUE)
                                     try(p.value <- as.numeric(temp$p.value), silent = TRUE)
                                     gofMatrix[i, ] <- c(distribution, as.numeric(statistic), as.numeric(p.value))
                                     cat("\n")
                                     cat("fitted distribution is", distribution, ":\n")
                                     print(parameters)
                                   }
                                   cat("\n")
                                   cat("\n------ Goodness of Fit - Anderson Darling Test ------\n")
                                   cat("\n")
                                   gofMatrixPrint <- gofMatrix
                                   gofMatrixPrint[, 2] <- signif(as.numeric(gofMatrixPrint[, 2]), 4)
                                   gofMatrixPrint[, 3] <- signif(as.numeric(gofMatrixPrint[, 3]), 4)
                                   print(gofMatrixPrint)
                                 },
                                 plot = function(xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL, line.col = "red", line.width = 1, box = TRUE , ...) {
                                   distrList <- self$distr
                                   numDist <- length(self$distr)
                                   numColWin <- ceiling(numDist/2)
                                   if (missing(xlim)) {
                                     xlim <- .xyLimits(self)$xlim
                                   }
                                   if (missing(ylim)) {
                                     ylim <- .xyLimits(self)$ylim
                                   }
                                   if (missing(line.col)) {
                                     line.col <- "red"
                                   }
                                   if (missing(line.width)) {
                                     line.width <- 1
                                   }
                                   p <- distrList[[1]]$plot(xlab = xlab, ylab = ylab, line.col = line.col, line.width = line.width, box = box)
                                   for (i in 2:length(distrList)) {
                                     p <- p+distrList[[i]]$plot(xlab = xlab, ylab = ylab, line.col = line.col, line.width = line.width, box = box)
                                   }
                                   p
                                 }
                               )
)


# Funcion Distribution ----
distribution <- function(x = NULL, distrib = "weibull", start, ...) {
  distr_coll <- DistrCollection$new()
  if (is.character(distrib))
    distrib = tolower(distrib)
  allDistr = c("beta", "cauchy", "chi-squared", "exponential", "f", "gamma", "geometric", "log-normal", "logistic", "negative binomial", "normal", "poisson",
               "t", "weibull")
  if (distrib %in% allDistr){
    distrVec = distrib
  }
  else{distrVec = c("normal")}
  if (identical(distrib, "all"))
    distrVec = allDistr
  if (identical(distrib, "quality"))
    distrVec = c("normal", "log-normal", "exponential", "weibull")
  for (i in seq(along = distrVec)) {
    temp <- suppressWarnings(FitDistr(x, densfun = distrVec[i]))
    fit <- Distr$new(x = x,
                     name = distrVec[i],
                     parameters = temp$estimate,
                     sd = temp$sd,
                     loglik = temp$loglik,
                     n = length(x))
    distr_coll$add(fit)
  }
  return(distr_coll)
}

# Funciones necesarias
.sdSg = function(x, grouping = NULL, method = c("NOWEIGHT", "MVLUE", "RMSDF"), na.rm = TRUE, DB = TRUE) {
  DB = FALSE
  if (!is.data.frame(x) && !is.vector(x) && is.numeric(x))
    stop("x needs to be either a data.frame or a vector and numeric")
  if (is.null(grouping)) {
    if (is.data.frame(x))
      return(sd(x[, 1]))
    else return(sd(x))
  }
  else grouping = as.data.frame(grouping)
  group = unique(grouping)
  sdVec = numeric(length = length(group))
  for (i in 1:nrow(group)) {
    if (is.data.frame(x))
      temp = x[group[i, 1] == grouping[, 1], 1]
    if (is.vector(x))
      temp = x[group[i, 1] == grouping[, 1]]
    sdVec[i] = sd(temp, na.rm = T)/.c4(length(temp[!is.na(temp)]))
    if (DB) {
      print(group[i, 1])
      print(temp)
      print(length(temp[!is.na(temp)]))
    }
  }
  if (DB) {
    print(paste("std.dev: ", mean(sdVec)))
    print(sdVec)
  }
  return((mean(sdVec)))
}
.lfkp = function(wholeList, filterList) {
  if (!is.list(wholeList))
    stop(paste(deparse(substitute(wholeList)), "is not a list!"))
  if (length(wholeList) == 0)
    return(wholeList)
  if (!is.list(filterList))
    stop(paste(deparse(substitute(filterList)), "is not a list!"))
  if (length(filterList) == 0)
    return(filterList)
  logVec = lapply(names(wholeList), "%in%", names(filterList))
  filteredList = wholeList[unlist(logVec)]
  return(filteredList)
}
.lfrm = function(wholeList, filterList) {
  if (!is.list(wholeList))
    stop(paste(deparse(substitute(wholeList)), "is not a list!"))
  if (length(wholeList) == 0)
    return(wholeList)
  if (!is.list(filterList))
    stop(paste(deparse(substitute(filterList)), "is not a list!"))
  if (length(filterList) == 0)
    return(wholeList)
  logVec = lapply(names(wholeList), "%in%", names(filterList))
  filteredList = wholeList[!unlist(logVec)]
  return(filteredList)
}
# Funcion .xyLimits -------------------
.xyLimits = function(distrCollection, lowerquantile = 0.001, upperquantile = 0.999) {
  x <- NULL
  y <- NULL
  for (i in seq_along(distrCollection$distr)) {
    object <- distrCollection$distr[[i]]
    xValues <- object$x
    parameters <- object$parameters
    distr <- object$name
    qFun <- .charToDistFunc(distr, type = "q")
    dFun <- .charToDistFunc(distr, type = "d")
    lq <- do.call(qFun, c(list(lowerquantile), as.list(parameters)))
    uq <- do.call(qFun, c(list(upperquantile), as.list(parameters)))
    x <- range(x, xValues, lq, uq)
    histObj <- hist(xValues, plot = FALSE)
    xPoints <- seq(x[1], x[2], length = 200)
    yPoints <- do.call(dFun, c(list(xPoints), as.list(parameters)))
    y <- range(y, 0, histObj$density, yPoints)
  }
  invisible(list(xlim = x, ylim = y))
}

# Funcion qqPlot ---------------------
qqPlot <- function(x, y, confbounds = TRUE, alpha, main, xlab, ylab, xlim, ylim, border = "red", bounds.col = "black", bounds.lty = 1, start, grapic = TRUE, axis.y.right = FALSE, bw.theme = FALSE,...){
  DB = FALSE
  parList = list()
  if (is.null(parList[["col"]])){
    parList$col = 1:2
  }
  if (is.null(parList[["pch"]])){
    parList$pch = 19
  }
  if (is.null(parList[["lwd"]])){
    parList$lwd = 0.5
  }
  if (is.null(parList[["cex"]])){
    parList$cex = 1
  }
  if(inherits(x, "DistrCollection")){
    distList <- x$distr
    grap <- qqPlot(distList[[1]]$x, grapic = FALSE, ylab = "", xlab = "", main = paste(distList[[1]]$name,"distribution"))
    for (i in 2:length(distList)){
      aux <- qqPlot(distList[[i]]$x, grapic = FALSE, ylab = "", xlab = "", main = paste(distList[[i]]$name,"distribution"))
      grap$plot <-  grap$plot + aux$plot
    }
    show(grap$plot + plot_annotation(title = "QQ Plot for a Collection Distribution"))
    invisible()
  }
  else{
    if (missing(y))
      y = "normal"
    if(missing(alpha))
      alpha = 0.05
    if (alpha <=0 || alpha >=1)
      stop(paste("alpha should be between 0 and 1!"))
    if (missing(main))
      main = paste("QQ Plot for", deparse(substitute(y)), "distribution")
    if (missing(xlab))
      xlab = paste("Quantiles for", deparse(substitute(x)))
    if (missing(ylab))
      ylab = paste("Quantiles from", deparse(substitute(y)), "distribution")
    if (is.numeric(y)) {
      cat("\ncalling (original) qqplot from namespace stats!\n")
      return(stats::qqplot(x, y, ...))
    }
    qFun = NULL
    theoretical.quantiles = NULL
    xs = sort(x)
    distribution = tolower(y)
    distWhichNeedParameters = c("weibull", "logistic", "gamma","exponential", "f",
                                "geometric", "chi-squared", "negative binomial",
                                "poisson")
    
    threeParameterDistr = c("weibull3", "lognormal3", "gamma3")
    threeParameter = distribution %in% threeParameterDistr
    if(threeParameter) distribution = substr(distribution, 1, nchar(distribution)-1)
    if(is.character(distribution)){
      qFun = .charToDistFunc(distribution, type = "q")
      if (is.null(qFun))
        stop(paste(deparse(substitute(y)), "distribution could not be found!"))
    }
    # Puntos teoricos
    theoretical.probs = ppoints(xs)
    # Quantiles
    xq = NULL
    yq = quantile(xs, prob = c(0.25, 0.75))
    
    
    dots <- list(...)
    
    if(TRUE){
      if (DB)
        print("TODO: Pass the estimated parameters correctly")
      fitList = .lfkp(parList, formals(qFun))
      fitList$x = xs
      fitList$densfun = distribution
      if(!missing(start))
        fitList$start = start
      if(DB){
        print(fitList)
        print("Ende")
      }
      if(!threeParameter){
        fittedDistr = do.call(FitDistr, fitList)
        parameter = fittedDistr$estimate
        
        #save the distribution parameter#
        thethas = fittedDistr$estimate
        # save the cariance-covariance matrix
        varmatrix = fittedDistr$vcov
        
      }else{
        parameter = do.call(paste(".",distribution, "3", sep = ""), list(xs) )    ####
        threshold = parameter$threshold
      }
      
      parameter = .lfkp(as.list(parameter), formals(qFun))
      params = .lfkp(parList, formals(qFun))
      parameter = .lfrm(as.list(parameter), params)
      parameter = c(parameter, params)
      theoretical.quantiles = do.call(qFun, c(list(c(theoretical.probs)), parameter))
      
      if(!threeParameter){
        confIntCapable = c("exponential", "log-normal", "logistic", "normal", "weibull", "gamma", "beta", "cauchy")
        getConfIntFun = .charToDistFunc(distribution, type = ".confint")
        if(confbounds == TRUE){
          if(distribution %in% confIntCapable){
            confInt = getConfIntFun(xs, thethas, varmatrix, alpha)
          }
        }
      }
      
      xq <- do.call(qFun, c(list(c(0.25, 0.75)), parameter))
      if (DB) {
        print(paste("parameter: ", parameter))
        print(xq)
      }
    }
    else {
      params =.lfkp(parList, formals(qFun))
      params$p = theoretical.probs
      theoretical.quantiles = do.call(qFun, params)
      params$p = c(0.25, 0.75)
      xq = do.call(qFun, params)
    }
    
    params =.lfkp(parList, c(formals(plot.default), par()))
    
    if(!threeParameter){
      params$y = theoretical.quantiles
    }else{
      params$y = theoretical.quantiles+threshold
    }
    params$x = xs
    params$xlab = xlab
    params$ylab = ylab
    params$main = main
    if (!(is.null(params$col[1]) || is.na(params$col[1])))
      params$col = params$col[1]
    
    params$lwd = 1
    
    ############ Desde Aquí comienza la gráfica ############
    p <- ggplot(data = data.frame(x=params$x, y=params$y), mapping=aes(x=x, y=y)) +
      geom_point() + labs(x = xlab, y = ylab, title = main) + 
      theme_minimal() +
      theme(plot.title = element_text(hjust = 0.5))
    
    params =.lfkp(parList, c(formals(abline), par()))
    params$a = 0
    params$b = 1
    params$col = border
    p <- p + geom_abline(intercept = params$a, slope = params$b, col = params$col, lwd = params$lwd)
    
    if(!threeParameter){
      if(confbounds == TRUE){
        if(distribution %in% confIntCapable){
          params =.lfkp(parList, c(formals(lines), par()))
          params$x = confInt[[3]]
          params$y = confInt[[1]]
          params$col = bounds.col
          params$lty = bounds.lty
          # La curva de abajo
          p <- p + geom_line(data = data.frame(x=params$x, y=params$y), aes(x = x, y = y),
                             col = params$col, lty = params$lty, lwd = params$lwd)
          params$x = confInt[[3]]
          params$y = confInt[[2]]
          params$col = bounds.col
          params$lty = bounds.lty
          # curva de arriba
          p <- p + geom_line(data = data.frame(x=params$x, y=params$y), aes(x = x, y = y),
                             col = params$col, lty = params$lty, lwd = params$lwd)
        }
      }
    }
    if(axis.y.right){
      p <- p + scale_y_continuous(position = "right")
    }
    if(bw.theme){
      p <- p + theme_bw() +
      theme(plot.title = element_text(hjust = 0.5))
    }
    if(main == ""){
      p <- p + labs(title = NULL)
    }
    if(grapic){
      show(p)
      invisible(list(x = theoretical.quantiles, y = xs, int = params$a, slope = params$b, plot = p))
    }
    else{
      invisible(list(x = theoretical.quantiles, y = xs, int = params$a, slope = params$b, plot = p))
    }
  }
}

# Funcion ppPlot ---------------------
ppPlot <- function (x, distribution, confbounds = TRUE, alpha, probs, main, xlab, ylab, xlim, ylim, border = "red", bounds.col = "black", bounds.lty = 1, start, grapic = TRUE, axis.y.right = FALSE, bw.theme = FALSE,...)
{
  conf.level = 0.95
  conf.lines = TRUE
  if (!(is.numeric(x) | inherits(x, "DistrCollection")))
    stop(paste(deparse(substitute(x)), " needs to be numeric or an object of class distrCollection"))
  parList = list(...)
  if (is.null(parList[["col"]]))
    parList$col = c("black", "red", "gray")
  if (is.null(parList[["pch"]]))
    parList$pch = 19
  if(is.null(parList[["lwd"]]))
    parList$lwd = 1
  if (is.null(parList[["cex"]]))
    parList$cex = 1
  qFun = NULL
  xq = NULL
  yq = NULL
  x1 = NULL
  if(missing(alpha))
    alpha = 0.05
  if (alpha <=0 || alpha >=1)
    stop(paste("alpha should be between 0 and 1!"))
  if (missing(probs))
    probs = ppoints(11)
  else if (min(probs) <= 0 || max(probs) >= 1)
    stop("probs should be values within (0,1)!")
  probs = round(probs, 2)
  if (is.numeric(x)) {
    x1 <- sort(na.omit(x))
    if (missing(xlim))
      xlim = c(min(x1) - 0.1 * diff(range(x1)), max(x1) +0.1 * diff(range(x1)))
  }
  if (missing(distribution))
    distribution = "normal"
  if (missing(ylim))
    ylim = NULL
  if (missing(main))
    main = paste("Probability Plot for", deparse(substitute(distribution)),
                 "distribution")
  if (missing(xlab))
    xlab = deparse(substitute(x))
  if (missing(ylab))
    ylab = "Probability"
  if(inherits(x, "DistrCollection")){
    distList <- x$distr
    grap <- ppPlot(distList[[1]]$x, grapic = FALSE, ylab = "", xlab = "", main = paste(distList[[1]]$name,"distribution"))
    for (i in 2:length(distList)){
      aux <- ppPlot(distList[[i]]$x, grapic = FALSE, ylab = "", xlab = "", main = paste(distList[[i]]$name,"distribution"))
      grap$plot <-  grap$plot + aux$plot
    }
    show(grap$plot + plot_annotation(title = "QQ Plot for a Collection Distribution"))
    invisible()
  }
  distWhichNeedParameters = c("weibull", "gamma", "logistic","exponential","f",
                              "geometric", "chi-squared", "negative binomial",
                              "poisson")
  # new
  threeParameterDistr = c("weibull3", "lognormal3", "gamma3")
  threeParameter = distribution %in% threeParameterDistr
  if(threeParameter) distribution = substr(distribution, 1, nchar(distribution)-1)
  # end new
  if (is.character(distribution)) {
    qFun = .charToDistFunc(distribution, type = "q")
    pFun = .charToDistFunc(distribution, type = "p")
    dFun = .charToDistFunc(distribution, type = "d")
    if (is.null(qFun))
      stop(paste(deparse(substitute(y)), "distribution could not be found!"))
  }
  dots <- list(...)
  if (TRUE) {
    fitList = .lfkp(parList, formals(qFun))
    fitList$x = x1
    fitList$densfun = distribution
    if (!missing(start))
      fitList$start = start
    if(!threeParameter){
      fittedDistr = do.call(FitDistr, fitList)
      parameter = fittedDistr$estimate
      #save the distribution parameter#
      thethas = fittedDistr$estimate
      # save the cariance-covariance matrix
      varmatrix = fittedDistr$vcov
    }else{
      parameter = do.call(paste(".",distribution, "3", sep = ""), list(x1) )    ####
      print(parameter[3])
      threshold = parameter$threshold
    }
    parameter = .lfkp(as.list(parameter), formals(qFun))
    params = .lfkp(parList, formals(qFun))
    parameter = .lfrm(as.list(parameter), params)
    print(parameter)
    parameter = c(parameter, params)
    # new
    if(!threeParameter){
      # array containing names of the distributions, for which conf intervals can be computed
      confIntCapable = c("exponential", "log-normal", "logistic", "normal", "weibull", "gamma", "beta", "cauchy")
      getConfIntFun = .charToDistFunc(distribution, type = ".confint")
      # if possible, compute the conf intervals
      if(confbounds == TRUE){
        if(distribution %in% confIntCapable){
          confInt = getConfIntFun(x1, thethas, varmatrix, alpha)
        }
      }# end of my code
    }
    y = do.call(qFun, c(list(ppoints(x1)), as.list(parameter)))
    yc = do.call(qFun, c(list(ppoints(x1)), as.list(parameter)))
    cv = do.call(dFun, c(list(yc), as.list(parameter)))
    print(cv)
    axisAtY = do.call(qFun, c(list(probs), as.list(parameter)))
    yq = do.call(qFun, c(list(c(0.25, 0.75)), as.list(parameter)))
    xq = quantile(x1, probs = c(0.25, 0.75))
  }
  else {
    params = .lfkp(parList, formals(qFun))
    params$p = ppoints(x1)
    y = do.call(qFun, params)
    params$p = probs
    axisAtY = do.call(qFun, params)
    params$p = c(0.25, 0.75)
    yq = do.call(qFun, params)
    xq = quantile(x1, probs = c(0.25, 0.75))
  }
  params = .lfkp(parList, c(formals(plot.default), par()))
  params$x = x1
  params$y = y
  params$xlab = xlab
  params$ylab = ylab
  params$main = main
  params$xlim = xlim
  params$axes = FALSE
  params$lwd = 1
  if (!(is.null(params$col[1]) || is.na(params$col[1])))
    params$col = params$col[1]
  # PLOT
  p <- ggplot(data.frame(x = x1, y = y), aes(x = x, y = y)) +
    geom_point(size = 1, color = "black") +
    labs(x = xlab, y = ylab, title = main) +
    scale_x_continuous(limits = xlim, expand = c(0, 0)) +
    scale_y_continuous(labels = scales::percent_format(scale = 1/max(x1), suffix = "", accuracy = 0.01))+
    theme_minimal() +
    theme(axis.text.x = element_text(size = 12),
          axis.text.y = element_text(size = 12),
          axis.title.x = element_text(size = 14, face = "bold"),
          axis.title.y = element_text(size = 14, face = "bold"),
          plot.title = element_text(size = 16, face = "bold", hjust = 0.5))
  # Regression line
  params = .lfkp(parList, c(formals(abline), par()))
  if(!threeParameter){
    params$a = 0
  }else{
    params$a = -threshold
  }
  params$b = 1
  params$col = border
  p <- p + geom_abline(intercept = params$a, slope = params$b, color = border)
  if(!threeParameter){
    if(confbounds == TRUE){
      if(distribution %in% confIntCapable){
        params =.lfkp(parList, c(formals(lines), par()))
        params$x = confInt[[3]]
        params$y = confInt[[1]]
        params$col = bounds.col
        params$lty = bounds.lty
        # La curva de abajo
        p <- p + geom_line(data = data.frame(x=params$x, y=params$y), aes(x = x, y = y),
                           col = params$col, lty = params$lty, lwd = params$lwd)
        params$x = confInt[[3]]
        params$y = confInt[[2]]
        params$col = bounds.col
        params$lty = bounds.lty
        # curva de arriba
        p <- p + geom_line(data = data.frame(x=params$x, y=params$y), aes(x = x, y = y),
                           col = params$col, lty = params$lty, lwd = params$lwd)
      }
    }
  }
  if(axis.y.right){
    p <- p + scale_y_continuous(position = "right")
  }
  if(bw.theme){
    p <- p + theme_bw()
  }
  if(main == ""){
    p <- p + labs(title = NULL)
  }
  if(grapic){
    show(p)
    invisible(list(x = x, y = y, int = params$a, slope = params$b, plot = p))
  }
  else{
    invisible(list(x = x, y = y, int = params$a, slope = params$b, plot = p))
  }
}


```


```{r, echo=FALSE}
# nuevas funciones
pcr <- function (x, distribution = "normal", lsl, usl, target, boxcox = FALSE,
                  lambda = c(-5, 5), main, xlim, ylim, grouping = NULL, std.dev = NULL,
                  conf.level = 0.9973002, start, lineWidth = 1, lineCol = "red",
                  lineType = "solid", specCol = "red3", specWidth = 1, cex.text = 2,
                  cex.val = 1.5, cex.col = "darkgray", plot = TRUE, bounds.lty = 3,
                  bounds.col = "red", ...) {
  DB = FALSE
  data.name = deparse(substitute(x))[1]
  
  parList = list(...)
  if (is.null(parList[["col"]]))
    parList$col = "lightblue"
  if (is.null(parList[["border"]]))
    parList$border = 1
  if (is.null(parList[["lwd"]]))
    parList$lwd = 1
  if (is.null(parList[["cex.axis"]]))
    parList$cex.axis = 1.5
  if (missing(lsl))
    lsl = NULL
  if (missing(usl))
    usl = NULL
  if (missing(target))
    target = NULL
  if (missing(lambda))
    lambda = c(-5, 5)
  if (!is.numeric(lambda))
    stop("lambda needs to be numeric")
  if (any(x < 0) && any(distribution == c("beta", "chi-squared",
                                          "exponential", "f", "geometric", "lognormal", "log-normal",
                                          "negative binomial", "poisson", "weibull", "gamma")))
    stop("choosen distribution needs all values in x to be > 0!")
  if (any(x > 1) && distribution == "beta")
    stop("choosen distribution needs all values in x to be between 0 and 1!")
  
  paramsList = vector(mode = "list", length = 0)
  estimates = vector(mode = "list", length = 0)
  varName = deparse(substitute(x))
  dFun = NULL
  pFun = NULL
  qFun = NULL
  cp = NULL
  cpu = NULL
  cpl = NULL
  cpk = NULL
  ppt = NULL
  ppl = NULL
  ppu = NULL
  xVec = numeric(0)
  yVec = numeric(0)
  
  if (is.vector(x))
    x = as.data.frame(x)
  any3distr = FALSE
  not3distr = FALSE
  
  if (distribution == "weibull3" || distribution == "lognormal3" ||
      distribution == "gamma3")
    any3distr = TRUE
  if (distribution != "weibull3" && distribution != "lognormal3" &&
      distribution != "gamma3")
    not3distr = TRUE
  if (boxcox) {
    distribution = "normal"
    if (length(lambda) >= 2) {
      temp = boxcox(x[, 1] ~ 1, lambda = seq(min(lambda),
                                             max(lambda), 1/10), plotit = FALSE)
      i = order(temp$y, decreasing = TRUE)[1]
      lambda = temp$x[i]
    }
    x = as.data.frame(x[, 1]^lambda)
  }
  numObs = nrow(x)
  if (!is.null(grouping))
    if (is.vector(grouping))
      grouping = as.data.frame(grouping)
  center = colMeans(x)
  if (!is.null(x) & !is.null(grouping)) {
    if (nrow(x) != nrow(grouping))
      stop(paste("length of ", deparse(substitute(grouping)),
                 " differs from length of ", varName))
  }
  if (missing(main))
    if (boxcox)
      main = paste("Process Capability using box cox transformation for",
                   varName)
  else main = paste("Process Capability using", as.character(distribution),
                    "distribution for", varName)
  if (is.null(std.dev)) {
    if (is.null(grouping))
      std.dev = .sdSg(x)
    else std.dev = .sdSg(x, grouping)
  }
  if (conf.level < 0 | conf.level > 1)
    stop("conf.level must be a value between 0 and 1")
  confHigh = conf.level + (1 - conf.level)/2
  confLow = 1 - conf.level - (1 - conf.level)/2
  if (DB) {
    print(paste("confHigh:", confHigh))
    print(paste("confLow:", confLow))
  }
  distWhichNeedParameters = c("weibull", "logistic", "gamma",
                              "exponential", "f", "geometric", "chi-squared", "negative binomial",
                              "poisson")
  if (is.character(distribution)) {
    dis = distribution
    if (identical(distribution, "weibull3"))
      dis = "weibull3"
    if (identical(distribution, "gamma3"))
      dis = "gamma3"
    if (identical(distribution, "lognormal3"))
      dis = "lognormal3"
    qFun = .charToDistFunc(dis, type = "q")
    pFun = .charToDistFunc(dis, type = "p")
    dFun = .charToDistFunc(dis, type = "d")
    if (is.null(qFun) & is.null(pFun) & is.null(dFun))
      stop(paste(deparse(substitute(y)), "distribution could not be found!"))
  }
  if (TRUE) {
    if (DB)
      print("TODO: Pass the estimated parameters correctly")
    fitList = vector(mode = "list", length = 0)
    fitList$x = x[, 1]
    fitList$densfun = dis
    if (!missing(start))
      fitList$start = start
    if (not3distr) {
      fittedDistr = do.call(FitDistr, fitList)
      estimates = as.list(fittedDistr$estimate)
      paramsList = estimates
    }
    if (distribution == "weibull3") {
      paramsList = .weibull3(x[, 1])
      estimates = paramsList
    }
    if (distribution == "lognormal3") {
      paramsList = .lognormal3(x[, 1])
      estimates = paramsList
    }
    if (distribution == "gamma3") {
      paramsList = .gamma3(x[, 1])
      estimates = paramsList
    }
    if (DB)
      print(paste("parameter: ", paramsList))
  }
  paramsList = c(paramsList, .lfkp(parList, formals(qFun)))
  if (distribution == "normal") {
    paramsList$mean = center
    paramsList$sd = std.dev
    estimates = paramsList
  }
  if (boxcox) {
    if (!is.null(lsl))
      lsl = lsl^lambda
    if (!is.null(usl))
      usl = usl^lambda
    if (!is.null(target))
      target = target^lambda
  }
  if (is.null(lsl) && is.null(usl)) {
    paramsList$p = confLow
    lsl = do.call(qFun, paramsList)
    paramsList$p = confHigh
    usl = do.call(qFun, paramsList)
  }
  
  if (identical(lsl, usl))
    stop("lsl == usl")
  if (!is.null(lsl) && !is.null(target) && target < lsl)
    stop("target is less than lower specification limit")
  if (!is.null(usl) && !is.null(target) && target > usl)
    stop("target is greater than upper specification limit")
  if (!is.null(lsl) && !is.null(usl))
    if (lsl > usl) {
      temp = lsl
      lsl = usl
      usl = temp
    }
  paramsList$p = c(confLow, 0.5, confHigh)
  paramsListTemp = .lfkp(paramsList, formals(qFun))
  qs = do.call(qFun, paramsListTemp)
  paramsListTemp = .lfkp(paramsList, formals(pFun))
  if (!is.null(lsl) && !is.null(usl))
    cp = (usl - lsl)/(qs[3] - qs[1])
  if (!is.null(usl)) {
    cpu = (usl - qs[2])/(qs[3] - qs[2])
    paramsListTemp$q = usl
    ppu = 1 - do.call(pFun, paramsListTemp)
  }
  if (!is.null(lsl)) {
    cpl = (qs[2] - lsl)/(qs[2] - qs[1])
    paramsListTemp$q = lsl
    ppl = do.call(pFun, paramsListTemp)
  }
  cpk = min(cpu, cpl)
  ppt = sum(ppl, ppu)
  if (DB == TRUE) {
    print(cp)
    print(cpk)
    print(cpu)
    print(cpl)
    print(ppu)
    print(ppl)
    print(ppt)
  }
  
  if(plot==TRUE){
    # ----------------------------- IF PLOT == TRUE -----------------------------------------------------------
    if (missing(xlim)) {
      xlim <- range(x[, 1], usl, lsl)
      xlim <- xlim + diff(xlim) * c(-0.2, 0.2)
    }
    xVec <- seq(min(xlim), max(xlim), length = 200)
    dParamsList = .lfkp(paramsList, formals(dFun))
    dParamsList$x = xVec
    
    yVec = do.call(dFun, dParamsList)
    histObj <- hist(x[, 1], plot = FALSE)
    if (missing(ylim)) {
      ylim <- range(histObj$density, yVec)
      ylim <- ylim + diff(ylim) * c(0, 0.05)
    }
    
    # 1. Histograma --------------------------------------------------------------------------
    # Calculos previos
    x.c <- x[, 1]
    temp <- hist(x.c, plot = FALSE)
    # Obtenemos la información para el histograma
    df <- data.frame(
      mid = temp$mids,
      density = temp$density
    )
    width <- diff(df$mid)[1] # Ancho de cada barra
    # Histograma
    p1 <- ggplot(df, aes(x = mid, y = density)) +
      geom_bar(stat = "identity", width = width, fill = "lightblue", color = "black", alpha = 0.5) +
      labs(y = "", x = "", title = "") +
      theme_minimal() + theme(plot.title = element_text(hjust = 0.5,face = "bold"))+
      guides(color = guide_legend(title.position = "top", title.hjust = 0.5))+
      geom_line(data = data.frame(x = xVec, y = yVec), aes(x = x, y = y), color = "red", linewidth = 0.5) + # densidad
      theme(legend.position = "none")
    
    #  etiquetas de los límites
    if (!is.null(lsl) & !is.null(usl)){
      p1 <- p1 +
        geom_vline(aes(xintercept = usl, color = "Confidence interval"), linetype = "dashed", col = "red") + # USL
        geom_vline(aes(xintercept = lsl, color = "Confidence interval"), linetype = "dashed", col = "red") + # LSL
        scale_x_continuous(limits = xlim, expand = c(0, 0),
                           sec.axis = sec_axis(~ ., breaks = c(lsl, usl),
                                               labels = c(paste("LSL =",format(lsl, digits = 3)), paste("USL =",format(usl, digits = 3)))
                           )) +
        theme(axis.text.y.right = element_text(size = 15))
    }else{
      if(!is.null(lsl)){
        p1 <- p1 +
          geom_vline(aes(xintercept = lsl, color = "Confidence interval"), linetype = "dashed", col = "red") + # LSL
          scale_x_continuous(limits = xlim, expand = c(0, 0),
                             sec.axis = sec_axis(~ ., breaks = lsl, labels = paste("LSL =",format(lsl, digits = 3)) )) +
          theme(axis.text.y.right = element_text(size = 15))
      }
      if(!is.null(usl)){
        p1 <- p1 +
          geom_vline(aes(xintercept = usl, color = "Confidence interval"), linetype = "dashed", col = "red") + # USL
          scale_x_continuous(limits = xlim, expand = c(0, 0),
                             sec.axis = sec_axis(~ ., breaks = usl,labels = paste("USL =",format(usl, digits = 3)))) +
          theme(axis.text.y.right = element_text(size = 15))
      }
    }
    
    # 2. Cajita de info Cp's --------------------------------------------------------------------------
    p2 <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
      ) +
      xlim(c(0.24, 0.26)) + ylim(c(0.21, 0.43))
    {
      if(is.null(cpu))
        p2 <- p2 + annotate('text', x = 0.25, y = 0.40,
                            label = paste("C[pkL] == ", "NA"),
                            parse = TRUE, size = 3.5, hjust = 0.5)
      else p2 <- p2 + annotate('text', x = 0.25, y = 0.40,
                               label = paste("C[pkU]==", round(cpu, 2)),
                               parse = TRUE, size = 3.5, hjust = 0.5)
      if(is.null(cpl))
        p2 <- p2 + annotate('text', x = 0.25, y = 0.35,
                            label = paste("C[pkL] == ", "NA"),
                            parse = TRUE, size = 3.5, hjust = 0.5)
      else p2 <- p2 + annotate('text', x = 0.25, y = 0.35,
                               label = paste("C[pkL]==", round(cpl, 2)),
                               parse = TRUE, size = 3.5, hjust = 0.5)
      if(is.null(cpk))
        p2 <- p2 + annotate('text', x = 0.25, y = 0.30,
                            label = paste("C[pkL] == ", "NA"),
                            parse = TRUE, size = 3.5, hjust = 0.5)
      else p2 <- p2 + annotate('text', x = 0.25, y = 0.30,
                               label = paste("C[pk]==", round(cpk, 2)),
                               parse = TRUE, size = 3.5, hjust = 0.5)
      if(is.null(cp))
        p2 <- p2 + annotate('text', x = 0.25, y = 0.25,
                            label = paste("C[pkL] == ", "NA"),
                            parse = TRUE, size = 3.5, hjust = 0.5)
      else p2 <- p2 + annotate('text',x = 0.25,y = 0.25,
                               label = paste("C[p]==", round(cp, 2)),
                               parse = TRUE,size = 3.5,hjust = 0.5)
      }
    # 3. Cajita de info n, means, sd --------------------------------------------------------------------------
    index = 1:(length(estimates) + 3)
    names(x) = data.name
    if(not3distr){
      names(x) = data.name
      adTestStats = .myADTest(x, distribution)
      A = numeric()
      p = numeric()
      if (adTestStats$class == "adtest"){
        A = adTestStats$statistic$A
        p = adTestStats$p.value$p
      }
      
      # Caja de Info
      p3 <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
        theme_bw() +
        theme(
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          axis.title = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()
        ) +
        xlim(c(0.24, 0.26)) + ylim(c(0.19, 0.43))
      {
        # n y A
        p3 <- p3 + annotate('text', x = 0.25, y = 0.40,
                            label = paste("n==", numObs),
                            parse = TRUE, size = 3, hjust = 0.5) +
          annotate('text', x = 0.25, y = 0.35,
                   label = paste("A==", format(as.numeric(A), digits = 3)),
                   parse = TRUE, size = 3, hjust = 0.5)
        
        # p
        if (!is.null(adTestStats$smaller) && adTestStats$smaller){
          p3 <- p3 + annotate(
            'text',
            x = 0.25,
            y = 0.30,
            label = paste("p<", format(as.numeric(p), digits =3)),
            parse = TRUE,
            size = 3,
            hjust = 0.5
          )
        }
        if (!is.null(adTestStats$smaller) && !adTestStats$smaller){
          p3 <- p3 + annotate(
            'text',
            x = 0.25,
            y = 0.30,
            label = paste("p>=", format(as.numeric(p),digits = 3)),
            parse = TRUE,
            size = 3,
            hjust = 0.5
          )
        }
        if (is.null(adTestStats$smaller)){
          p3 <- p3 + annotate(
            'text',
            x = 0.25,
            y = 0.30,
            label = paste("p==", format(as.numeric(p), digits = 3)),
            parse = TRUE,
            size = 3,
            hjust = 0.5
          )
        }
        
        # mean y sd
        p3 <- p3 + annotate('text', x = 0.25, y = 0.25,
                            label = paste(names(estimates)[1], "==", format(estimates[[names(estimates)[1]]], digits = 3)),
                            parse = TRUE, size = 3, hjust = 0.5) +
          annotate('text', x = 0.25, y = 0.20,
                   label = paste(names(estimates)[2], "==", format(estimates[[names(estimates)[2]]], digits = 3)),
                   parse = TRUE, size = 3, hjust = 0.5)
        }
    }
    if(any3distr){
      p3 <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
        theme_bw() +
        theme(
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          axis.title = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()
        ) +
        xlim(c(0.24, 0.26)) + ylim(c(0.21, 0.43))
      {
        # n y A
        p3 <- p3 + annotate('text', x = 0.25, y = 0.40,
                            label = paste("n==", numObs),
                            parse = TRUE, size = 3, hjust = 0.5) +
          annotate('text', x = 0.25, y = 0.35,
                   label = paste("A = ", "*"),
                   parse = FALSE, size = 3, hjust = 0.5) +
          annotate('text', x = 0.25, y = 0.30,
                   label = paste("p = ", "*"),
                   parse = FALSE, size = 3, hjust = 0.5) +
          annotate('text', x = 0.25, y = 0.25,
                   label = paste("mean==", format(estimates[[1]], digits = 3)),
                   parse = TRUE, size = 3, hjust = 0.5) +
          annotate('text', x = 0.25, y = 0.20,
                   label = paste("sd==", format(estimates[[2]], digits = 3)),
                   parse = TRUE, size = 3, hjust = 0.5)
        }
    }
    
    # 4. qqPlot --------------------------------------------------------------------------
    p4 <- qqPlot(x[, 1], y = distribution, xlab = "", ylab = "", main = "",
                 axes = FALSE, bounds.lty = bounds.lty, bounds.col = bounds.col, grapic = FALSE, axis.y.right = TRUE, bw.theme = TRUE)
    
    # Unimos las 4 primeras gráficas
    main_plot <- p1 + (p2 / p3 / p4$plot) + plot_layout(widths = c(5, 1))
    
    # 5. Cajita de info 4 (Expected Fraction Nonconforming) --------------------------------------------------------------------------
    p5 <- ggplot(data.frame(x = c(-1, 1),y = c(0.5, 5)), aes(x = x, y = y)) +
      theme_bw() +
      ggtitle("Expected Fraction Nonconforming") +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.title = element_text(hjust = 0.5, vjust = -0.5,margin = margin(b = -12),size = 10)
      )
    
    p5_left <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.border = element_blank()
      ) +
      xlim(c(0.25,0.26)) + ylim(c(0.24, 0.36))
    {
      p5_left <- p5_left +
        annotate('text', x = 0.25, y = 0.35, label = "-----", size = 3, hjust = 0, colour = "white")
      # Pt
      p5_left <- p5_left +
        annotate("text", x = 0.25, y = 0.33, label = paste("p[t]==", format(ppt, digits = 6)),
                 parse = TRUE, size = 3.5, hjust = 0)
      # PL
      if(is.null(ppl)){
        p5_left <- p5_left +
          annotate("text", x = 0.25, y = 0.3, label = paste("p[L]==", "0"),
                   parse = TRUE, size = 3.5, hjust = 0)
      }else{
        p5_left <- p5_left +
          annotate("text", x = 0.25, y = 0.3, label = paste("p[L]==", format(ppl, digits = 6)),
                   parse = TRUE, size = 3.5, hjust = 0)
      }
      # PU
      if(is.null(ppu)){
        p5_left <- p5_left +
          annotate("text", x = 0.25, y = 0.27, label = paste("p[U]==", "0"),
                   parse = TRUE, size = 3.5, hjust = 0)
      }else{
        p5_left <- p5_left +
          annotate("text", x = 0.25, y = 0.27, label = paste("p[U]==", format(ppu, digits = 6)),
                   parse = TRUE, size = 3.5, hjust = 0)
      }
      }
    
    p5_right <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.border = element_blank()
      ) +
      xlim(c(0.25,0.26)) + ylim(c(0.24, 0.36))
    {
      p5_right <- p5_right +
        annotate('text', x = 0.25, y = 0.35, label = "-----", size = 3, hjust = 0, colour = "white")
      
      # ppm
      p5_right <- p5_right +
        annotate("text", x = 0.25, y = 0.33, label = paste("ppm==", format(ppt * 1e+06, digits = 6)),
                 parse = TRUE, size = 3.5, hjust = 0)
      if(is.null(ppl)){
        p5_right <- p5_right +
          annotate("text", x = 0.25, y = 0.3, label = paste("ppm==", "0"),
                   parse = TRUE, size = 3.5, hjust = 0)
      }else{
        p5_right <- p5_right +
          annotate("text", x = 0.25, y = 0.3, label = paste("ppm==", format(ppl * 1e+06, digits = 6)),
                   parse = TRUE, size = 3.5, hjust = 0)
      }
      if(is.null(ppu)){
        p5_right <- p5_right +
          annotate("text", x = 0.25, y = 0.27, label = paste("ppm==", "0"),
                   parse = TRUE, size = 3.5, hjust = 0)
      }else{
        p5_right <- p5_right +
          annotate("text", x = 0.25, y = 0.27, label = paste("ppm==", format(ppu * 1e+06, digits = 6)),
                   parse = TRUE, size = 3.5, hjust = 0)
      }
      }
    
    p5 <- p5 + inset_element(p5_left, left = 0, right = 0.5, top = 0,  bottom = 0.80)+
      inset_element(p5_right, left = 0.5, right = 1, top = 0,  bottom = 0.80)
    
    # Caja info 6. Observed --------------------------------------------------------------------------
    obsL = 0
    obsU = 0
    p6 <- ggplot(data.frame(x = 0,y = 0), aes(x = x, y = y)) +
      theme_bw() +
      ggtitle("Observed") +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5, vjust = -0.5,margin = margin(b = -12), size = 10)
      ) +
      xlim(c(0.24, 0.26)) + ylim(c(0.27, 0.36))
    if (!is.null(lsl)){
      obsL = (sum(x < lsl)/length(x)) * 1e+06
      p6 <- p6 + annotate("text", x = 0.25, y = 0.31, label = paste("ppm==", format(obsL, digits = 6)),
                          parse = TRUE, size = 3.5, hjust = 0.5)
    } else{
      p6 <- p6 + annotate("text", x = 0.25, y = 0.31, label = paste("ppm==", 0),
                          parse = TRUE, size = 3.5, hjust = 0.5)
    }
    if (!is.null(usl)){
      obsU = (sum(x > usl)/length(x)) * 1e+06
      p6 <- p6 + annotate("text", x = 0.25, y = 0.28, label = paste("ppm==", format(obsU, digits = 6)),
                          parse = TRUE, size = 3.5, hjust = 0.5)
    } else{
      p6 <- p6 + annotate("text", x = 0.25, y = 0.28, label = paste("ppm==", 0),
                          parse = TRUE, size = 3.5, hjust = 0.5)
    }
    p6 <- p6 + annotate("text", x = 0.25, y = 0.34, label = paste("ppm==", format(obsL + obsU, digits = 6)),
                        parse = TRUE, size = 3.5, hjust = 0.5)
    
    # UNION --------------------------------------------------------------------------
    box_bottom <- p5 + p6 + plot_layout(widths = c(2, 1))
    main_plot <- p1 / box_bottom + plot_layout(heights = c(1, 0.5))
    box_right <- p2 / p3 / p4$plot
    box_right <- box_right/plot_spacer()
    main_plot <- (main_plot | box_right) + plot_layout(ncol = 2, widths = c(5, 1))
    main_plot <- main_plot + plot_annotation(
      title = main,
      theme = theme(plot.title = element_text(hjust = 0.5))
    )
    if(not3distr){
      print.adtest(adTestStats)
      show(main_plot)
      invisible(list(lambda = lambda, cp = cp, cpk = cpk,
                     cpl = cpl, cpu = cpu, ppt = ppt, ppl = ppl, ppu = ppu,
                     A = A, usl = usl, lsl = lsl, target = target, plot = main_plot))
    }else{
      show(main_plot)
      invisible(list(lambda = lambda, cp = cp, cpk = cpk,
                     cpl = cpl, cpu = cpu, ppt = ppt, ppl = ppl, ppu = ppu,
                     usl = usl, lsl = lsl, target = target, plot = main_plot))
    }
  }
  ## ---------------- end if plot == true --------------------------------------------------------------------------
  invisible(list(lambda = lambda, cp = cp, cpk = cpk, cpl = cpl,
                 cpu = cpu, ppt = ppt, ppl = ppl, ppu = ppu, usl = usl,
                 lsl = lsl, target = target, plot = main_plot))
}

.pcr = function(x, distribution = "normal", lsl, usl, target, boxcox = FALSE, lambda = c(-5,5), main, xlim, ylim, grouping = NULL, std.dev = NULL, conf.level = 0.9973002, start, lineWidth = 1, 
                lineCol = "red", lineType = "solid", specCol = "red3", specWidth = 1, cex.text = 2, cex.val = 1.5, cex.col = "darkgray", plot = TRUE, ...) {                                                                                                  
  data.name = deparse(substitute(x))[1]                                 ####                                                                         
  parList = list(...)
  if (is.null(parList[["col"]])) 
    parList$col = "lightblue"
  if (is.null(parList[["border"]])) 
    parList$border = 1
  if (is.null(parList[["lwd"]])) 
    parList$lwd = 1
  if (is.null(parList[["cex.axis"]])) 
    parList$cex.axis = 1.5
  if (missing(lsl)) 
    lsl = NULL
  if (missing(usl)) 
    usl = NULL
  if (missing(target)) 
    target = NULL
  if (missing(lambda)) 
    lambda = c(-5, 5)
  if (!is.numeric(lambda)) 
    stop("lambda needs to be numeric")
  paramsList = vector(mode = "list", length = 0)
  estimates = vector(mode = "list", length = 0)
  varName = deparse(substitute(x))
  dFun = NULL
  pFun = NULL
  qFun = NULL
  cp = NULL
  cpu = NULL
  cpl = NULL
  cpk = NULL
  ppt = NULL
  ppl = NULL
  ppu = NULL
  xVec = numeric(0)
  yVec = numeric(0)
  if (is.vector(x)) 
    x = as.data.frame(x)                                                                          ####
  any3distr=FALSE;not3distr=FALSE                                            ####
  if(distribution=="weibull3" || distribution=="lognormal3" || distribution=="gamma3")####
    any3distr=TRUE                                                             ####
  if (distribution!="weibull3" && distribution!="lognormal3" && distribution!="gamma3")####
    not3distr=TRUE                                                                  ####
  if (boxcox) {
    distribution = "normal"
    if (length(lambda) >= 2) {
      temp = boxcox(x[, 1] ~ 1, lambda = seq(min(lambda), max(lambda), 1/10), plotit = FALSE)
      i = order(temp$y, decreasing = TRUE)[1]
      lambda = temp$x[i]
    }
    x = as.data.frame(x[, 1]^lambda)
  }
  numObs = nrow(x)
  if (!is.null(grouping)) 
    if (is.vector(grouping)) 
      grouping = as.data.frame(grouping)
  center = colMeans(x)
  if (!is.null(x) & !is.null(grouping)) {
    if (nrow(x) != nrow(grouping)) 
      stop(paste("length of ", deparse(substitute(grouping)), " differs from length of ", varName))
  }
  if (missing(main)) 
    if (boxcox) 
      main = paste("Process Capability using box cox transformation for", varName)
  else main = paste("Process Capability using", as.character(distribution), "distribution for", 
                    varName)
  if (is.null(std.dev)) {
    if (is.null(grouping)) 
      std.dev = .sdSg(x)
    else std.dev = .sdSg(x, grouping)
  }
  if (conf.level < 0 | conf.level > 1) 
    stop("conf.level must be a value between 0 and 1")
  confHigh = conf.level + (1 - conf.level)/2
  confLow = 1 - conf.level - (1 - conf.level)/2
  distWhichNeedParameters = c("weibull", "logistic", "gamma", "exponential", "f", "geometric", 
                              "chi-squared", "negative binomial", "poisson")
  if (is.character(distribution)) {
    dis=distribution                                                           ####
    if (identical(distribution,"weibull3"))                                     ####
      dis="weibull3"                                                             ####
    if (identical(distribution,"gamma3"))                                       ####
      dis="gamma3"                                                               ####
    if (identical(distribution,"lognormal3"))                                   ####
      dis="lognormal3"                                                           ####
    qFun = .charToDistFunc(dis, type = "q")                                 ####
    pFun = .charToDistFunc(dis, type = "p")                                 ####
    dFun = .charToDistFunc(dis, type = "d")                                 ####
    if (is.null(qFun) & is.null(pFun) & is.null(dFun)) 
      stop(paste(deparse(substitute(y)), "distribution could not be found!"))
  }
  if (TRUE) {                                                                 #### distribution!="weibull3" && distribution!="lognormal3" && distribution!="gamma3"
    fitList = vector(mode = "list", length = 0)
    fitList$x = x[, 1]
    fitList$densfun = dis                                                   ####
    if (!missing(start)) 
      fitList$start = start
    if (not3distr)                                                          ####
    {                                                                       ####
      fittedDistr = do.call(MASS::fitdistr, fitList)
      estimates = as.list(fittedDistr$estimate)
      paramsList = estimates
    }                                                                       ####
    if (distribution=="weibull3")                                           ####
    {                                                                       ####
      paramsList= .weibull3(x[,1])                                           ####
      estimates = paramsList                                                 ####
    }                                                                       ####
    if (distribution=="lognormal3")                                         ####
    {                                                                       ####
      paramsList= .lognormal3(x[,1])                                         ####
      estimates = paramsList                                                 ####
    }                                                                       ####
    if (distribution=="gamma3")                                             ####
    {                                                                       ####
      paramsList= .gamma3(x[,1])                                             ####
      estimates = paramsList                                                 ####
    }                                                                       ####
  }
  paramsList = c(paramsList, .lfkp(parList, formals(qFun)))
  if (distribution == "normal") {
    paramsList$mean = center
    paramsList$sd = std.dev
    estimates = paramsList
  }
  if (boxcox) {
    if (!is.null(lsl)) 
      lsl = lsl^lambda
    if (!is.null(usl)) 
      usl = usl^lambda
    if (!is.null(target)) 
      target = target^lambda
  }
  if (is.null(lsl) && is.null(usl)) {
    paramsList$p = confLow
    lsl = do.call(qFun, paramsList)
    paramsList$p = confHigh
    usl = do.call(qFun, paramsList)
  }
  if (identical(lsl, usl)) 
    stop("lsl == usl")
  if (!is.null(lsl) && !is.null(target) && target < lsl) 
    stop("target is less than lower specification limit")
  if (!is.null(usl) && !is.null(target) && target > usl) 
    stop("target is greater than upper specification limit")
  if (!is.null(lsl) && !is.null(usl)) 
    if (lsl > usl) {
      temp = lsl
      lsl = usl
      usl = temp                       
    }
  paramsList$p = c(confLow, 0.5, confHigh)
  paramsListTemp = .lfkp(paramsList, formals(qFun))                           ####
  qs = do.call(qFun, paramsListTemp)                                         ####  
  paramsListTemp = .lfkp(paramsList, formals(pFun))                           ####
  if (!is.null(lsl) && !is.null(usl)) 
    cp = (usl - lsl)/(qs[3] - qs[1])
  if (!is.null(usl)) {
    cpu = (usl - qs[2])/(qs[3] - qs[2])
    paramsListTemp$q = usl                                                  ####
    ppu = 1 - do.call(pFun, paramsListTemp)                                 ####
  }
  if (!is.null(lsl)) {
    cpl = (qs[2] - lsl)/(qs[2] - qs[1])
    paramsListTemp$q = lsl                                                  ####
    ppl = do.call(pFun, paramsListTemp)                                     ####
  }
  cpk = min(cpu, cpl)
  ppt = sum(ppl, ppu)
  
  if(plot==TRUE){
    if (missing(xlim)) {
    xlim <- range(x[, 1], usl, lsl)
    xlim <- xlim + diff(xlim) * c(-0.2, 0.2)
  }
  xVec <- seq(min(xlim), max(xlim), length = 200)
  dParamsList = .lfkp(paramsList, formals(dFun))
  dParamsList$x = xVec
  
  yVec = do.call(dFun, dParamsList)
  histObj <- hist(x[, 1], plot = FALSE)
  if (missing(ylim)) {
    ylim <- range(histObj$density, yVec)
    ylim <- ylim + diff(ylim) * c(0, 0.05)
  }
  
  # 1. Histograma --------------------------------------------------------------------------
  x.c <- x[, 1]
  temp <- hist(x.c, plot = FALSE)
  df <- data.frame(
    mid = temp$mids,
    density = temp$density
  )
  width <- diff(df$mid)[1] # Ancho de cada barra
  # Histograma
  p1 <- ggplot(df, aes(x = mid, y = density)) +
    geom_bar(stat = "identity", width = width, fill = "lightblue", color = "black", alpha = 0.5) +
    labs(y = "", x = "", title = main) +
    theme_minimal() + theme(plot.title = element_text(hjust = 0.5,face = "bold"))+
    guides(color = guide_legend(title.position = "top", title.hjust = 0.5))+
    geom_line(data = data.frame(x = xVec, y = yVec), aes(x = x, y = y), color = "red", linewidth = 0.5) + # densidad
    theme(legend.position = "none")
  
  #  etiquetas de los límites
  if (!is.null(lsl) & !is.null(usl)){
    p1 <- p1 +
      geom_vline(aes(xintercept = usl, color = "Confidence interval"), linetype = "dashed", col = "red") + # USL
      geom_vline(aes(xintercept = lsl, color = "Confidence interval"), linetype = "dashed", col = "red") + # LSL
      scale_x_continuous(limits = xlim, expand = c(0, 0),
                         sec.axis = sec_axis(~ ., breaks = c(lsl, usl),
                                             labels = c(paste("LSL =",format(lsl, digits = 3)), paste("USL =",format(usl, digits = 3)))
                         )) +
      theme(axis.text.y.right = element_text(size = 15))
  }else{
    if(!is.null(lsl)){
      p1 <- p1 +
        geom_vline(aes(xintercept = lsl, color = "Confidence interval"), linetype = "dashed", col = "red") + # LSL
        scale_x_continuous(limits = xlim, expand = c(0, 0),
                           sec.axis = sec_axis(~ ., breaks = lsl, labels = paste("LSL =",format(lsl, digits = 3)) )) +
        theme(axis.text.y.right = element_text(size = 15))
    }
    if(!is.null(usl)){
      p1 <- p1 +
        geom_vline(aes(xintercept = usl, color = "Confidence interval"), linetype = "dashed", col = "red") + # USL
        scale_x_continuous(limits = xlim, expand = c(0, 0),
                           sec.axis = sec_axis(~ ., breaks = usl,labels = paste("USL =",format(usl, digits = 3)))) +
        theme(axis.text.y.right = element_text(size = 15))
    }
  }
  return(list(lambda = lambda, cp = cp, cpk = cpk, cpl = cpl, cpu = cpu,        ####
              ppt = ppt, ppl = ppl, ppu = ppu, usl = usl,                  ####
              lsl = lsl, target = target, plot = p1))
  }
  
  return(list(lambda = lambda, cp = cp, cpk = cpk, cpl = cpl, cpu = cpu,        ####
              ppt = ppt, ppl = ppl, ppu = ppu, usl = usl,                  ####
              lsl = lsl, target = target))                                 ####
}

```


1. Distribución Normal

```{r}
set.seed(1234)
datos <- rnorm(20, mean = 20)
pcr(datos, "normal", lsl = 17, usl = 23)
```

Además, las gráficas QQ-plot pueden obtenerse a partir de la siguiente función:

```{r}
qqPlot(datos,"normal")
```

Así también, los gráficos de probabilidad se pueden calcular con la función ppPlot:

```{r, results='hide'}
# bounds.lty = 3 -> linea entrecortada
# bounds.col -> color de las bandas
ppPlot(datos, "normal", bounds.lty = 3, bounds.col = "blue")
```

Además si solo queremos obtener la gráfica central, se hace uso de la función `.pcr`, de la siguiente manera:

```{r, results='hide'}
.pcr(datos, "normal", lsl = 17, usl = 23)
```


2. Distribución Weibull

```{r}
set.seed(1234)
weib <- rweibull(20, shape = 2, scale = 8)
pcr(weib, "weibull", usl = 20)
```





## FASE 4: Mejorar

### Diseños factoriales $2^k$

```{r, echo=FALSE}
### necesito .helpAliasTable##################################################
### Funcion .replace2s####
.replace2s = function(x) {
  if (!is.data.frame(x))
    stop(paste(deparse(substitute(x)), "needs to be a data.frame"))
  for (i in 1:ncol(x)) x[x[, i] == 2, i] = -1
  return(x)
}
.helpAliasTable = function(fdo, k, degree = 3) {
  if (degree > k) {
    degree = k
  }
  if (class(fdo)[1] == "facDesign")
    X = unique(fdo$cube)
  if (class(fdo)[1] == "taguchiDesign") {
    X = unique(fdo$design)
    X = .replace2s(X)
  }
  N = nrow(X)
  columns = names(X[, 1:k])
  X1 = matrix(1, nrow = N, ncol = 1)
  nameVec = c("Identity")
  for (i in 1:degree) {
    temp = combn(columns, i)
    for (j in 1:ncol(temp)) {
      if (class(fdo)[1] == "facDesign")
        index = names(X) %in% temp[, j]
      if (class(fdo)[1] == "taguchiDesign")
        index = names(X) %in% temp[, j]
      if (length((1:length(index))[index]) == 1) {
        X1 = cbind(X1, X[, index])
        nameVec = c(nameVec, temp[, j])
      }
      else {
        X1 = cbind(X1, apply(X[, index], 1, prod))
        nameVec = c(nameVec, paste(temp[, j], sep = "", collapse = ""))
      }
    }
    X1 = data.frame(X1)
    names(X1) = nameVec
  }
  return(X1)
}

### necesito aliasTable#######################################################
aliasTable <- function (fdo, degree, show = TRUE)
{
  if (class(fdo)[1] == "facDesign") {
    X = unique(fdo$cube)
    N = nrow(X)
    k = log2(N)
    kPlusP = ncol(X)
    if (missing(degree))
      degree = min(c(4, k + 1))
    X1 = .helpAliasTable(fdo, k, degree = degree - 1)
    X2 = .helpAliasTable(fdo, k = kPlusP, degree)
  }
  if (class(fdo)[1] == "taguchiDesign") {
    if (length(table(as.numeric(as.matrix(fdo$design)))) !=
        2)
      stop("calculation of an alias table for mixed designs is not supported")
    k = ncol(fdo$design)
    if (missing(degree))
      degree = min(c(3, k))
    X1 = unique(fdo$design)
    X1 = .replace2s(X1)
    X2 = .helpAliasTable(fdo, k, degree)
    X1 = cbind(data.frame(Identity = rep(1, times = nrow(X1))),
               X1)
  }
  logVec = !(names(X2) %in% names(X1))
  X2 = X2[, logVec]
  X1 = as.matrix(X1)
  X2 = as.matrix(X2)
  alias.matrix = solve(t(X1) %*% X1) %*% t(X1) %*% X2
  if (show)
    print(round(alias.matrix, 2))
  invisible(alias.matrix)
}

### necesito .fdoOrth y .NAMES#######################################
.fdoOrth = vector(mode = "list", length = 3)
###
.fdoOrth[[1]] = list(k = 3, gen = "C=AB", p = 1)
###
.fdoOrth[[2]] = list(k = 4, gen = "D=ABC", p = 1)
###
.fdoOrth[[3]] = list(k = 5, gen = c("D=AB","E=AC"), p = 2)
###
.fdoOrth[[4]] = list(k = 6, gen = c("D=AB","E=AC","F=BC"), p = 3)
###
.fdoOrth[[5]] = list(k = 7, gen = c("D=AB","E=AC","F=BC","G=ABC"), p = 4)
###
.fdoOrth[[6]] = list(k = 5, gen = "E=ABCD", p = 1)
###
.fdoOrth[[7]] = list(k = 6, gen = c("E=ABC","F=BCD"), p = 2)
###
.fdoOrth[[8]] = list(k = 7, gen = c("E=ABC","F=BCD","G=ACD"), p = 3)
###
.fdoOrth[[9]] = list(k = 8, gen = c("E=BCD","F=ACD","G=ABC","H=ABD"), p = 4)
###
.fdoOrth[[10]] = list(k = 9, gen = c("E=ABC","F=BCD","G=ACD","H=ABD","J=ABCD"), p = 5)
###
.fdoOrth[[11]] = list(k = 10, gen = c("E=ABC","F=BCD","G=ACD","H=ABD","J=ABCD","K=AB"), p = 6)
###
.fdoOrth[[12]] = list(k = 11, gen = c("E=ABC","F=BCD","G=ACD","H=ABD","J=ABCD","K=AB","L=AC"), p = 7)
###
.fdoOrth[[13]] = list(k = 6, gen = "F=ABCDE", p = 1)
###
.fdoOrth[[14]] = list(k = 7, gen = c("F=ABCD","G=ABDE"), p = 2)
###
.fdoOrth[[15]] = list(k = 8, gen = c("F=ABC","G=ABD","H=BCDE"), p = 3)
###
.fdoOrth[[16]] = list(k = 9, gen = c("F=BCDE","G=ACDE","H=ABDE","J=ABCE"), p = 4)
###
.fdoOrth[[17]] = list(k = 10, gen = c("F=ABCD","G=ABCE","H=ABDE","J=ACDE","K=BCDE"), p = 5)
###
.fdoOrth[[18]] = list(k = 11, gen = c("F=ABC","G=BCD","H=CDE","J=ACD","K=AEF","L=ADEF"), p = 6)
###
.fdoOrth[[19]] = list(k = 7, gen = "G=ABCDEF", p = 1)
###
.fdoOrth[[20]] = list(k = 8, gen = c("G=ABCD","H=ABEF"), p = 2)
###
.fdoOrth[[21]] = list(k = 9, gen = c("G=ABCD","H=ABEF","J=CDEF"), p = 3)
###
.fdoOrth[[22]] = list(k = 10, gen = c("G=BCDF","H=ACDF","J=ABDE","K=ABCE"), p = 4)
###
.fdoOrth[[23]] = list(k = 11, gen = c("G=CDE","H=ABCD","J=ABF","K=BDEF","L=ADEF"), p = 5)
###
.fdoOrth[[24]] = list(k = 8, gen = "H=ABCDEFG", p = 1)
###
.fdoOrth[[25]] = list(k = 9, gen = c("H=ACDFG","J=BCEFG"), p = 2)
###
.fdoOrth[[26]] = list(k = 10, gen = c("H=ABCG","J=BCDE","K=ACDF"), p = 3)
###
.fdoOrth[[27]] = list(k = 11, gen = c("H=ABCG","J=BCDE","K=ACDF","L=ABCDEFG"), p = 4)
###
.NAMES = LETTERS[c(1:8, 10:26)]



### necesito .m.interaction.plot###########################
.m.interaction.plot <- function(x.factor, trace.factor, response, fun = mean, type = c("l", "p", "b"), legend = TRUE, trace.label = deparse(substitute(trace.factor)),
                                fixed = FALSE, xlab = deparse(substitute(x.factor)), ylab = ylabel, ytitle = TRUE, ylim = range(cells, na.rm = TRUE), lty = nc:1, col = 1, pch = c(1L:9, 0, letters), xpd = NULL,
                                leg.bg = par("bg"), leg.bty = "n", xtick = FALSE, xaxt = par("xaxt"), axes.x = TRUE, axes.y = TRUE, main, ...) {
  ylabel <- paste(deparse(substitute(fun)), "of ", deparse(substitute(response)))
  type <- match.arg(type)
  cells <- base::tapply(response, list(x.factor, trace.factor), fun)
  nr <- nrow(cells)
  nc <- ncol(cells)
  xvals <- 1L:nr
  xvals = as.numeric(rownames(cells))
  if (is.ordered(x.factor)) {
    wn <- getOption("warn")
    options(warn = -1)
    xnm <- as.numeric(levels(x.factor))
    options(warn = wn)
    if (!any(is.na(xnm)))
      xvals <- xnm
  }
  if (missing(main)) {
    main = paste("Effect Plot")
  }
  xlabs <- rownames(cells)
  ylabs <- colnames(cells)
  nch <- max(sapply(ylabs, nchar, type = "width"))
  if (is.null(xlabs))
    xlabs <- as.character(xvals)
  if (is.null(ylabs))
    ylabs <- as.character(1L:nc)
  xlim <- range(xvals)
  xleg <- xlim[2L] + 0.05 * diff(xlim)
  xlim <- xlim + c(-0.2/nr, if (legend) 0.2 + 0.02 * nch else 0.2/nr) * diff(xlim)

  df <- data.frame(x = xvals, y = c(cells))

  # PLOT
  p <- ggplot(df, aes(x = x, y = y)) +
    geom_line(na.rm = TRUE) +
    ylim(ylim) + labs(x = xlab, y = ylab, title = main) + theme_bw() +

    theme(axis.ticks = element_blank(),
          axis.text = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_blank(),
          plot.title = element_text(hjust = 0.5))

  if (axes.x){
    p <- p +
      theme(axis.ticks.x = element_line(),
            axis.text.x = element_text()) +
      scale_x_continuous(breaks=c(-1, 1))
  }
  if (axes.y){
    p <- p +
      theme(axis.ticks.y = element_line(),
            axis.text.y = element_text())
  }
  if (ytitle == FALSE){
    p <-  p + theme(axis.title.y = element_blank())
  }
  if(main == ""){
    p <- p + labs(title = NULL)
  }
  if (deparse(substitute(mean)) == "mean"){
    p <- p + geom_hline(yintercept = median(df$y, na.rm = TRUE), linetype = "dashed", col = "#324B7A")
  }

  invisible(list(xVals = df$x, yVals = df$y, plot = p))
}

### necesito clase facDesign.c######################################################
facDesign.c <- R6Class("facDesign", public = list(name = NULL,
                                                 factors = NULL,
                                                 cube = data.frame(),
                                                 star = data.frame(),
                                                 centerCube = data.frame(),
                                                 centerStar = data.frame(),
                                                 generator = NULL,
                                                 response = data.frame(),
                                                 block = data.frame(),
                                                 blockGen = data.frame(),
                                                 runOrder = data.frame(),
                                                 standardOrder = data.frame(),
                                                 desireVal = NULL,
                                                 desirability = list(),
                                                 fits = NULL,

                                                 nrow = function(){
                                                   nrow(self$as.data.frame())
                                                 },

                                                 ncol = function(){
                                                   ncol(self$as.data.frame())
                                                 },

                                                 show = function(){
                                                   runIndex = order(self$runOrder[,1])
                                                   print(format(self$as.data.frame(), digits = 4))
                                                   invisible(self$as.data.frame())
                                                 },

                                                 .clear = function(){
                                                   self$standardOrder = data.frame()
                                                   self$runOrder = data.frame()
                                                   self$cube = data.frame()
                                                   self$centerStar = data.frame()
                                                   self$centerCube = data.frame()
                                                   self$star = data.frame()
                                                   self$block = data.frame()
                                                   self$blockGen = data.frame()
                                                   self$response = data.frame()
                                                   invisible(self)
                                                 },

                                                 names = function(value){
                                                   if(missing(value)){
                                                     n <- c()
                                                     for (i in 1:length(self$factors)) {
                                                       n[i] <- self$factors[[i]]$name
                                                     }
                                                     return(n)
                                                   }
                                                   else {
                                                     for (i in 1:length(self$factors)){
                                                       self$factors[[i]]$name = as.character(value[i])

                                                     }
                                                     invisible(self)
                                                   }

                                                 },

                                                 as.data.frame = function(row.names = NULL, optional = FALSE, ...) {
                                                   if (nrow(self$cube)>0) {
                                                     frameOut = self$cube
                                                     names(frameOut) = self$names()
                                                   }
                                                   else return(NULL)
                                                   if (nrow(self$centerCube)>0){
                                                     faux <- self$centerCube
                                                     names(faux) <- self$names()
                                                     frameOut = rbind(frameOut, faux)
                                                   }
                                                   if (nrow(self$star)>0){
                                                     faux <- self$star
                                                     names(faux) <- self$names()
                                                     frameOut = rbind(frameOut, faux)
                                                   }
                                                   if (nrow(self$centerStar)>0){
                                                     faux <- self$centerStar
                                                     names(faux) <- self$names()
                                                     frameOut = rbind(frameOut, faux)
                                                   }
                                                   aux <- list()
                                                   for (i in 1:length(self$names())) {
                                                     aux[[self$names()[i]]] <-.NAMES[i]
                                                   }
                                                   if (!is.null(self$factors) && length(self$factors) == dim(frameOut)[2]) {
                                                     names(frameOut) = as.character(aux)
                                                   }
                                                   if (!is.null(self$blockGen) && nrow(self$blockGen) > 0) {
                                                     frameOut = cbind(self$blockGen, frameOut)
                                                   }
                                                   if (!is.null(self$block) && nrow(self$block) > 0) {
                                                     frameOut = cbind(self$block, frameOut)
                                                   }
                                                   if (!is.null(self$runOrder) && nrow(self$runOrder) > 0) {
                                                     frameOut = cbind(self$runOrder, frameOut)
                                                   }
                                                   if (!is.null(self$standardOrder) && nrow(self$standardOrder) > 0) {
                                                     frameOut = cbind(self$standardOrder, frameOut)
                                                   }
                                                   if (!is.null(self$response) && nrow(frameOut) == nrow(self$response))
                                                     frameOut = cbind(frameOut, self$response)
                                                   else {
                                                     temp = as.data.frame(matrix(NA, nrow = nrow(frameOut), ncol = ncol(self$response)))
                                                     names(temp) = names(self$response)
                                                     frameOut = cbind(frameOut, temp)
                                                   }
                                                   runIndex = order(self$runOrder[,1])
                                                   out = frameOut[runIndex, ]
                                                   return(out)
                                                 },

                                                 get = function(i,j){
                                                   return(self$as.data.frame()[i, j])
                                                 },

                                                 lows = function(value){
                                                   if (missing(value)) {
                                                     listOut = vector(mode = "list")
                                                     for (i in seq(along = self$factors)) {
                                                       listOut[self$factors[[i]]$name] = self$factors[[i]]$.low()
                                                     }
                                                     return(listOut)
                                                   }
                                                   else {
                                                     for (i in seq(along = self$factors)) {
                                                       self$factors[[i]]$.low(value[i])
                                                     }
                                                     invisible(self)
                                                   }
                                                 },

                                                 highs = function(value){
                                                   if (missing(value)) {
                                                     listOut = vector(mode = "list")
                                                     for (i in seq(along = self$factors)) {
                                                       listOut[self$factors[[i]]$name] = self$factors[[i]]$.high()
                                                     }
                                                     return(listOut)
                                                   }
                                                   else {
                                                     for (i in seq(along = self$factors)) {
                                                       self$factors[[i]]$.high(value[i])
                                                     }
                                                     invisible(self)
                                                   }
                                                 },

                                                 .nfp = function(){
                                                   x = self$factors
                                                   atr <- c('low','high','name','unit','type')
                                                   if (is.list(x) && length(x[[1]]) > 0) {
                                                     numAttr = length(x[[1]]$attributes())
                                                     .numFac = length(x)
                                                     frameOut = data.frame(matrix(ncol = .numFac, nrow = numAttr ))
                                                     for (i in 1:numAttr ) {
                                                       charVec = character(0)
                                                       for (j in 1:.numFac) {
                                                         charVec = c(charVec, atr[i], "\t\t")
                                                         frameOut[i, j] = x[[j]]$attributes()[i]
                                                       }
                                                     }
                                                     names(frameOut) = self$names()
                                                     rownames(frameOut) = atr[1:numAttr ]
                                                   }
                                                   else {
                                                     stop("no list given or length of list < 1")
                                                   }
                                                   print(frameOut)
                                                 },

                                                 identity = function(){
                                                   identity = character(0)
                                                   identityList = vector(mode = "list", length = 0)
                                                   resolution = numeric(0)
                                                   temp = NULL
                                                   A = aliasTable(self, show = FALSE)
                                                   if (any(dim(A) == 0))
                                                     return(identityList)
                                                   temp = as.matrix(A["Identity", ])
                                                   boolTemp = apply(temp, 2, as.logical)
                                                   identity = row.names(temp)[boolTemp[, 1]]
                                                   if (length(identity) > 0) {
                                                     charList = strsplit(toupper(identity), split = "")
                                                     identityList = lapply(charList, match, .NAMES[1:25])
                                                     names(identityList) = identity
                                                   }
                                                   cat("Defining relations:\n")
                                                   if (length(identityList) > 0) {
                                                     for (i in 1:length(identityList)) {
                                                       identLen = length((strsplit(names(identityList)[i], split = character(0))[[1]]))
                                                       if (length(resolution) == 0 || identLen > resolution)
                                                         resolution = c(resolution, identLen)
                                                       cat("I = ", names(identityList)[i], "\t\tColumns:", identityList[[i]], "\n")
                                                     }
                                                     cat("\nResolution: ", as.character(as.roman(min(resolution))), "\n")
                                                   }
                                                   invisible(identityList)
                                                 },

                                                 summary = function(){
                                                   doeFactors = self$factors
                                                   cat("Information about the factors:\n\n")
                                                   self$.nfp()
                                                   cat("-----------\n")
                                                   print(self$as.data.frame())
                                                   temp = aliasTable(self, show = FALSE)
                                                   if (ncol(temp) > 0) {
                                                     cat("\n---------\n\n")
                                                     self$identity()
                                                     cat("\n")
                                                   }
                                                   invisible(self$as.data.frame())
                                                 },

                                                 .response = function(value){
                                                   if(missing(value)){
                                                     iIntern <- order(self$runOrder[,1])
                                                     out <- data.frame(self$response[iIntern,])
                                                     names(out) <- names(self$response)
                                                     return(out)
                                                   }
                                                   else{
                                                     index = order(self$runOrder[,1])
                                                     if (!is.vector(value) && !is.data.frame(value))
                                                       stop("vector or data.frame expected!")
                                                     if (is.vector(value) && (is.numeric(value) || is.na(value))) {
                                                       if (nrow(self$response) != length(value))
                                                         stop(paste("Number of rows for Design does not equal length of vector ", nrow(object),
                                                                    " != ", length(value), " "))
                                                       self$response <- data.frame(value)
                                                       self$response[index, ] <- value
                                                       names(self$response) <- make.names(deparse(substitute(value)))
                                                       invisible(self)
                                                     }
                                                     if (is.data.frame(value)) {
                                                       self$response <- value
                                                       self$response[index, ] <- value
                                                       invisible(self)
                                                     }

                                                   }

                                                 },

                                                 effectPlot = function(factors, fun = base::mean, response = NULL, single = FALSE,
                                                                       points = FALSE, classic = FALSE, axes = TRUE, 
                                                                       lty, xlab, ylab, main, ylim, ...) {

                                                   if(is.null(response)==FALSE)
                                                   {                                                                           ###
                                                     temp=self$.response()[response]                                            ###
                                                     self$.response(temp)                                                      ###
                                                   }
                                                   ylabmiss = FALSE
                                                   xlabmiss = FALSE
                                                   mainmiss = FALSE
                                                   ylimmiss = FALSE
                                                   if (missing(ylim))
                                                     ylimmiss = TRUE
                                                   if (missing(lty))
                                                     lty = 1
                                                   X = self$cube
                                                   Y = as.data.frame(self$response[1:nrow(X), ])
                                                   names(Y) = names(self$.response())
                                                   if (!missing(factors))
                                                     k = length(factors)
                                                   else{
                                                     k = ncol(X)
                                                     factors = names(X)
                                                   }
                                                   numCol = 1
                                                   numRow = 1
                                                   if (!single && missing(factors)) {               
                                                     if (ncol(X) == 2) {
                                                       numCol = 2
                                                       numRow = 1
                                                     }
                                                     if (ncol(X) > 2) {
                                                       numCol = 2
                                                       numRow = 2
                                                     }
                                                   }
                                                   if (!single && !missing(factors)) {                                         
                                                     if (length(factors) == 2) {                                             
                                                       numCol = 2                                                         
                                                       numRow = 1                                                          
                                                     }                                                                     
                                                     if (length(factors) == 3) {                                             
                                                       numCol = 3                                                          
                                                       numRow = 1                                                          
                                                     }                                                                       
                                                     if (length(factors) == 4) {                                             
                                                       numCol = 2                                                          ###
                                                       numRow = 2                                                          ###
                                                     }                                                                       
                                                     if (length(factors) == 5) {                                             ###
                                                       numCol = 3                                                          ###
                                                       numRow = 2                                                          ###
                                                     }                                                                       
                                                     if (length(factors) == 6) {                                             ###
                                                       numCol = 3                                                          ###
                                                       numRow = 2                                                          ###
                                                     }                                                                       
                                                     if (length(factors) > 6) {                                              ###
                                                       numRow = ceiling(sqrt(length(factors)))                             ###
                                                       numCol = ceiling(sqrt(length(factors)))                             ###
                                                     }                                                                       ###
                                                   }
                                                   if (classic) {
                                                     numCol = ncol(X)
                                                     numRow = 1
                                                   }
                                                   if (!single)
                                                     par(mfrow = c(numRow, numCol))
                                                   nextResponse = FALSE
                                                   if (missing(main)) {
                                                     main = paste("Effect Plot for", names(Y)[1])
                                                   }

                                                   list_plot <- list()
                                                   for (j in 1:ncol(Y)){
                                                     counter = 0
                                                     cells = numeric(0)
                                                     for (i in 1:length(factors)){
                                                       cells = c(cells, as.vector(tapply(Y[, j], list(X[, factors[i]], rep(0, nrow(X))), fun)))
                                                       if (points)
                                                         cells = range(Y)
                                                     }
                                                     if (nextResponse & !single) {
                                                       dev.new()
                                                       par(mfrow = c(numRow, numCol))
                                                     }
                                                     # 1. ------------------------------------
                                                     i <- 1
                                                     if ((counter != 0 & counter%%(numCol * numRow) == 0) & !single) {
                                                       dev.new()
                                                       par(mfrow = c(numRow, numCol))
                                                     }
                                                     if (missing(main)) {
                                                       main = paste("Effect Plot for", names(Y)[j])
                                                       mainmiss = TRUE
                                                     }
                                                     if (missing(xlab)) {
                                                       xlab = factors[i]
                                                       xlabmiss = TRUE
                                                     }
                                                     if (xlabmiss) {
                                                       if (identical(" ", self$names()[[i]]))
                                                         xlab = factors[i]
                                                       else xlab = paste(factors[i], ": ", self$names()[[i]], sep = "")
                                                     }
                                                     if (missing(ylab)) {
                                                       ylab = paste("mean of ", names(Y)[j])
                                                       ylabmiss = TRUE
                                                     }
                                                     if (ylabmiss)
                                                       ylab = paste("mean of ", names(Y)[j])
                                                     if (ylimmiss)
                                                       ylim = range(cells, na.rm = TRUE)
                                                     if (classic) {
                                                       p <- .m.interaction.plot(x.factor = X[, factors[i]], 
                                                                                trace.factor = rep(0, nrow(X)), 
                                                                                response = Y[, j], lty = lty, ylim = ylim,
                                                                                xlab = xlab, fun = base::mean,
                                                                                ylab = ylab, main = " ", ...)
                                                       list_plot[[paste0("p",j,i)]] <- p$plot
                                                     }
                                                     else {
                                                       p <- .m.interaction.plot(x.factor = X[, factors[i]], 
                                                                                trace.factor = rep(0, nrow(X)), 
                                                                                response = Y[, j], lty = lty, ylim = ylim, 
                                                                                xlab = xlab, fun = base::mean,
                                                                                ylab = ylab, main = main, ...)
                                                       list_plot[[paste0("p",j,i)]] <- p$plot
                                                     }
                                                     counter = counter + 1
                                                     # 2. ------------------------------------
                                                     if(length(factors) >= 2){
                                                       for (i in 2:length(factors)) {
                                                         if ((counter != 0 & counter%%(numCol * numRow) == 0) & !single) {
                                                           dev.new()
                                                           par(mfrow = c(numRow, numCol))
                                                         }
                                                         if (missing(main)) {
                                                           main = paste("Effect Plot for", names(Y)[j])
                                                           mainmiss = TRUE
                                                         }
                                                         if (missing(xlab)) {
                                                           xlab = factors[i]
                                                           xlabmiss = TRUE
                                                         }
                                                         if (xlabmiss) {
                                                           if (identical(" ", self$names()[[i]]))
                                                             xlab = factors[i]
                                                           else xlab = paste(factors[i], ": ", self$names()[[i]], sep = "")
                                                         }
                                                         if (missing(ylab)) {
                                                           ylab = paste("mean of ", names(Y)[j])
                                                           ylabmiss = TRUE
                                                         }
                                                         if (ylabmiss)
                                                           ylab = paste(deparse(substitute(fun)), "of ", names(Y)[j])
                                                         if (ylimmiss)
                                                           ylim = range(cells, na.rm = TRUE)
                                                         if (classic) {
                                                           aux <- .m.interaction.plot(x.factor = X[, factors[i]], 
                                                                                      trace.factor = rep(0, nrow(X)),
                                                                                      response = Y[, j], lty = lty, ylim = ylim,
                                                                                      xlab = xlab, fun = fun,
                                                                                      ylab = ylab, axes.y = FALSE, ytitle = FALSE,
                                                                                      main = " ", ...)
                                                           list_plot[[paste0("p",j,i)]] <- aux$plot
                                                         }
                                                         else {
                                                           aux <- .m.interaction.plot(x.factor = X[, factors[i]], 
                                                                                      trace.factor = rep(0, nrow(X)), 
                                                                                      response = Y[, j], lty = lty, ylim = ylim,
                                                                                      xlab = xlab, fun = fun,
                                                                                      ylab = ylab, main = main, ytitle = TRUE, ...)
                                                           list_plot[[paste0("p",j,i)]] <- aux$plot
                                                         }
                                                         counter = counter + 1
                                                       }
                                                     }
                                                     nextResponse = TRUE
                                                   }
                                                   # Obtener los nombres de todas las graficas que se crearon
                                                   grap <- c()
                                                   for(j in 1:ncol(Y)){
                                                     for(i in 1:length(factors)){
                                                       x <- paste0("p",j,i)
                                                       if(!x %in% grap){
                                                         grap <- c(grap, x)
                                                       }
                                                     }
                                                   }

                                                   p <- list_plot$p11
                                                   for(i in 2:length(grap)){
                                                     aux <- grap[i]
                                                     p <- p + list_plot[[aux]]
                                                   }

                                                   if(classic){
                                                     p <- p + plot_layout(ncol = numCol, nrow = numRow) +
                                                       plot_annotation(title = main,
                                                                       theme = theme(plot.title = element_text(hjust = 0.5, 
                                                                                                               size = 15, 
                                                                                                               face = "bold")))
                                                     show(p)
                                                   }
                                                   else{show(p)}
                                                   par(mfcol=c(1,1))
                                                 },

                                                 lm = function(formula){
                                                   invisible(lm(formula, data = self$as.data.frame()))
                                                 },

                                                 desires = function(value){
                                                   if (missing(value)) {
                                                     return(self$desirability)
                                                   }
                                                   else{
                                                     if (!any(value$response == names(self$.response())))
                                                       stop(paste(value$response, "is not a response!"))
                                                     listPos = length(self$desirability) + 1
                                                     yName = value$response
                                                     isIn = (yName == names(self$desirability))
                                                     if (any(isIn))
                                                       listPos = (1:length(names(self$desirability)))[isIn]
                                                     self$desirability[[listPos]] = value
                                                     names(self$desirability)[listPos] = yName
                                                     invisible(self)
                                                   }

                                                 },

                                                 set.fits = function(value){
                                                   if (!identical(class(value), "lm"))
                                                     stop(paste(deparse(substitute(value)), "needs to an object of class lm"))
                                                   if (!any(names(value$model)[1] == names(self$.response())))
                                                     stop(paste("fitted response", names(value$model)[1], "could not be found in", deparse(substitute(x))))
                                                   listPos = length(self$fits) + 1
                                                   yName = names(value$model)[1]
                                                   isIn = (yName == names(self$fits))
                                                   if (any(isIn))
                                                     listPos = (1:length(names(self$fits)))[isIn]
                                                   self$fits[[listPos]] = value
                                                   names(self$fits)[listPos] = yName
                                                   invisible(self)

                                                 },

                                                 types = function(value){
                                                   if (missing(value)) {
                                                     v <- list()
                                                     for (i in 1:length(self$factors)) {
                                                       v[[self$names()[i]]] <- self$factors[[i]]$.type()
                                                     }
                                                     return(v)

                                                   }
                                                   else{
                                                     for (i in 1:length(self$factors)) {
                                                       if (!identical(value[i], "numeric") & !identical(value[i], "factor"))
                                                         stop(paste(value[i], "\ttype of factor needs to be 'numeric' or 'factor'"))
                                                       self$factors[[i]]$.type() = as.character(value[i])
                                                     }
                                                     invisible(self)
                                                   }
                                                 },

                                                 unit = function(value){
                                                   if (missing(value)) {
                                                     v <- list()
                                                     for (i in 1:length(self$factors)) {
                                                       v[[self$names()[i]]] <- self$factors[[i]]$.unit()
                                                     }
                                                     return(v)
                                                   }
                                                   else{
                                                     for (i in 1:length(self$factors)) if (length(value) > 1)
                                                       self$factors[[i]]$.unit() = as.character(value[i])
                                                     else self$factors[[i]]$.unit() = as.character(value[1])
                                                     invisible(self)
                                                   }

                                                 },

                                                 .star = function(value){
                                                   if (missing(value)) {
                                                     return(self$star)
                                                   }
                                                   else{
                                                     DB = FALSE
                                                     if (!is.data.frame(value))
                                                       stop("data.frame must be provided!")
                                                     if (.numFac(self) != ncol(value))
                                                       stop("number of columns not matching!")
                                                     if (nrow(value) == 0) {
                                                       return("TODO: remove star und Rest anpassen")
                                                     }
                                                     oldResponse = self$.response()
                                                     newDf = value
                                                     oldDf = self$star
                                                     numNewRow = nrow(newDf) - nrow(oldDf)
                                                     oldOrd = self$standardOrder
                                                     oldRunOrd = self$runOrder
                                                     len = nrow(oldOrd)
                                                     lenFirst = nrow(self$cube) + nrow(self$centerCube)
                                                     self$standardOrder = data.frame(StandOrd = 1:(len + numNewRow))
                                                     newRunOrd = data.frame()
                                                     if (numNewRow > 0) {
                                                       newNums = data.frame(newNums = seq(max(oldRunOrd) + 1, max(oldRunOrd) + numNewRow, by = 1))
                                                       if (DB)
                                                         print(newNums)
                                                       names(newNums) = names(oldRunOrd)
                                                       newRunOrd = data.frame(oldRunOrd[1:lenFirst, ])
                                                       if (DB)
                                                         print(newRunOrd)
                                                       names(newRunOrd) = names(oldRunOrd)
                                                       restFrame = data.frame(oldRunOrd[-c(1:lenFirst), ])
                                                       names(restFrame) = names(oldRunOrd)
                                                       newRunOrd = rbind(newRunOrd, newNums, restFrame)
                                                       if (DB)
                                                         print(newRunOrd)
                                                     }
                                                     else {
                                                       newRunOrd = data.frame(oldRunOrd[1:(lenFirst + nrow(newDf) + nrow(self$centerStar)), ])
                                                       names(newRunOrd) = names(oldRunOrd)
                                                     }
                                                     self$runOrder = newRunOrd
                                                     naFrame = as.data.frame(matrix(rep(NA, times = ncol(oldResponse) * nrow(newDf)), ncol = ncol(oldResponse)))
                                                     names(naFrame) = names(oldResponse)
                                                     newResponse = data.frame(oldResponse[1:lenFirst, ])
                                                     names(newResponse) = names(oldResponse)
                                                     restFrame = data.frame(oldResponse[-c(1:(lenFirst + nrow(oldDf))), ])
                                                     names(restFrame) = names(oldResponse)
                                                     newResponse = rbind(newResponse, naFrame, restFrame)
                                                     self$.response(newResponse)
                                                     if (DB) {
                                                       print(newResponse)
                                                       print("hinter response")
                                                     }
                                                     oldBlockGen = self$blockGen
                                                     if (ncol(oldBlockGen) > 0) {
                                                       if (DB)
                                                         print("TODO: BlockGen anpassen!")
                                                       newBlockGen = data.frame(oldBlockGen[1:lenFirst, ])
                                                       names(newBlockGen) = names(self$blockGen)
                                                       naFrameGen = as.data.frame(matrix(rep(NA, times = ncol(self$blockGen) * nrow(newDf)), ncol = ncol(self$blockGen)))
                                                       names(naFrameGen) = names(oldBlockGen)
                                                       restBlockGen = data.frame(oldBlockGen[-c(1:(lenFirst + nrow(oldDf))), ])
                                                       names(restBlockGen) = names(oldBlockGen)
                                                       newBlockGen = rbind(newBlockGen, naFrameGen, restBlockGen)
                                                       if (DB)
                                                         print(newBlockGen)
                                                       self$.blockGen(newBlockGen)
                                                     }
                                                     oldBlock = self$block
                                                     newBlock = data.frame(oldBlock[1:lenFirst, ])
                                                     names(newBlock) = names(oldBlock)
                                                     naFrame = as.data.frame(matrix(rep(max(newBlock) + 1, times = ncol(oldBlock) * nrow(newDf)),
                                                                                    ncol = ncol(oldBlock)))
                                                     names(naFrame) = names(oldBlock)
                                                     restBlock = data.frame(oldBlock[-c(1:(lenFirst + nrow(oldDf))), ])
                                                     names(restBlock) = names(oldBlock)
                                                     newBlock = rbind(newBlock, naFrame, restBlock)
                                                     self$.block(newBlock)
                                                     self$star <- newDf
                                                     invisible(self)
                                                   }
                                                 },

                                                 .blockGen = function(value){
                                                   if (missing(value)) {
                                                     return(self$blockGen)
                                                   }
                                                   else{
                                                     if (!is.vector(value) && !is.data.frame(value))
                                                       stop("vector or data.frame expected!")
                                                     if (is.vector(value) && (is.numeric(value) || is.na(value))) {
                                                       if (self$nrow() != length(value))
                                                         stop(paste("Number of rows for Design does not equal length of vector ", self$nrow(),
                                                                    " != ", length(value), " "))
                                                       self$blockGen <- as.data.frame(value)
                                                       names(self$blockGen) = deparse(substitute(value))

                                                     }
                                                     if (is.data.frame(value)) {
                                                       self$blockGen <- value

                                                     }
                                                     invisible(self)

                                                   }

                                                 },

                                                 .block = function(value){
                                                   if (missing(value)) {
                                                     return(self$block)
                                                   }
                                                   else{
                                                     if (!is.vector(value) && !is.data.frame(value))
                                                       stop("vector or data.frame expected!")
                                                     if (is.vector(value) && (is.numeric(value) || is.na(value))) {
                                                       if (self$nrow() != length(value))
                                                         stop(paste("Number of rows for Design does not equal length of vector ", nrow(object),
                                                                    " != ", length(value), " "))
                                                       self$block <- as.data.frame(value)
                                                       names(self$block) = deparse(substitute(value))

                                                     }
                                                     if (is.data.frame(value)) {
                                                       self$block <- value

                                                     }
                                                     invisible(self)

                                                   }
                                                 },

                                                 .centerCube = function(value){
                                                   if (missing(value)) {
                                                     return(self$centerCube)
                                                   }
                                                   else{
                                                     DB = FALSE
                                                     if (!is.data.frame(value))
                                                       stop("data.frame must be provided!")
                                                     if (.numFac(self) != ncol(value))
                                                       stop("number of columns not matching!")
                                                     if (nrow(value) == 0) {
                                                       return("TODO: remove CenterCube und Rest anpassen")
                                                     }
                                                     newDf = value
                                                     lenCube = nrow(self$cube)
                                                     oldDf = self$centerCube
                                                     oldRunOrd = self$runOrder
                                                     oldResponse = self$.response()
                                                     blockValues = unique(self$block[1:nrow(self$cube), ])
                                                     numBlocks = length(blockValues)
                                                     if (numBlocks > 1)
                                                       for (i in 1:(numBlocks - 1)) {
                                                         newDf = rbind(newDf, value)
                                                       }
                                                     if (DB)
                                                       print(newDf)
                                                     numNewRow = nrow(newDf) - nrow(oldDf)
                                                     oldOrd = self$standardOrder
                                                     len = nrow(oldOrd)
                                                     self$standardOrder = data.frame(StandOrd = 1:(len + numNewRow))
                                                     newRunOrd = data.frame()
                                                     if (numNewRow > 0) {
                                                       newNums = data.frame(newNums = seq(max(oldRunOrd) + 1, max(oldRunOrd) + numNewRow, by = 1))
                                                       names(newNums) = names(oldRunOrd)
                                                       if (DB) {
                                                         print("----")
                                                         print(newNums)
                                                       }
                                                       newRunOrd = data.frame(oldRunOrd[1:lenCube, ])
                                                       names(newRunOrd) = names(oldRunOrd)
                                                       restRunOrd = data.frame(oldRunOrd[-c(1:lenCube), ])
                                                       names(restRunOrd) = names(oldRunOrd)
                                                       newRunOrd = rbind(newRunOrd, newNums, restRunOrd)
                                                       if (DB) {
                                                         print("----")
                                                         print(oldRunOrd[-c(1:lenCube), ])
                                                         print("----")
                                                         print(newRunOrd)
                                                       }
                                                       self$runOrder = newRunOrd
                                                     }
                                                     else {
                                                       newRunOrd = data.frame(oldRunOrd[1:(lenCube + nrow(newDf)), ])
                                                       names(newRunOrd) = names(oldRunOrd)
                                                       restRunOrd = data.frame(oldRunOrd[-c(1:(lenCube + nrow(oldDf))), ])
                                                       names(restRunOrd) = names(oldRunOrd)
                                                       newRunOrd = rbind(newRunOrd, restRunOrd)
                                                       if (DB) {
                                                         print("----")
                                                         print(newRunOrd)
                                                       }
                                                       self$runOrder = newRunOrd
                                                     }
                                                     naFrame = as.data.frame(matrix(rep(NA, times = ncol(oldResponse) * nrow(newDf)), ncol = ncol(oldResponse)))
                                                     names(naFrame) = names(oldResponse)
                                                     newResponse = data.frame(oldResponse[1:lenCube, ])
                                                     names(newResponse) = names(oldResponse)
                                                     restResponse = data.frame(oldResponse[-c(1:(lenCube + nrow(oldDf))), ])
                                                     names(restResponse) = names(oldResponse)
                                                     newResponse = rbind(newResponse, naFrame, restResponse)
                                                     if (DB) {
                                                       print("newResponse_____")
                                                       print(newResponse)
                                                     }
                                                     self$.response(newResponse)
                                                     oldBlockGen = self$blockGen
                                                     if (ncol(oldBlockGen) > 0) {
                                                       if (DB)
                                                         print("TODO: BlockGen Spalte(n) anpassen")
                                                       newBlockGen = data.frame(oldBlockGen[1:lenCube, ])
                                                       names(newBlockGen) = names(self$blockGen)
                                                       naFrameGen = as.data.frame(matrix(rep(NA, times = ncol(self$blockGen) * nrow(newDf)), ncol = ncol(self$blockGen)))
                                                       names(naFrameGen) = names(oldBlockGen)
                                                       restFrame = data.frame(oldBlockGen[-c(1:(lenCube + nrow(oldDf))), ])
                                                       names(restFrame) = names(self$blockGen)
                                                       newBlockGen = rbind(newBlockGen, naFrameGen, restFrame)
                                                       self$.blockGen(newBlockGen)
                                                       if (DB)
                                                         print(newBlockGen)
                                                     }
                                                     oldBlock = self$block
                                                     newBlock = data.frame(oldBlock[1:lenCube, ])
                                                     names(newBlock) = names(self$block)
                                                     naFrame = as.data.frame(matrix(rep(blockValues, times = nrow(newDf)/numBlocks), ncol = 1))
                                                     restFrame = as.data.frame(oldBlock[-c(1:(lenCube + nrow(oldDf))), ])
                                                     names(restFrame) = names(self$block)
                                                     if (DB)
                                                       print(naFrame)
                                                     names(naFrame) = names(oldBlock)
                                                     newBlock = rbind(newBlock, naFrame, restFrame)
                                                     self$.block(newBlock)
                                                     self$centerCube <- newDf
                                                     invisible(self)
                                                   }

                                                 },

                                                 .centerStar = function(value){
                                                   if (missing(value)) {
                                                     return(self$centerStar)
                                                   }
                                                   else{
                                                     DB = FALSE
                                                     if (!is.data.frame(value))
                                                       stop("data.frame must be provided!")
                                                     if (.numFac(self) != ncol(value))
                                                       stop("number of columns not matching!")
                                                     if (nrow(value) == 0) {
                                                       return("TODO: remove CenterCube und Rest anpassen")
                                                     }
                                                     newDf = value
                                                     oldDf = self$centerStar
                                                     numNewRow = nrow(newDf) - nrow(oldDf)
                                                     oldResponse = self$.response()
                                                     lenRest = nrow(self$cube) + nrow(self$centerCube) + nrow(self$star)
                                                     oldRunOrd = self$runOrder
                                                     oldOrd = self$standardOrder
                                                     len = nrow(oldOrd)
                                                     self$standardOrder = data.frame(StandOrd = 1:(len + numNewRow))
                                                     newRunOrd = data.frame(oldRunOrd[1:lenRest, ])
                                                     names(newRunOrd) = names(oldRunOrd)
                                                     if (numNewRow > 0) {
                                                       newNums = data.frame(newNums = seq(max(oldRunOrd) + 1, max(oldRunOrd) + numNewRow, by = 1))
                                                       names(newNums) = names(oldRunOrd)
                                                       restFrame = data.frame(oldRunOrd[-c(1:lenRest), ])
                                                       names(restFrame) = names(oldRunOrd)
                                                       newRunOrd = rbind(newRunOrd, newNums, restFrame)
                                                       if (DB)
                                                         print(newRunOrd)
                                                       self$runOrder = newRunOrd
                                                     }
                                                     else {
                                                       newRunOrd = data.frame(oldRunOrd[1:(lenRest + nrow(newDf)), ])
                                                       names(newRunOrd) = names(oldRunOrd)
                                                       self$runOrder = newRunOrd
                                                     }
                                                     naFrame = as.data.frame(matrix(rep(NA, times = ncol(oldResponse) * nrow(newDf)), ncol = ncol(oldResponse)))
                                                     names(naFrame) = names(oldResponse)
                                                     newResponse = data.frame(oldResponse[1:lenRest, ])
                                                     names(newResponse) = names(self$.response())
                                                     newResponse = rbind(newResponse, naFrame)
                                                     if (DB)
                                                       print(" vor centerStar response")
                                                     self$.response(newResponse)
                                                     if (DB)
                                                       print("hinter centerStar response")
                                                     oldBlockGen = self$blockGen
                                                     if (ncol(oldBlockGen) > 0) {
                                                       print("TODO: BlockGen Spalte(n) anpassen")
                                                       newBlockGen = data.frame(oldBlockGen[1:lenRest, ])
                                                       names(newBlockGen) = names(self$blockGen)
                                                       naFrameGen = as.data.frame(matrix(rep(NA, times = ncol(self$blockGen) * nrow(newDf)), ncol = ncol(self$block)))
                                                       names(naFrameGen) = names(oldBlockGen)
                                                       restBlockGen = data.frame(oldBlockGen[-c(1:(lenRest + nrow(oldDf))), ])
                                                       names(restBlockGen) = names(oldBlockGen)
                                                       newBlockGen = rbind(newBlockGen, naFrameGen, restBlockGen)
                                                       if (DB)
                                                         print(newBlockGen)
                                                       self$.blockGen(newBlockGen)
                                                     }
                                                     oldBlock = self$block
                                                     newBlock = data.frame(oldBlock[1:lenRest, ])
                                                     names(newBlock) = names(self$block)
                                                     naFrame = as.data.frame(matrix(rep(max(self$block[1:nrow(self$cube), ]) + 1, times = ncol(self$block) *
                                                                                          nrow(newDf)), ncol = ncol(self$block)))
                                                     names(naFrame) = names(oldBlock)
                                                     restBlock = data.frame(oldBlock[-c(1:(lenRest + nrow(oldDf))), ])
                                                     names(restBlock) = names(oldBlock)
                                                     newBlock = rbind(newBlock, naFrame, restBlock)
                                                     self$.block(newBlock)
                                                     self$centerStar <- newDf
                                                     invisible(self)

                                                   }

                                                 },

                                                 .generators = function(value){
                                                   if (missing(value)) {
                                                     return(self$generator)

                                                   }
                                                   else{
                                                     self$generator <- value
                                                     invisible(self)
                                                   }
                                                 }




                                                 )
                      )

### necesito clase doeFactor####################
doeFactor <- R6Class('doeFactor', public = list(low = -1,
                                                 high = 1,
                                                 name = "",
                                                 unit = "",
                                                 type = "numeric",

                                                 attributes = function(){
                                                   v <- c(self$low, self$high, self$name, self$unit, self$type)
                                                 },

                                                 .low = function(value){
                                                   if (missing(value)) {
                                                     return(unlist(self$low))
                                                   }
                                                   else{
                                                     boolOld = is.numeric(unlist(self$low))
                                                     self$low <- value
                                                     boolNew = is.numeric(self$low)
                                                     if (boolNew)
                                                       self$type = "numeric"
                                                     else self$type = "factor"
                                                     if (boolOld != boolNew)
                                                       print("Note: The types of the factors were changed!")
                                                     invisible(self)
                                                   }
                                                 },

                                                 .high = function(value){
                                                   if (missing(value)) {
                                                     return(unlist(self$high))
                                                   }
                                                   else{
                                                     boolOld = is.numeric(unlist(self$high))
                                                     self$high <- value
                                                     boolNew = is.numeric(self$high)
                                                     if (boolNew)
                                                       self$type = "numeric"
                                                     else self$type = "factor"
                                                     if (boolOld != boolNew)
                                                       print("Note: The types of the factors were changed!")
                                                     invisible(self)
                                                   }
                                                 },

                                                .type = function(value){
                                                  if (missing(value)) {
                                                    return(self$type)
                                                  }
                                                  else{
                                                    self$type <- value
                                                    invisible(self)
                                                  }
                                                },

                                                .unit = function(value){
                                                  if (missing(value)){
                                                    return(self$unit)
                                                  }
                                                  else{
                                                    self$unit <- value
                                                    invisible(self)
                                                  }
                                                },

                                                names = function(value){
                                                  if (missing(value)) {
                                                    return(self$name)
                                                  }
                                                  else {
                                                    self$name <- value
                                                    invisible(self)
                                                  }
                                                },

                                                show = function(){
                                                  cat("Name: ", self$names(), "\n")
                                                  cat("low Setting: ", self$.low(), "\n")
                                                  cat("high setting: ", self$.high(), "\n")
                                                  cat("Unit: ", self$.unit(), "\n")
                                                  cat("type: ", self$.type(), "\n")
                                                  cat("\n")
                                                }

                                                )
                      )




### necesito funcion randomize####
randomize <- function (fdo, random.seed, so = FALSE)
{
  if (missing(random.seed))
    set.seed(93275938)
  else set.seed(random.seed)
  j = 1
  temp = fdo$runOrder
  for (i in sort(unique(fdo$block[, 1]))) {
    pos = !is.na(match(fdo$block[, 1], i))
    count = sum(as.numeric(pos))
    if (so) {
      temp[pos, 1] = j:(j + (count - 1))
    }
    else {
      temp[pos, 1] = sample(j:(j + (count - 1)), count)
    }
    j = j + count
  }
  fdo$runOrder = temp
  return(fdo)
}


### necesito .rsm#################
.rsm = vector(mode = "list", length = 7)
.rsm[[1]] = list(k = 3, blocks = 2, gen = c("ABC"))
.rsm[[2]] = list(k = 3, blocks = 4, gen = c("AB", "AC"))
.rsm[[3]] = list(k = 4, blocks = 2, gen = c("ABCD"))
.rsm[[4]] = list(k = 4, blocks = 4, gen = c("ABC", "ACD"))
.rsm[[5]] = list(k = 4, blocks = 8, gen = c("AB", "BC", "CD"))
.rsm[[6]] = list(k = 5, blocks = 2, gen = c("ABCDE"))
.rsm[[7]] = list(k = 5, blocks = 4, gen = c("ABC", "CDE"))
.rsm[[8]] = list(k = 5, blocks = 8, gen = c("ABE", "BCE", "CDE"))
.rsm[[9]] = list(k = 5, blocks = 16, gen = c("AB", "AC", "CD", "DE"))
.rsm[[10]] = list(k = 6, blocks = 2, gen = c("ABCDEF"))
.rsm[[11]] = list(k = 6, blocks = 4, gen = c("ABCF", "CDEF"))
.rsm[[12]] = list(k = 6, blocks = 8, gen = c("ABEF", "ABCD", "ACE"))
.rsm[[13]] = list(k = 6, blocks = 16, gen = c("ABF", "ACF", "BDF", "DEF"))
.rsm[[14]] = list(k = 6, blocks = 32, gen = c("AB", "BC", "CD", "DE", "EF"))
.rsm[[15]] = list(k = 7, blocks = 2, gen = c("ABCDEFG"))
.rsm[[16]] = list(k = 7, blocks = 4, gen = c("ABCFG", "CDEFG"))
.rsm[[17]] = list(k = 7, blocks = 8, gen = c("ABC", "DEF", "AFG"))
.rsm[[18]] = list(k = 7, blocks = 16, gen = c("ABD", "EFG", "CDE", "ADG"))
.rsm[[19]] = list(k = 7, blocks = 32, gen = c("ABG", "BCG", "CDG", "DEG", "EFG"))
.rsm[[20]] = list(k = 7, blocks = 64, gen = c("AB", "BC", "CD", "DE", "EF", "FG"))


### necesito .numFac#############
.numFac = function(fdo) {
  return(length(fdo$names()))
}


### necesito .confoundings####
.confoundings = function(blockGenVec, lSet, DB = FALSE) {
  biVec = character(0)
  for (i in 2:length(blockGenVec)) {
    mat = combn(blockGenVec, i)
    temp = apply(mat, 2, strsplit, split = "")
    comb = lapply(temp, unlist)
    comb = lapply(comb, c, lSet)
    if (DB) {
      print("here")
      print(comb)
    }
    combFreq = sapply(comb, table)%%2
    combBool = !apply(combFreq, 2, as.logical)
    chars = row.names(combFreq)
    if (DB)
      print(combBool)
    biTemp = character(0)
    for (j in 1:ncol(combBool)) {
      biTemp = c(biTemp, paste(chars[combBool[, j]], collapse = ""))
    }
    if (DB)
      print(biTemp)
    biVec = c(biVec, biTemp)
  }
  return(c(blockGenVec, biVec))
}


### necesito .lociv####
.lociv = function(charVec) {
  lenVec = numeric(length = length(charVec))
  for (i in seq(along = charVec)) {
    lenVec[i] = length(strsplit(charVec[i], split = "")[[1]])
  }
  return(lenVec)
}

### necesito .blockInteractions######
.blockInteractions = function(fdo, blocks = 2, useTable = "rsm") {
  DB = FALSE
  if (!(blocks %in% c(0, 1, 2, 4, 8, 16, 32, 64)))
    stop("blocks needs to be a power of 2 up to 64!")
  gen = NULL
  if (blocks %in% c(0, 1)) {
    if (DB)
      print("TODO: Return the Identity as generator")
    return(gen)
  }
  if (length(useTable) > 0) {
    if (!(nrow(unique(fdo$cube)) >= 2^.numFac(fdo)))
      stop("no blocking of a fractional factorial Design --> block on replicates instead!")
    if (identical(useTable, "rsm")) {
      for (i in seq(along = .rsm)) {
        if (.rsm[[i]]$k == .numFac(fdo) & .rsm[[i]]$blocks == blocks)
          return(.rsm[[i]]$gen)
      }
    }
    return(gen)
  }
  bgaci = matrix(nrow = 0, ncol = blocks - 1)
  if (!is.numeric(blocks))
    stop("blocks must be an integer")
  numCol = log2(blocks)
  blockGen = character(3)
  lSet = fdo$names()
  sSet = vector(mode = "list")
  for (i in length(lSet):2) {
    sSet = c(sSet, combn(lSet, i, simplify = FALSE))
  }
  if (blocks == 2) {
    index = order(sapply(sSet, length), decreasing = TRUE)[1]
    sSet = sapply(sSet, paste, collapse = "")
    return(sSet[index])
  }
  sSet = sapply(sSet, paste, collapse = "")
  if (DB)
    print(sSet)
  possGen = combn(sSet, numCol, simplify = FALSE)
  for (i in seq(along = possGen)) {
    blockGenVec = unlist(possGen[[i]])
    if (DB)
      print(blockGenVec)
    if (DB)
      print(.confoundings(blockGenVec, lSet))
    newRow = .confoundings(blockGenVec, lSet)
    if (!any(newRow %in% c(lSet, "")))
      bgaci = rbind(bgaci, .confoundings(blockGenVec, lSet))
  }
  mat = unique(t(apply(bgaci, 1, sort)))
  temp = t(apply(mat, 1, .lociv))
  temp = t(apply(temp, 1, sort))
  ref = temp[1, ]
  index = 1
  for (i in 1:nrow(temp)) {
    if (any((ref - temp[i, ]) < 0)) {
      ref = temp[i, ]
      index = i
    }
  }
  for (i in 1:nrow(temp)) {
    if (!(any(ref - temp[i, ] > 0) | any(ref - temp[i, ] < 0))) {
      index = c(index, i)
    }
  }
  temp = unique((mat[index, ]))
  cat("\nSuggested Effects for Blocking:")
  cat("\n")
  cat(temp[1, 1:numCol])
  cat("\n")
  cat("\nInteractions Confounded with blocks:")
  cat("\n")
  cat(unique(temp[1, ]))
  cat("\n")
  cat("\n Alternate Effects for Blocking:")
  cat(temp[c(-1), 1:numCol])
  cat("\n")
  gen = temp[1, 1:numCol]
  return(gen)
}



### necesito .blockGenCol##########
.blockGenCol = function(gen, fdo) {
  DB = FALSE
  blockVec = NULL
  .blockCol = NULL
  genList = gen
  genList = strsplit(genList, split = "")
  .fdo = fdo
  for (i in seq(along = genList)) {
    gen = genList[[i]]
    for (j in seq(along = gen)) {
      genTemp = .fdo$get(,gen[j])
      if (j == 1)
        blockVec = rep(1, length = length(genTemp))
      blockVec = blockVec * genTemp
      if (DB)
        print(blockVec)
    }
    if (i == 1)
      .blockCol = data.frame(B1 = blockVec)
    else .blockCol = cbind(.blockCol, blockVec)
  }
  names(.blockCol) = paste("B", 1:ncol(.blockCol), sep = "")
  return(.blockCol)
}


### necesito .blockCol##############
.blockCol = function(.blockGenCol) {
  DB = FALSE
  .blockCol = numeric(nrow(.blockGenCol))
  uniCol = unique(.blockGenCol)
  for (i in 1:nrow(uniCol)) {
    if (ncol(uniCol) == 1)
      .blockCol[apply(t(as.data.frame(apply(.blockGenCol, 1, "==", uniCol[i, ]))), 2, all)] = i
    else .blockCol[apply(apply(.blockGenCol, 1, "==", uniCol[i, ]), 2, all)] = i
  }
  return(data.frame(Block = .blockCol))
}


### necesito funcion blocking######
blocking <- function (fdo, blocks, BoR = FALSE, random.seed, useTable = "rsm",
                      gen)
{
  override = FALSE
  Block = data.frame(Block = rep(1, fdo$nrow()))
  fdo$.block(Block)
  fdo = randomize(fdo, so = TRUE)
  if (missing(random.seed)) {
    runif(1)
    random.seed = .Random.seed[sample(1:626, 1)]
  }
  if (missing(gen))
    gen = NULL
  if (blocks <= 1) {
    Block = data.frame(Block = rep(1, fdo$nrow()))
    fdo$.block(Block)
    fdo = randomize(fdo, random.seed = random.seed)
    return(fdo)
  }
  if (nrow(fdo$star) > 0 | nrow(fdo$centerStar) > 0) {
    if (blocks == 2) {
      override = TRUE
      fdo = randomize(fdo, so = TRUE)
      numB1 = nrow(fdo$cube) + nrow(fdo$centerCube)
      numB2 = fdo$nrow() - numB1
      fdo$.block(data.frame(Block = c(rep(1, numB1),
                                      rep(2, numB2))))
      fdo$.blockGen(data.frame(B1 = rep(NA, fdo$nrow())))
    }
    if (blocks %in% c(2, 3, 5, 9, 17))
      blocks = blocks - 1
    else stop("Blocking not possible")
  }
  else {
    if (!(blocks %in% c(1, 2, 4, 8, 16, 32, 64, 128)))
      stop("Blocking not possible")
  }
  if (is.null(gen))
    gen = .blockInteractions(fdo, blocks, useTable)
  if (is.null(gen) & !override) {
    cat("\n")
    cat(paste("Blocking in", blocks, "blocks not possible!"))
    cat("\n")
    return(fdo)
  }
  if (!override) {
    .blockGenCol = .blockGenCol(gen, fdo)
    .blockCol = .blockCol(.blockGenCol)
    Block = .blockCol
    BlockGenCol = .blockGenCol
    fdo$.block(Block)
    fdo$.blockGen(BlockGenCol)
  }
  numCC = nrow(fdo$centerCube)
  if (numCC > 0) {
    ccFrame = as.data.frame(matrix(0, nrow = numCC, ncol = ncol(fdo$cube)))
    names(ccFrame) = names(fdo)
    fdo$.centerCube(ccFrame)
  }
  fdo = randomize(fdo, random.seed = random.seed)
  return(fdo)
}


### necesito funcion "fracDesign"###################

fracDesign <- function (k = 3, p = 0, gen = NULL, replicates = 1, blocks = 1,
  centerCube = 0, random.seed = 1234)
{
  DB = FALSE
  STDfdo = FALSE
  if (p < 0 || p > 7)
    stop("p needs to be an integer between 0 and 7!")
  if (abs(p - round(p)) > .Machine$double.eps^0.5) {
    warning(paste("p needs to be an integer but is real! p was rounded to",
      round(p)))
    p = round(p)
  }
  if (p != 0) {
    gen = NULL
    for (i in 1:length(.fdoOrth)) {
      if (k == .fdoOrth[[i]]$k && p == .fdoOrth[[i]]$p) {
        STDfdo = TRUE
        return(fracDesign(k = .fdoOrth[[i]]$k, gen = .fdoOrth[[i]]$gen,
          replicates = replicates, blocks = blocks,
          centerCube = centerCube, random.seed = random.seed))
      }
    }
    if (STDfdo == FALSE)
      stop("No standard Design for the choosen combination of k and p (see: fracChoose())!")
  }
  if (!is.numeric(random.seed))
    stop("random.seed needs to be numeric")
  if (!is.numeric(blocks))
    stop("blocks needs to be numeric!")
  if (!is.numeric(replicates)){
    stop("replicates needs to be numeric!")
  } else {
    if (replicates < 0){
      stop("replicates need to >= 0")
    }
  }
  N <- 2^k
  X <- matrix(NA, nrow = N, ncol = k)
  for (j in 1:k) X[, j] <- rep(sort(rep(c(-1, 1), N/2^j)),
    2^(j - 1))
  X <- X[, ncol(X):1]
  if (is.null(gen)) {
    X = as.data.frame(X)
    names(X) = .NAMES[1:k]
  }
  origX = X
  if (replicates > 1) {
    for (i in 2:replicates) {
      X = rbind(X, origX)
    }
  }
  frameOut = data.frame(X)
  if (DB)
    print("juhu")
  if (!is.null(gen)) {
    listGen = vector("list", length(gen))
    .numFactors = numeric(0)
    charFactors = character(0)
    if (DB) {
      cat(paste("gen is: ", gen, "\n"))
      cat(paste("length of gen is: ", length(gen), "\n"))
      print(listGen)
    }
    temp = character(0)
    for (i in seq(along = gen)) {
      if (DB)
        cat("gen[", i, "] = ", gen[i], "\n")
      if (!is.character(gen[i]))
        stop("Defining Relations should contain characters only!")
      chars = strsplit(gen[i], split = character(0))[[1]]
      if (DB) {
        cat("\nchars: ")
        print(chars)
        cat("\n")
      }
      checkDupl = character(0)
      for (j in 1:length(chars)) {
        if (chars[j] %in% toupper(c(.NAMES[1:26], letters[1:26]))) {
          if (chars[j] %in% checkDupl)
            stop("Defining relations contain one or more duplicates!")
          checkDupl = c(checkDupl, chars[j])
          temp = c(temp, chars[j])
        }
      }
      if (DB) {
        cat("\ntemp: ")
        print(temp)
        cat("\n")
      }
    }
    temp = sort(unique(temp))
    numCharVec = 1:length(temp)
    names(numCharVec) = temp
    if (DB) {
      cat("Zuordnung Buchstabe und Spalte:\n")
      print(numCharVec)
      cat("\n")
    }
    for (i in seq(along = gen)) {
      if (DB)
        cat("gen[", i, "] = ", gen[i], "\n")
      if (!is.character(gen[i]))
        stop("Defining Relations should contain characters only!")
      chars = strsplit(gen[i], split = character(0))[[1]]
      numVec = numeric(0)
      charVec = character(0)
      allowedChars = c(.NAMES[1:26], letters[1:26], "=")
      for (j in 1:length(chars)) {
        if (chars[j] %in% allowedChars) {
          if ((chars[j] == "=") & (length(numVec) !=
            1))
            stop("check position of \"=\" in generators!")
          if (chars[j] != "=") {
            charVec = c(charVec, toupper(chars[j]))
            numVec = c(numVec, numCharVec[names(numCharVec) ==
              toupper(chars[j])])
          }
        }
      }
      if (DB) {
        cat("charVec for i = ", i, ": ", charVec, "\n")
        cat("numVec for i = ", i, ": ", numVec, "\n")
      }
      listGen[[i]] = numVec
      .numFactors = c(.numFactors, numVec)
      charFactors = c(charFactors, charVec)
    }
    if (DB)
      print("juhu")
    names(.numFactors) = charFactors
    if (length(unique(.numFactors)) > k)
      stop("number of distinct Factors in generators greater than k!")
    if (DB) {
      print(listGen)
      print(.numFactors)
      print(charFactors)
    }
    for (i in seq(along = listGen)) {
      ind <- trunc(listGen[[i]])
      if (any(abs(ind) > k))
        stop(paste("generator:", paste(ind[1], "=",
          paste(ind[-1], collapse = "*")), "includes undefined columns"))
      x <- rep(sign(ind[1]), N)
      for (j in ind[-1]) x <- x * X[, j]
      X[, abs(ind[1])] <- x
    }
    X <- unique(X)
    origX = X
    if (replicates > 1) {
      for (i in 2:replicates) {
        X = rbind(X, origX)
      }
    }
    frameOut = as.data.frame(X)
    names(frameOut) = names(numCharVec)
    if (k > length(temp)) {
      charsLeft = (.NAMES[1:26])[-match(charFactors, .NAMES[1:26])]
      naIndex = (1:k)[is.na(names(frameOut))]
      names(frameOut)[naIndex] = charsLeft[1:length(naIndex)]
    }
  }
  DesignOut <- facDesign.c$new()
  DesignOut$generator <-  gen
  DesignOut$cube <-  frameOut
  listFac <-  vector("list", ncol(frameOut))
  for (i in seq(along = listFac)){
    listFac[[i]] = doeFactor$new()
    listFac[[i]]$name = names(frameOut)[i]
  }


  DesignOut$factors = listFac
  if (DB)
    print(frameOut)
  if (DB)
    print("yes")
  if (DB)
    print("aha")
  if (centerCube >= 1) {
    temp = data.frame(matrix(rep(0, centerCube * k), ncol = k,
                             nrow = centerCube))
    names(temp) = names(frameOut)
    DesignOut$centerCube = temp
  }
  numRows = nrow(DesignOut$cube) + nrow(DesignOut$centerCube) + nrow(DesignOut$star) +
    nrow(DesignOut$centerStar)
  if (DB) {
    print(numRows)
    print("response")
  }
  DesignOut$response = data.frame(y = rep(NA, numRows))
  if (DB)
    print("response")
  standardOrder = data.frame(matrix(data = 1:numRows, nrow = numRows,
    ncol = 1))
  names(standardOrder) = "StandOrder"
  DesignOut$standardOrder <-  standardOrder
  if (DB)
    print("1")
  set.seed(random.seed)
  runOrder = as.data.frame(standardOrder[sample(1:numRows),])
  if (DB)
    print("2")
  names(runOrder) = "RunOrder"
  DesignOut$runOrder <- runOrder
  if (DB)
    print("3")
  temp = try(blocking(DesignOut, blocks = blocks)) #################Poner random.seed para variar con semilla
  if (inherits(temp, "try-error"))
    stop("Blocking not possible!")
  return(blocking(DesignOut, blocks = blocks))  #################Poner random.seed para variar con semilla
}

### Funcion facDesign########################
facDesign <- function (k = 3, p = 0, replicates = 1, blocks = 1, centerCube = 0, random.seed = 1234)
{
  frameOut = fracDesign(k = k, p = p, gen = NULL, replicates = replicates,
                        blocks = blocks, centerCube = centerCube, random.seed = random.seed)
  return(frameOut)
}


```

```{r}
###### USO DE facDesign ######

dfac <- facDesign(k = 3, centerCube = 4)
#dfac$names()
dfac$names(c('Factor 1', 'Factor 2', 'Factor 3'))
#dfac$names()
dfac$lows(c(80,120,1))
#dfac$lows()
dfac$highs(c(120,140,2))
#dfac$highs()
dfac$summary()
```

```{r, echo=FALSE}
### necesito funcion .norm2d ###########
.norm2d <- function(x1, x2, mu1 = 160, mu2 = 165, rho = 0.7, sigma1 = 45, sigma2 = 22.5) {
  z = 1/(2 * pi * sigma1 * sigma2 * sqrt(1 - rho^2)) * exp(-1/(2 * (1 - rho^2)) * (((x1 - mu1)/sigma1)^2 - 2 * rho * (x1 - mu1)/sigma1 * (x2 - mu2)/sigma2 +
                                                                                     ((x2 - mu2)/sigma2)^2))
  return(z)
}
### Funcion simProc#####################################
simProc <- function(x1, x2, x3, noise = TRUE) {
  max_z = 0.0002200907
  min_z = 8.358082e-10
  yield = .norm2d(x1 = x1, x2 = x2)
  yield = yield - min_z
  yield = (yield/max_z) * 0.9
  if (noise)
    yield = yield + rnorm(length(yield), mean = 0, sd = 0.007)
  return(yield)
}
```

```{r}
################# USO simProc ################# 

# Primeros valores
rend <- simProc(x1=120,x2=140,x3=2)

# valores completos
rend <- c(simProc(120,140,1),simProc(80,140,1),simProc(120,140,2),simProc(120,120,1),simProc(90,130,1.5),simProc(90,130,1.5),simProc(80,120,2),simProc(90,130,1.5),simProc(90,130,1.5),simProc(120,120,2),simProc(80,140,2),simProc(80,120,1))

# Asignar rendimiento al diseño factorial
dfac$.response(rend)
dfac$.response()
```

```{r}
### effectPlot #### 
dfac$effectPlot(classic=TRUE)
dfac$effectPlot()
```


```{r, echo=FALSE}
### necesito .letterPos  .testFun# ############
.letterPos <- function(LETTER) {
  if (!(nchar(LETTER) == 1))
    stop("factor names should be single characters only")
  return((1:26)[LETTERS[1:26] == LETTER])
}
.testFun <- function(x.factor, trace.factor, response, fun = base::mean, type = c("l", "p", "b"), legend = TRUE, trace.label = deparse(substitute(trace.factor)),
                    fixed = FALSE, xlab = deparse(substitute(x.factor)), ylab = ylabel, ylim = range(cellNew, na.rm = TRUE), lty = nc:1, col = 1, pch = c(1L:9, 0, letters),
                    xpd = NULL, leg.bg = par("bg"), leg.bty = "o", xtick = FALSE, xaxt = par("xaxt"), axes = TRUE, title = "", ...) {
  ylabel <- paste(deparse(substitute(fun)), "of ", deparse(substitute(response)))
  type <- match.arg(type)
  cellNew <- tapply(response, list(x.factor, trace.factor), fun)
  nr <- nrow(cellNew)
  nc <- ncol(cellNew)
  xvals <- 1L:nr
  if (is.ordered(x.factor)) {
    wn <- getOption("warn")
    options(warn = -1)
    xnm <- as.numeric(levels(x.factor))
    options(warn = wn)
    if (!any(is.na(xnm)))
      xvals <- xnm
  }
  xlabs <- rownames(cellNew)
  ylabs <- colnames(cellNew)
  nch <- max(sapply(ylabs, nchar, type = "width"))
  if (is.null(xlabs))
    xlabs <- as.character(xvals)
  if (is.null(ylabs))
    ylabs <- as.character(1L:nc)
  xlim <- range(xvals)
  xleg <- xlim[2L] + 0.05 * diff(xlim)
  xlim <- xlim + c(-0.2/nr, if (legend) 0.2 + 0.02 * nch else 0.2/nr) * diff(xlim)
  matplot(xvals, cellNew, ..., type = type, xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab, axes = axes, xaxt = "n", col = col, lty = lty, pch = pch)
  if (axes && xaxt != "n") {
    axisInt <- function(x, main, sub, lwd, bg, log, asp, ...) axis(1, x, ...)
    mgp. <- par("mgp")
    if (!xtick)
      mgp.[2L] <- 0
    axisInt(1, at = xvals, labels = xlabs, tick = xtick, mgp = mgp., xaxt = xaxt, ...)
  }
  if (legend) {
    legpretty = ylabs
    legend("topright", legend = legpretty, title = title, col = col, pch = if (type %in% c("p", "b"))
      pch, lty = if (type %in% c("l", "b"))
        lty, bty = leg.bty, bg = leg.bg, inset = 0.02)
  }
  return(list(xvals, xlabs))
}


### necesito InteractionPlot#########################################################
interactionPlot <- function(fdo, y = NULL, response = NULL, fun = base::mean, main, col = 1:2, ...) { ###
  DB = FALSE
  mainmiss = FALSE
  if (missing(main))
    mainmiss = TRUE
  if (missing(fdo) || class(fdo)[1]!="facDesign")                                ###
    stop("fdo needs to be an object of class facDesign")                    ###
  parList = list(...)
  old.par <- par(no.readonly = TRUE)
  fdoName = deparse(substitute(fdo))                                          ###
  if(is.null(response)==FALSE)                                                ###
  {                                                                           ###
    temp=fdo$.response()[response]                                               ###
    fdo$.response(temp)                                                         ###
  }                                                                           ###
  diagNames = character(0)
  x = fdo$cube
  runIndex = order(fdo$runOrder[,1])
  x = x[runIndex[1:nrow(x)], ]
  y = fdo$.response()[1:nrow(x), ]
  numFac = ncol(x)
  combMat = combn(names(x), 2)
  if (numFac == 2) {
    facName2 = combMat[1, 1]
    facName1 = combMat[2, 1]
    temp = with(cbind(y, x), .testFun(eval(parse(text = facName2)), eval(parse(text = facName1)), xlab = facName1, response = y, trace.label = facName1,
                                      ylim = range(y), axes = F, fun, title = facName1, col = col, ...))
    tempList = parList
    tempList$col = 1
    tempList$lwd = 1
    tempList$side = c(2)
    do.call(axis, tempList)
    box()
    tempList$at = temp[[1]]
    tempList$labels = temp[[2]]
    tempList$side = c(1)
    do.call(axis, tempList)
    invisible()
  }

  for (r in 1:ncol(fdo$.response())) {
    if (r > 1)
      dev.new()
    y = fdo$.response()[1:nrow(x), r]
    par(mfrow = c(numFac, numFac))
    par(mar = c(0, 0, 0, 0))
    par(oma = c(0, 0, 8, 8))
    plot(1, 1, type = "n", axes = FALSE, xlab = "", ylab = "", main = "")
    for (i in 1:ncol(combMat)) {
      facName1 = combMat[1, i]
      facName2 = combMat[2, i]
      rowNum = .letterPos(facName1)
      colNum = .letterPos(facName2)
      if (DB) {
        print(numFac)
        print(rowNum)
        print(colNum)
        print(facName1)
        print(facName2)
        print(y)
        print(fun)
        cat(paste(i, "\t", c(rowNum, colNum)))
      }
      par(mfg = c(rowNum, colNum))
      temp = with(cbind(x, y), .testFun(eval(parse(text = facName2)), eval(parse(text = facName1)), response = y, trace.label = facName1, ylim = range(y),
                                        axes = F, fun = fun, title = facName1, col = col, ...))
      if (colNum == numFac) {
        tempList = parList
        tempList$col = 1
        tempList$lwd = 1
        tempList$side = 4
        do.call(axis, tempList)
      }
      if (rowNum == 1) {
        tempList = parList
        tempList$col = 1
        tempList$lwd = 1
        tempList$side = 3
        tempList$at = temp[[1]]
        tempList$labels = temp[[2]]
        do.call(axis, tempList)
      }
      box(which = "plot")
      par(mfg = c(rowNum, rowNum))
      plot(c(-1, 1), c(-1, 1), type = "n", axes = F, xlab = "", ylab = "", main = "")
      text(0, 0, facName1, cex = 4)
      diagNames = c(diagNames, facName1)
    }
    par(mfg = c(numFac, numFac))
    plot(c(-1, 1), c(-1, 1), type = "n", axes = F, xlab = "", ylab = "", main = "")
    text(0, 0, setdiff(names(x), diagNames), cex = 4)
    if (mainmiss) {
      main = paste("Interaction plot for", names(fdo$.response())[r], "in", fdoName)         ###
      title(main, outer = T, ...)
    }
    else title(main[r], outer = T, ...)
  }
  #    }
  par(old.par)
  invisible()
}



```

```{r}
### Uso interactionPlot ####
interactionPlot(dfac)
```


```{r}
### lm ###
m1 <- dfac$lm(rend ~ A*B*C)
summary(m1)
```

```{r,echo=FALSE}
### necesito .splitDev ##########################################
.splitDev = function(x) {
  if (x > 6)
    dev = TRUE
  else dev = FALSE
  if (x == 1)
    mfrow = c(1, 1)
  if (x == 2)
    mfrow = c(1, 2)
  if (x == 3)
    mfrow = c(2, 2)
  if (x == 4)
    mfrow = c(2, 2)
  if (x == 5)
    mfrow = c(2, 3)
  if (x == 6)
    mfrow = c(2, 3)
  if (x >= 7)
    mfrow = c(3, 3)
  return(list(dev, mfrow))
}
### Funcion paretoPlot#################################
paretoPlot <- function(fdo, threeWay = FALSE, abs = TRUE, decreasing = TRUE, na.last = NA, alpha = 0.05, response = NULL, ylim, xlab, ylab, main, single = TRUE, ...) {  ###
  if(single==FALSE)                                                           ###
    par(mfrow=.splitDev(length(fdo$.response()))[[2]])                           ###
  if(is.null(response)==FALSE)                                                ###
  {                                                                           ###
    temp=fdo$.response()[response]                                               ###
    fdo$.response(temp)                                                         ###
  }                                                                           ###
  ylimMissing = FALSE
  if (missing(ylim)){
    ylimMissing = TRUE
    ylim = ""
  }
  if (missing(xlab))
    xlab = ""
  location = "topright"
  if (decreasing == F) {
    location = "topleft"
  }
  xVals = numeric(0)
  sig.neg = NULL
  sig.pos = NULL
  effect.list = vector("list")
  suppressMessages(
    for (j in 1:ncol(fdo$.response())) {
      if (j > 1 && single==TRUE) {
        dev.new()
        par(mar = c(5.1, 4.1, 4.1, 4.1))
      }
      if (!any(is.na(fdo$.response()[, j]))) {
        if (missing(ylab))
          ylabel = names(fdo$.response())[j]                                ###
        else
          ylabel = ylab                                                   ###
        form = paste("fdo$.response()[,", j, "]~")
        for (i in 1:ncol(fdo$cube)) {
          form = paste(form, names(fdo$cube)[i], sep = "")
          if (i < ncol(fdo$cube))
            form = paste(form, "*", sep = "")
        }
        lm.1 = lm(as.formula(form), data = fdo$as.data.frame())
        coefs = coef(lm.1)[-pmatch("(Intercept)", names(coef(lm.1)))]
        df.resid = df.residual(lm.1)
        num.c = nrow(fdo$centerCube)
        if (df.resid == 0) {
          effect = 2 * coefs
          effect = effect[!is.na(effect)]
          effect.list[[j]] = effect
          if (missing(main))
            main = "Lenth Plot of effects"
          plt = TRUE
          limits = TRUE
          faclab = NULL
          m = length(effect)
          d = m/3
          s0 = 1.5 * median(abs(effect))
          rmedian = effect[abs(effect) < 2.5 * s0]
          PSE = 1.5 * median(abs(rmedian))
          ME = qt(1 - alpha/2, d) * PSE
          Gamma = (1 + (1 - alpha)^(1/m))/2
          SME = qt(Gamma, d) * PSE
          n = length(effect)
          if (ylimMissing)
            if (abs)
              ylim <- (range(c(0, abs(effect), 1.3 * ME))) * 1.1
          else ylim <- (range(c(effect, -1.3 * ME, 1.3 * ME))) * 1.1
          if (abs) {
            if (missing(ylabel))
              ylabel = ""
            p <- ggplot(data.frame(names = names(effect), effect_ = abs(as.vector(effect))),
                        aes(x = names, y = effect_)) +
              geom_bar(stat = "identity",  fill = "lightblue", color = "black") + theme_minimal()+
              geom_text(aes(label = round(effect,2)), vjust = -1, colour = "black") + # etiquetas sobre las barras
              labs(title = main, x = "", y = ylabel) + ylim(c(ylim)) +
              theme(axis.text.x = element_text(angle = 90, hjust = 1),
                    plot.title = element_text(hjust = 0.5))

            if(ME >= ylim[1] & ME <= ylim[2]){
              p <- p + geom_hline(yintercept = ME, linetype = "dashed", color = "red") +
                scale_y_continuous(limits = ylim, expand = c(0, 0),sec.axis = sec_axis(~ ., breaks = c(ME), labels = c(paste("ME = ", round(ME, 2)))))

            }
            if(SME >= ylim[1] & SME <= ylim[2]){
              p <- p + geom_hline(yintercept = SME, linetype = "dashed", color = "red") +
                scale_y_continuous(limits = ylim, expand = c(0, 0),sec.axis = sec_axis(~ ., breaks = c(SME), labels = c(paste("SME = ", round(ME, 2)))))
            }
          }
          else {
            if (missing(ylabel))
              ylabel = ""
            p <- ggplot(data.frame(names = names(effect), effect_ = as.vector(effect)),
                        aes(x = names, y = effect_)) +
              geom_bar(stat = "identity",  fill = "lightblue", color = "black") + theme_minimal()+
              geom_text(aes(label = round(effect,2)), vjust = -1, colour = "black") + # etiquetas sobre las barras
              labs(title = main, x = "", y = ylabel) + ylim(c(ylim)) +
              theme(axis.text.x = element_text(angle = 90, hjust = 1),
                    plot.title = element_text(hjust = 0.5))
            if(ME >= ylim[1] & ME <= ylim[2]){
              p <- p + geom_hline(yintercept = ME, linetype = "dashed", color = "red") +
                scale_y_continuous(limits = ylim, expand = c(0, 0),sec.axis = sec_axis(~ ., breaks = c(ME), labels = c(paste("ME = ", round(ME, 2)))))

            }
            if(SME >= ylim[1] & SME <= ylim[2]){
              p <- p + geom_hline(yintercept = SME, linetype = "dashed", color = "red") +
                scale_y_continuous(limits = ylim, expand = c(0, 0),sec.axis = sec_axis(~ ., breaks = c(SME), labels = c(paste("SME = ", round(ME, 2)))))
            }
          }
        }
        else {
          if (missing(main))
            main = "Standardized main effects and interactions"
          effect = ((summary(lm.1)$coefficients[-pmatch("(Intercept)", names(coef(lm.1))), 1])/(summary(lm.1)$coefficients[-pmatch("(Intercept)", names(coef(lm.1))),
                                                                                                                           2]))
          if (all(is.na(effect)))
            stop("effects could not be calculated")
          effect = effect[!is.na(effect)]
          effect.list[[j]] = effect
          if ((df.resid) > 0) {
            sig.pos = -qt(alpha/2, df.resid)
            sig.neg = +qt(alpha/2, df.resid)
          }
          # Ylimits ----

          if (ylimMissing)
            if (abs) {
              tempVec = c(effect, sig.pos)
              tempVec = tempVec[!is.na(tempVec)]
              ylim = c(0, 1.3 * max(tempVec))
            }
          else {
            tempVec1 = c(0, effect, sig.neg, sig.pos)
            tempVec1 = tempVec1[!is.na(tempVec1)]
            tempVec2 = c(abs(effect), sig.pos, sig.neg)
            tempVec2 = tempVec2[!is.na(tempVec2)]
            ylim = c(1.3 * min(tempVec1), 1.3 * max(tempVec2))
          }

          effect = effect[order(abs(effect), na.last = TRUE, decreasing = decreasing)]
          effect = round(effect, 3)

          # Plot ---------
          if (abs) {
            if (missing(ylabel))
              ylabel = ""
            # plot with abs
            p <- ggplot(data.frame(names = names(effect), effect_ = abs(as.vector(effect))),
                        aes(x = reorder(names, effect_,decreasing = TRUE), y = effect_)) +
              geom_bar(stat = "identity",  fill = "lightblue", color = "black") + theme_minimal()+
              labs(title = main, x = "", y = ylabel) + ylim(c(ylim)) +
              theme(axis.text.x = element_text(angle = 90, hjust = 1),
                    plot.title = element_text(hjust = 0.5)) +
              geom_text(aes(label = round(effect,2)), vjust = -1, colour = "black") + # etiquetas sobre las barras
              geom_hline(yintercept = sig.pos, linetype = "dashed", color = "red") +
              scale_y_continuous(limits = ylim, expand = c(0, 0),sec.axis = sec_axis(~ ., breaks = c(sig.pos), labels = c(round(sig.pos, 2))))
          }
          else {
            if (missing(ylabel))
              ylabel = ""
            # Plot without abs
            p <- ggplot(data.frame(names = names(effect), effect_ = as.vector(effect)),
                        aes(x = reorder(names, effect_,decreasing = TRUE), y = effect_)) +
              geom_bar(stat = "identity",  fill = "lightblue", color = "black") + theme_minimal()+
              labs(title = main, x = "", y = ylabel) + ylim(c(ylim)) +
              theme(axis.text.x = element_text(angle = 90, hjust = 1),
                    plot.title = element_text(hjust = 0.5)) +
              geom_text(aes(label = round(effect)), vjust = -1, colour = "black") + # etiquetas sobre las barras
              geom_hline(yintercept = sig.pos, linetype = "dashed", color = "red") +
              geom_hline(yintercept = sig.neg, linetype = "dashed", color = "red") +
              scale_y_continuous(limits = ylim, expand = c(0, 0),sec.axis = sec_axis(~ ., breaks = c(sig.pos, sig.neg), labels = c(round(sig.pos, 2), round(sig.neg, 2))))
          }
          myDelta = diff(range(ylim)) * 0.02
        }
        # Legend ----
        titles <- data.frame(Name_title = paste0(names(fdo$cube),": ",fdo$names()))
        for(i in 1:dim(titles)[1]){
          titles$Pos_title[i] <- 0.95 - (0.05 * i)
        }
        caja <- ggplot(data.frame(x = 0,y = 0), aes(x = x, y = y)) +
          theme_bw() +
          theme(
            axis.text = element_blank(),
            axis.ticks = element_blank(),
            axis.title = element_blank(),
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            plot.title = element_text(hjust = 0.5, vjust = -0.5,margin = margin(b = -12), size = 10)
          ) + xlim(c(0.24, 0.26)) + ylim(c(min(titles$Pos_title) - 0.01, max(titles$Pos_title) + 0.01))
        for(i in 1:dim(titles)[1]){
          caja <- caja + annotate("text", x = 0.25, y = titles$Pos_title[i], label = titles$Name_title[i], size = 3.5, hjust = 0.5)
        }
        # insert legend -----
        if(location == "topright"){
          p <- p + inset_element(caja, left = 0.75, right = 1, top = 1,  bottom = 0.80)
        }
        else{
          p <- p + inset_element(caja, left = 0.25, right = 0.05, top = 1,  bottom = 0.80)
        }

      }

    }
  )
  show(p)
  invisible(list(effect.list, plot = p))
  par(mfcol=c(1,1))
}

```

```{r}
### Uso paretoPlot#################################
paretoPlot(dfac)
```

```{r, echo=FALSE}
#### necesito FitDistr ##############
FitDistr <- function (x, densfun, start, ...){
  myfn <- function(parm, ...) -sum(log(dens(parm, ...)))
  mylogfn <- function(parm, ...) -sum(dens(parm, ..., log = TRUE))
  mydt <- function(x, m, s, df, log) dt((x - m)/s, df, log = TRUE) -
    log(s)
  Call <- match.call(expand.dots = TRUE)
  if (missing(start))
    start <- NULL
  dots <- names(list(...))
  dots <- dots[!is.element(dots, c("upper", "lower"))]
  if (missing(x) || length(x) == 0L || mode(x) != "numeric")
    stop("'x' must be a non-empty numeric vector")
  if (any(!is.finite(x)))
    stop("'x' contains missing or infinite values")
  if (missing(densfun) || !(is.function(densfun) || is.character(densfun)))
    stop("'densfun' must be supplied as a function or name")
  control <- list()
  n <- length(x)
  if (is.character(densfun)) {
    distname <- tolower(densfun)
    densfun <- switch(distname, beta = dbeta, cauchy = dcauchy,
                      `chi-squared` = dchisq, exponential = dexp, f = df,
                      gamma = dgamma, geometric = dgeom, `log-normal` = dlnorm,
                      lognormal = dlnorm, logistic = dlogis, `negative binomial` = dnbinom,
                      normal = dnorm, poisson = dpois, t = mydt, weibull = dweibull,
                      NULL)
    if (is.null(densfun))
      stop("unsupported distribution")
    if (distname %in% c("lognormal", "log-normal")) {
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "log-Normal"), domain = NA)
      if (any(x <= 0))
        stop("need positive values to fit a log-Normal")
      lx <- log(x)
      sd0 <- sqrt((n - 1)/n) * sd(lx)
      mx <- mean(lx)
      estimate <- c(mx, sd0)
      sds <- c(sd0/sqrt(n), sd0/sqrt(2 * n))
      names(estimate) <- names(sds) <- c("meanlog", "sdlog")
      vc <- matrix(c(sds[1]^2, 0, 0, sds[2]^2), ncol = 2,
                   dimnames = list(names(sds), names(sds)))
      names(estimate) <- names(sds) <- c("meanlog", "sdlog")
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dlnorm(x, mx, sd0, log = TRUE))), class = "FitDistr"))
    }
    if (distname == "normal") {
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "Normal"), domain = NA)
      sd0 <- sqrt((n - 1)/n) * sd(x)
      mx <- mean(x)
      estimate <- c(mx, sd0)
      sds <- c(sd0/sqrt(n), sd0/sqrt(2 * n))
      names(estimate) <- names(sds) <- c("mean", "sd")
      vc <- matrix(c(sds[1]^2, 0, 0, sds[2]^2), ncol = 2,
                   dimnames = list(names(sds), names(sds)))
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dnorm(x, mx,
                                                                 sd0, log = TRUE))), class = "FitDistr"))
    }
    if (distname == "poisson") {
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "Poisson"), domain = NA)
      estimate <- mean(x)
      sds <- sqrt(estimate/n)
      names(estimate) <- names(sds) <- "lambda"
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("lambda",
                                                              "lambda"))
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dpois(x, estimate,
                                                                 log = TRUE))), class = "FitDistr"))
    }
    if (distname == "exponential") {
      if (any(x < 0))
        stop("Exponential values must be >= 0")
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "exponential"), domain = NA)
      estimate <- 1/mean(x)
      sds <- estimate/sqrt(n)
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("rate",
                                                              "rate"))
      names(estimate) <- names(sds) <- "rate"
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dexp(x, estimate,
                                                                log = TRUE))), class = "FitDistr"))
    }
    if (distname == "geometric") {
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "geometric"), domain = NA)
      estimate <- 1/(1 + mean(x))
      sds <- estimate * sqrt((1 - estimate)/n)
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("prob",
                                                              "prob"))
      names(estimate) <- names(sds) <- "prob"
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dgeom(x, estimate,
                                                                 log = TRUE))), class = "FitDistr"))
    }
    if (distname == "weibull" && is.null(start)) {
      if (any(x <= 0))
        stop("Weibull values must be > 0")
      lx <- log(x)
      m <- mean(lx)
      v <- var(lx)
      shape <- 1.2/sqrt(v)
      scale <- exp(m + 0.572/shape)
      start <- list(shape = shape, scale = scale)
      start <- start[!is.element(names(start), dots)]
    }
    if (distname == "gamma" && is.null(start)) {
      if (any(x < 0))
        stop("gamma values must be >= 0")
      m <- mean(x)
      v <- var(x)
      start <- list(shape = m^2/v, rate = m/v)
      start <- start[!is.element(names(start), dots)]
      control <- list(parscale = c(1, start$rate))
    }
    if (distname == "negative binomial" && is.null(start)) {
      m <- mean(x)
      v <- var(x)
      size <- if (v > m)
        m^2/(v - m)
      else 100
      start <- list(size = size, mu = m)
      start <- start[!is.element(names(start), dots)]
    }
    if (is.element(distname, c("cauchy", "logistic")) &&
        is.null(start)) {
      start <- list(location = median(x), scale = IQR(x)/2)
      start <- start[!is.element(names(start), dots)]
    }
    if (distname == "t" && is.null(start)) {
      start <- list(m = median(x), s = IQR(x)/2, df = 10)
      start <- start[!is.element(names(start), dots)]
    }
  }
  if (is.null(start) || !is.list(start))
    stop("")
  nm <- names(start)
  f <- formals(densfun)
  args <- names(f)
  m <- match(nm, args)
  if (any(is.na(m)))
    stop("'start' specifies names which are not arguments to 'densfun'")
  formals(densfun) <- c(f[c(1, m)], f[-c(1, m)])
  dens <- function(parm, x, ...) densfun(x, parm, ...)
  if ((l <- length(nm)) > 1L)
    body(dens) <- parse(text = paste("densfun(x,", paste("parm[",1L:l, "]", collapse = ", "), ", ...)"))
  Call[[1L]] <- quote(stats::optim)
  Call$densfun <- Call$start <- NULL
  Call$x <- x
  Call$par <- start
  Call$fn <- if ("log" %in% args)
    mylogfn
  else myfn
  Call$hessian <- TRUE
  if (length(control))
    Call$control <- control
  if (is.null(Call$method)) {
    if (any(c("lower", "upper") %in% names(Call)))
      Call$method <- "L-BFGS-B"
    else if (length(start) > 1L)
      Call$method <- "BFGS"
    else Call$method <- "Nelder-Mead"
  }
  res <- eval.parent(Call)
  if (res$convergence > 0L)
    stop("optimization failed")
  vc <- solve(res$hessian)
  sds <- sqrt(diag(vc))
  structure(list(estimate = res$par, sd = sds, vcov = vc,
                 loglik = -res$value, n = n), class = "FitDistr")
}
#### necesito .lfkp####################
.lfkp = function(wholeList, filterList) {
  if (!is.list(wholeList))
    stop(paste(deparse(substitute(wholeList)), "is not a list!"))
  if (length(wholeList) == 0)
    return(wholeList)
  if (!is.list(filterList))
    stop(paste(deparse(substitute(filterList)), "is not a list!"))
  if (length(filterList) == 0)
    return(filterList)
  logVec = lapply(names(wholeList), "%in%", names(filterList))
  filteredList = wholeList[unlist(logVec)]
  return(filteredList)
}
#### Funcion normalPlot#####################
normalPlot <- function(fdo, threeWay = FALSE, na.last = NA, alpha = 0.05, response = NULL, sig.col = c("red1", "red2", "red3"), sig.pch = c(1,2,3), main, ylim, xlim, xlab, ylab, pch,  ###
                       col, border = "red", ...){
  fdoName = deparse(substitute(fdo))
  if(is.null(response)==FALSE)
  {
    temp=fdo$.response()[response]
    fdo$.response(temp)
  }
  parList = list()
  parList = list(...)
  if (length(sig.col) < 3)
    sig.col = as.vector(matrix(sig.col, nrow = 1, ncol = 3))
  XLIM=FALSE;YLIM=FALSE
  if (!(class(fdo)[1] == "facDesign"))
    stop(paste(deparse(substitute(fdo)), "is not an object of class facDesign"))
  mainmiss = FALSE
  if (missing(main))
    mainmiss = TRUE
  if (missing(ylim))
    YLIM=TRUE
  if (missing(xlim))
    XLIM=TRUE
  if (missing(xlab))
    xlab = "Coefficients"
  if (missing(ylab))
    ylab = "Theoretical Quantiles"
  if (missing(pch))
    pch = 19
  if (missing(col))
    col = "black"

  list_plot = list()
  for(j in 1:ncol(fdo$.response())){
    parList = list(...)
    params = list()
    leg.col = vector()
    p.col = vector()
    p.pch = vector()
    leg.txt = vector()
    main = paste("Normal plot for", names(fdo$.response())[j], "in", fdoName)
    if (j > 1)
      dev.new()
    form = paste("fdo$.response()[,", j, "]~")

    for (i in 1:ncol(fdo$cube)) {
      form = paste(form, names(fdo$cube)[i], sep = "")
      if (i < ncol(fdo$cube))
        form = paste(form, "*", sep = "")
    }

    lm.1 = lm(as.formula(form), data = fdo$as.data.frame())
    lm.1s = summary(lm.1)
    effect = coef(lm.1s)[row.names(coef(lm.1s)) != "(Intercept)", "t value"]
    print(effect)
    if (all(is.na(effect)))
      effect = 2 * coef(lm.1)[-pmatch("(Intercept)", names(coef(lm.1)))]
    #            stop("effects could not be calculated")
    sig = summary(lm.1)$coefficients[, "Pr(>|t|)"][-pmatch("(Intercept)", names(coef(lm.1)))]
    df.resid = df.residual(lm.1)
    nc = nrow(fdo$centerCube)

    tQ = ppoints(effect)
    index = order(effect)
    sQ = effect[index]
    sig = sig[index]

    if (df.resid > 0) {
      # obtenemos el caracter de la cajita del p_value
      for (k in seq(along = sig)) {
        setted = FALSE
        if (abs(sig)[k] < 0.01) {
          if (!setted) {
            p.col[k] = sig.col[1]
            p.pch[k] = sig.pch[1]
            leg.txt = c(leg.txt, "p < 0.01")
            leg.col = c(leg.col, p.col)
            setted = TRUE
          }
        }
        if (abs(sig)[k] < 0.05) {
          if (!setted) {
            p.col[k] = sig.col[2]
            p.pch[k] = sig.pch[2]
            leg.txt = c(leg.txt, "p < 0.05")
            leg.col = c(leg.col, p.col)
            setted = TRUE
          }
        }
        if (abs(sig)[k] < 0.1) {
          if (!setted) {
            p.col[k] = sig.col[3]
            p.pch[k] = sig.pch[3]
            leg.txt = c(leg.txt, "p < 0.1")
            leg.col = c(leg.col, p.col)
            setted = TRUE
          }
        }
        if (abs(sig)[k] >= 0.1) {
          if (!setted) {
            p.col[k] = col
            p.pch[k] = pch
            leg.txt = c(leg.txt, "p >= 0.1")
            leg.col = c(leg.col, p.col)
            setted = TRUE
          }
        }
      }
      leg.txt = unique(leg.txt)
      leg.col = unique(leg.col)
    }else{p.col=col
    p.pch=pch}

    mid = round(length(tQ)/2)
    last = length(tQ)
    params$p = ppoints(effect)
    estimates = FitDistr(effect, "normal")   #estimates = MASS::fitdistr(effect, "normal")
    params$mean = estimates$estimate[["mean"]]
    params$sd = estimates$estimate[["sd"]]

    y = do.call(qnorm, params)

    if (XLIM)
      xlim = range(sQ)
    if (YLIM)
      ylim = range(y)

    # PLOT -----------------------
    df <- data.frame(sQ = names(sQ), value = as.numeric(sQ), y = y)

    p <- ggplot(df, aes(x = value, y = y, label = sQ)) +
      geom_point(col = p.col, pch = p.pch) +
      theme_classic() + lims(x = xlim, y = ylim) +
      labs(x = xlab, y = ylab, title = main) +
      geom_text(check_overlap = TRUE, vjust = 1) + theme_minimal() +
      theme(plot.title = element_text(hjust = 0.5))

    xp = c(qnorm(0.1), qnorm(0.99))
    yp = c(qnorm(0.1, mean = estimates$estimate[["mean"]], sd = estimates$estimate[["sd"]]), qnorm(0.99, mean = estimates$estimate[["mean"]], sd = estimates$estimate[["sd"]]))
    slope = (yp[2] - yp[1])/(xp[2] - xp[1])
    int = yp[1] - slope * xp[1]

    # line
    p <- p + geom_abline(intercept = int, slope = slope, col = border)

    # legend
    if (df.resid > 0){
      caja <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
        theme_bw() +
        theme(
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          axis.title = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()
        ) +
        xlim(c(0.25,0.30)) + ylim(c(0.24, 0.31))

      caja <- caja +
        annotate('text', x = 0.275, y = 0.28,
                 label = leg.txt, size = 3, hjust = 0.5, colour = leg.col)

      p <- p + inset_element(caja, left = 0.01, right = 0.2, top = 1, bottom = 0.85)
    }
    show(p)
    list_plot[[paste0("p",j)]] <- p
  }
  invisible(list(effect = effect, plots = list_plot))
}
```

```{r}
#### Uso normalPlot#################
normalPlot(dfac)
```

```{r, echo=FALSE}
#### necesito clase desirability.c#################
desirability.c <- R6Class("desirability", public = list(response = NULL,
                                                      low = NULL,
                                                      high = NULL,
                                                      target = NULL,
                                                      scale = NULL,
                                                      importance = NULL,
                                                      initialize = function(response=NULL, low=NULL, high=NULL, target=NULL, scale=NULL, importance=NULL) {
                                                        self$response <- response
                                                        self$low <- low
                                                        self$high <- high
                                                        self$target <- target
                                                        self$scale <- scale
                                                        self$importance <- importance
                                                      },
                                                      show = function(){
                                                        if (!is.numeric(self$target))
                                                          cat("Target is to", paste(self$target, "imize", sep = ""), self$response, "\n")
                                                        else cat("Target is ", self$target, " for", self$response, "\n")
                                                        cat("lower Bound: ", self$low, "\n")
                                                        cat("higher Bound: ", self$high, "\n")
                                                        if (is.numeric(self$target))
                                                          cat("Scale factor is: low =", self$scale[1], "and high =", self$scale[2], "\n")
                                                        else if (identical("min", self$target) | identical("max", self$target))
                                                          cat("Scale factor is: ", self$scale, "\n")
                                                        cat("importance: ", self$importance, "\n")
                                                        cat("\n")
                                                      },
                                                      plot = function(y, scale, main, xlab, ylab, type, col, numPoints = 500, ...){
                                                        xm1 = NULL
                                                        xm2 = NULL
                                                        ym = NULL
                                                        y = NULL
                                                        if (missing(main))
                                                          main = paste("Desirability function for", self$response)
                                                        if (missing(xlab))
                                                          xlab = self$response
                                                        if (missing(ylab))
                                                          ylab = "Desirability"
                                                        if (missing(type))
                                                          type = "l"
                                                        if (missing(scale))
                                                          scale = self$scale
                                                        if (missing(col))
                                                          col = 1:length(scale)
                                                        dFun = .desireFun(self$low, self$high, self$target, self$scale, self$importance)
                                                        xVals = seq(self$low - 0.04 * diff(range(self$low, self$high)), self$high + 0.04 * diff(range(self$low, self$high)), length = numPoints)
                                                        yVals = dFun(xVals)
                                                        plot(xVals, yVals, main = main, xlab = xlab, ylab = ylab, type = type, col = col, ...)
                                                        if (is.numeric(self$target)) {
                                                          xm1 = mean(c(par("usr")[1], self$target))
                                                          xm2 = mean(c(par("usr")[2], self$target))
                                                          ym1 = yVals[max((1:numPoints)[xVals <= xm1])]
                                                          ym2 = yVals[max((1:numPoints)[xVals <= xm2])]
                                                          text(xm1 + 0.025 * diff(range(par("usr")[1:2])), ym1, paste("scale =", scale[1]), adj = c(0, 0))
                                                          text(xm2 - 0.025 * diff(range(par("usr")[1:2])), ym2, paste("scale =", scale[2]), adj = c(1, 1))
                                                        }
                                                        else {
                                                          xm1 = mean(par("usr")[c(1, 2)])
                                                          ym1 = yVals[max((1:numPoints)[xVals <= xm1])]
                                                          if (identical(self$target, "max"))
                                                            text(xm1 + 0.025 * diff(range(par("usr")[1:2])), ym1 - 0.025 * diff(range(par("usr")[3:4])), paste("scale =", scale[1]), adj = c(0, 0))
                                                          else text(xm1 + 0.025 * diff(range(par("usr")[1:2])), ym1 + 0.025 * diff(range(par("usr")[3:4])), paste("scale =", scale[1]), adj = c(0, 1))
                                                        }
                                                        out = list(x = xVals, y = yVals)
                                                        names(out) = c(self$response, "desirability")
                                                        invisible(out)
                                                      }



                                                      )
                       )

#### necesito .desireFun###############
.desireFun = function(low, high, target = "max", scale = c(1, 1), importance = 1) {
  DB = FALSE
  if (importance > 10 | importance < 0.1)
    stop("importance needs to be in [0.1, 10]")
  if (low >= high)
    stop("the lower bound must be greater than the high bound!")
  if (any(scale <= 0))
    stop("the scale parameter must be greater than zero!")
  if (is.numeric(target)) {
    out = function(y) {
      if (DB)
        print("target")
      flush.console()
      d = rep(0, length(y))
      d[y >= low & y <= target] = ((y[y >= low & y <= target] - low)/(target - low))^scale[1]
      d[y >= target & y <= high] = ((y[y >= target & y <= high] - high)/(target - high))^scale[2]
      return(d^importance)
    }
    return(out)
  }
  if (identical(tolower(target), "min")) {
    out = function(y) {
      if (DB)
        print("min")
      d = rep(0, length(y))
      d[y > high] = 0
      d[y < low] = 1
      d[y >= low & y <= high] = ((y[y >= low & y <= high] - high)/(low - high))^scale[1]
      return(d^importance)
    }
    return(out)
  }
  if (identical(tolower(target), "max")) {
    out = function(y) {
      if (DB)
        print("max")
      d = rep(0, length(y))
      d[y < low] = 0
      d[y > high] = 1
      d[y >= low & y <= high] = ((y[y >= low & y <= high] - low)/(high - low))^scale[1]
      return(d^importance)
    }
    return(out)
  }
}


#### Funcion wirePlot###################
wirePlot <- function(x, y, z, data = NULL, xlim, ylim, zlim, main, xlab, ylab, border, sub, zlab, form = "fit", phi, theta, ticktype, col = 1, steps,
                     factors, fun, plot) {
  form = form
  fact = NULL
  if (missing(steps))
    steps = 25
  fdo = data
  fit = NULL
  lm.1 = NULL
  if (!is.function(col)) {
    if (identical(col, 1))
      col = colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
    if (identical(col, 2))
      col = colorRampPalette(c("blue", "white", "red"), space = "Lab")
    if (identical(col, 3))
      col = colorRampPalette(c("blue", "white", "orange"))
    if (identical(col, 4))
      col = colorRampPalette(c("gold", "white", "firebrick"))
  }
  if (is.null(data)) {
    cat("\n defaulting to persp function\n")
    return("persp")
  }
  if (class(data)[1] != "facDesign") {
    cat("\n defaulting to persp function using formula\n")
    return("persp")
  }

  x.c = deparse(substitute(x))
  y.c = deparse(substitute(y))
  z.c = deparse(substitute(z))

  if (missing(plot))
    plot = TRUE
  if (missing(main))
    main = paste("Response Surface for", z.c)

  aux <- list()
  for (i in 1:length(fdo$names())) {
    aux[[.NAMES[i]]] <-fdo$names()[i]
  }
  if (missing(ylab))
    ylab = paste(y.c, ": ", aux[[y.c]])
  if (missing(xlab))
    xlab = paste(x.c, ": ", aux[[x.c]])
  if (missing(zlab))
    zlab = paste(x.c, ": ", z.c)

  if (missing(ticktype))
    ticktype = "detailed"
  if (missing(border))
    border = NULL
  if (missing(phi))
    phi = 30
  if (missing(theta))
    theta = -30
  if (missing(factors))
    factors = NULL
  if (missing(xlim))
    xlim = c(min(fdo$get(, x.c)), max(fdo$get(, x.c)))
  if (missing(ylim))
    ylim = c(min(fdo$get(, y.c)), max(fdo$get(, y.c)))


  allVars = c(fdo$names(), names(fdo$.response()))
  isct = intersect(c(aux[[x.c]], aux[[y.c]], z.c), c(fdo$names(), names(fdo$.response())))

  if (length(isct) < length(c(x.c, y.c, z.c))) {
    d = setdiff(isct, allVars)
    stop(paste(d, "could not be found\n"))
  }

  if (missing(fun))
    fun = NULL
  if (!is.function(fun) & !is.null(fun))
    if (!(fun %in% c("overall", "desirability")))
      stop("fun should be a function, \"overall\" or \"desirability\"")
  if (identical(fun, "desirability")) {
    obj = fdo$desires()[[z.c]]
    fun = .desireFun(obj$low, obj$high, obj$target, obj$scale, obj$importance)
  }

  if (form %in% c("fit")) {
    lm.1 = fdo$fits[[z.c]]
    if (is.null(fit))
      form = "full"
  }

  if (form %in% c("quadratic", "full", "interaction", "linear")) {
    if (identical(form, "full")) {
      form = paste(z.c, "~", x.c, "+", y.c, "+", x.c, ":", y.c)
      if (nrow(fdo$star) > 0)
        form = paste(form, "+ I(", x.c, "^2) + I(", y.c, "^2)")
    }
    if (identical(form, "interaction")) {
      form = paste(z.c, "~", x.c, "+", y.c, "+", x.c, ":", y.c)
    }
    if (identical(form, "linear")) {
      form = paste(z.c, "~", x.c, "+", y.c)
    }
    if (identical(form, "quadratic")) {
      form = paste(z.c, "~I(", x.c, "^2) + I(", y.c, "^2)")
    }
  }

  if (is.null(form))
    stop(paste("invalid formula", form))
  if (is.null(lm.1))
    lm.1 = fdo$lm(form)
  if (missing(sub))
    sub = deparse(formula(lm.1))

  dcList = vector(mode = "list", length = length(fdo$names()))
  names(dcList) = names(aux)
  dcList[1:length(fdo$names())] = 0

  if (!is.null(factors)) {
    for (i in names(factors)) dcList[[i]] = factors[[i]][1]
  }

  help.predict = function(x, y, x.c, y.c, lm.1, ...) {
    dcList[[x.c]] = x
    dcList[[y.c]] = y
    temp = do.call(data.frame, dcList)
    invisible(predict(lm.1, temp))
  }

  xVec = seq(min(xlim), max(xlim), length = steps)
  yVec = seq(min(ylim), max(ylim), length = steps)

  mat = outer(xVec, yVec, help.predict, x.c, y.c, lm.1)

  if (is.function(fun))
    mat = try(apply(mat, c(1, 2), fun))
  if (identical(fun, "overall")) {
    main = "composed desirability"
    mat = matrix(1, nrow = nrow(mat), ncol = ncol(mat))
    for (i in names(fdo$.response())) {
      obj = fdo$desires()[[i]]
      fun = .desireFun(obj$low, obj$high, obj$target, obj$scale, obj$importance)
      temp = outer(xVec, yVec, help.predict, x.c, y.c, fits(fdo)[[i]])
      temp = try(apply(temp, c(1, 2), fun))
      mat = mat * temp
    }
    mat = mat^(1/length(names(fdo$response())))
  }

  if (is.function(col)) {
    nrMat <- nrow(mat)
    ncMat <- ncol(mat)
    jet.colors <- colorRampPalette(c("blue", "green"))
    nbcol <- 100
    color <- col(nbcol)
    matFacet <- mat[-1, -1] + mat[-1, -ncMat] + mat[-nrMat, -1] + mat[-nrMat, -ncMat]
    facetcol <- cut(matFacet, nbcol)
  }else {
    color = col
    facetcol = 1
  }

  if (plot) {
    if (missing(zlim))
      zlim = range(mat)

    p <- plot_ly(x = xVec, y = yVec, z = mat, colors = color) %>%
      add_surface() %>%
      layout(
        title = main,
        annotations = list(
          list(
            text = sub,# Subtitulo
            x = 0.5,   # Posición x en la mitad de la gráfica
            y = -0.1,  # Posición y debajo de la gráfica
            showarrow = FALSE,
            font = list(size = 12)
          )
        ),
        scene = list(
          xaxis = list(range = xlim, title = xlab, zeroline = FALSE),
          yaxis = list(range = ylim, title = ylab, zeroline = FALSE),
          zaxis = list(range = zlim, title = zlab, zeroline = FALSE),
          camera = list(eye = list(x=2, y=2, z=0.1))
        )
      )
    show(p)
  }
  invisible(list(x = xVec, y = yVec, z = mat, plot = p))
}

```

```{r}
#### Uso wirePlot ###############################
wirePlot(A,B,rend,data=dfac)
```


```{r, echo=FALSE}
### Funcion contourPlot#####################
contourPlot = function(x, y, z, data = NULL, xlim, ylim, main, xlab, ylab, border, sub, zlab, form = "fit", phi, theta, ticktype, col = 1, steps,
                       factors, fun, plot) {
  form = form
  fact = NULL
  if (missing(steps))
    steps = 25
  fdo = data
  fit = NULL
  lm.1 = NULL
  if (!is.function(col)) {
    if (identical(col, 1))
      col = colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
    if (identical(col, 2))
      col = colorRampPalette(c("blue", "white", "red"), space = "Lab")
    if (identical(col, 3))
      col = colorRampPalette(c("blue", "white", "orange"))
    if (identical(col, 4))
      col = colorRampPalette(c("gold", "white", "firebrick"))
    if (identical(col, 5))
      col = colorRampPalette(c("blue4", "lightblue1", "lightgreen", "green4"))
  }

  if (is.null(data)) {
    cat("\n defaulting to filled.contour function\n")
    return("persp")
  }
  if (class(data)[1] != "facDesign") {
    cat("\n defaulting to filled.contour function using formula\n")
    return("persp")
  }

  x.c = deparse(substitute(x))
  y.c = deparse(substitute(y))
  z.c = deparse(substitute(z))

  aux <- list()
  for (i in 1:length(fdo$names())) {
    aux[[.NAMES[i]]] <-fdo$names()[i]
  }
  if (missing(plot))
    plot = TRUE
  if (missing(main))
    main = paste("Filled Contour for", z.c)
  if (missing(ylab))
    ylab = paste(y.c, ": ", aux[[y.c]])
  if (missing(xlab))
    xlab = paste(x.c, ": ", aux[[x.c]])
  if (missing(factors))
    factors = NULL
  if (missing(xlim))
    xlim = c(min(fdo$get(, x.c)), max(fdo$get(, x.c)))
  if (missing(ylim))
    ylim = c(min(fdo$get(, y.c)), max(fdo$get(, y.c)))
  allVars = c(fdo$names(), names(fdo$.response()))
  isct = intersect(c(aux[[x.c]], aux[[y.c]], z.c), c(fdo$names(), names(fdo$.response())))

  if (length(isct) < length(c(x.c, y.c, z.c))) {
    d = setdiff(isct, allVars)
    stop(paste(d, "could not be found\n"))
  }
  if (missing(fun))
    fun = NULL
  if (!is.function(fun) & !is.null(fun))
    if (!(fun %in% c("overall", "desirability")))
      stop("fun should be a function, \"overall\" or \"desirability\"")
  if (identical(fun, "desirability")) {
    obj = fdo$desires()[[z.c]]
    fun = .desireFun(obj$low, obj$high, obj$target, obj$scale, obj$importance)
  }
  if (form %in% c("fit")) {
    lm.1 = fdo$fits[[z.c]]
    if (is.null(fit))
      form = "full"
  }
  if (form %in% c("quadratic", "full", "interaction", "linear")) {
    if (identical(form, "interaction")) {
      form = paste(z.c, "~", x.c, "+", y.c, "+", x.c, ":", y.c)
    }
    if (identical(form, "linear")) {
      form = paste(z.c, "~", x.c, "+", y.c)
    }
    if (identical(form, "quadratic")) {
      form = paste(z.c, "~I(", x.c, "^2) + I(", y.c, "^2)")
    }
    if (identical(form, "full")) {
      form = paste(z.c, "~", x.c, "+", y.c, "+", x.c, ":", y.c)
      if (nrow(fdo$star) > 0)
        form = paste(form, "+ I(", x.c, "^2) + I(", y.c, "^2)")
    }
  }

  if (is.null(form))
    stop(paste("invalid formula", form))
  if (is.null(lm.1))
    lm.1 = fdo$lm(form)

  dcList = vector(mode = "list", length = length(fdo$names()))
  names(dcList) = names(aux)
  dcList[1:length(fdo$names())] = 0

  if (!is.null(factors)) {
    for (i in fdo$names()) dcList[[i]] = factors[[i]][1]
  }

  help.predict = function(x, y, x.c, y.c, lm.1, ...) {
    dcList[[x.c]] = x
    dcList[[y.c]] = y
    temp = do.call(data.frame, dcList)
    invisible(predict(lm.1, temp))
  }

  xVec = seq(min(xlim), max(xlim), length = steps)
  yVec = seq(min(ylim), max(ylim), length = steps)
  mat = outer(xVec, yVec, help.predict, x.c, y.c, lm.1)

  if (is.function(col)) {
    nrMat <- nrow(mat)
    ncMat <- ncol(mat)
    nbcol <- 1000
    color <- col(nbcol)
    matFacet <- mat[-1, -1] + mat[-1, -ncMat] + mat[-nrMat, -1] + mat[-nrMat, -ncMat]
    facetcol <- cut(matFacet, nbcol)
  }
  else {
    color = col
    facetcol = 1
  }
  if (is.function(fun))
    mat = try(apply(mat, c(1, 2), fun))
  if (identical(fun, "overall")) {
    main = "composed desirability"
    mat = matrix(1, nrow = nrow(mat), ncol = ncol(mat))
    for (i in names(response(fdo))) {
      obj = fdo$desires()[[i]]
      fun = .desireFun(obj$low, obj$high, obj$target, obj$scale, obj$importance)
      temp = outer(xVec, yVec, help.predict, x.c, y.c, fdo$fits[[i]])
      temp = try(apply(temp, c(1, 2), fun))
      mat = mat * temp
    }
    mat = mat^(1/length(names(fdo$.response())))
  }

  if (plot) {
    p <- plot_ly(x = xVec, y = yVec, z = mat, colors = color, type = "contour", contours = list(coloring = 'heatmap')) %>%
      layout(
        title = main,
        xaxis = list(range = xlim, title = xlab, zeroline = FALSE),
        yaxis = list(range = ylim, title = ylab, zeroline = FALSE)
      )
    show(p)
  }

  invisible(list(x = xVec, y = yVec, z = mat, plot = p))
}
```


```{r, echo=FALSE}
### Uso contourPlot ########################
contourPlot(A,B,rend,data=dfac)
```


### Diseños factoriales fraccionarios $2^{k-p}$

### Diseños replicados y puntos centrales

### Respuestas múltiples

### Pasar a un entorno de proceso con un mayor rendimiento esperado

### Diseño de superficies de respuesta

### Deseabilidades

### Utilización de deseabilidades junto con experimentos diseñados

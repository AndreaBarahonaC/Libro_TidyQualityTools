# Cambio de Funciones

```{css, echo=FALSE}
.scroll-100 {
  max-height: 100px;
  overflow-y: auto;
  background-color: inherit;
}
```


```{r, warning=FALSE, message=FALSE, collapse=TRUE, echo=FALSE}
# install.packages("ggplot2")
# install.packages("patchwork")
# install.packages("gridExtra")
library(R6)
library(tidyverse)
library(ggplot2)
library(patchwork)
library(gridExtra)
```


## Fase 1: Definir

### 1. Función Pareto

```{r, class.output="scroll-100", echo=FALSE}
# Nueva Función (se quita argumento `las`)
ParetoChart_ <- function (x, weight, showTable = TRUE, showPlot = TRUE, main, col, border, xlab, ylab = "Frequency", percentVec, ...)
{
  varName = deparse(substitute(x))[1]
  corp.col = "#C4B9FF"
  corp.border = "#9E0138"
  if (!is.vector(x) & !is.data.frame(x) & !is.table(x))
    stop("x should be a vector, dataframe or a table")
  if (is.table(x)) {
    xtable = x
  }
  if (is.vector(x)) {
    if (!is.null(names(x)))
      xtable = as.table(x)
    else xtable = table(x)
  }
  if (!missing(weight)) {
    if (!is.numeric(weight))
      stop("weight must be numeric!")
    if (is.null(names(weight)))
      stop("weight is missing names for matching!")
    else {
      if (FALSE %in% (sort(names(weight)) == sort(names(xtable))))
        stop("names of weight and table do not match!")
      else {
        for (i in 1:length(xtable)) {
          xtable[i] = weight[names(weight) == names(xtable)[i]] *
            xtable[i]
        }
      }
    }
  }
  else {
    weight = FALSE
  }
  if (missing(showTable))
    showTable = TRUE
  if (missing(xlab))
    xlab = ""
  if (missing(main))
    main = paste("Pareto Chart for", varName)
  if (missing(col))
    col = corp.col
  if (missing(border))
    border = corp.border
  if (missing(percentVec))
    percentVec = seq(0, 1, by = 0.25)
  call <- match.call(expand.dots = TRUE)
  # Plot
  if (length(xtable) > 1) {
    ylim = c(min(xtable), max(xtable) * 1.025)
    xtable = c(sort(xtable, decreasing = TRUE, na.last = TRUE))
    cumFreq = cumsum(xtable)
    sumFreq = sum(xtable)
    percentage = xtable/sum(xtable) * 100
    cumPerc = cumFreq/sumFreq * 100
    
    
    data <- data.frame(Frequency = xtable,
                       Cum.Frequency = cumFreq,
                       Percentage = round(percentage, digits = 2),
                       Cum.Percentage = round(cumPerc, digits = 2))
    tabla <- t(data)
    
    p <- ggplot(data, aes(x = reorder(names(xtable), -xtable), y = Frequency)) +
      geom_col(aes(fill = "Frequency"), width = 0.7) +
      geom_point(aes(y = Cum.Frequency, color = "Cumulative Percentage"), size = 3) +
      geom_line(aes(y = Cum.Frequency, group = 1, color = "Cumulative Percentage")) +
      scale_y_continuous(name = ylab,
                         sec.axis = sec_axis(~ . / sum(xtable),
                                             name = "Cumulative Percentage",
                                             labels = percentVec)) +
      scale_x_discrete(name = xlab) +
      scale_color_manual(values = c(border, border)) +
      scale_fill_manual(values = col) +
      theme(legend.position = "none") +
      labs(title = main)+
      theme_minimal() +
      theme(plot.title = element_text(hjust = 0.5,face = "bold"))
  }
  else {
    warning("data should have at least two categories!")
  }
  if(showPlot == TRUE){
    if(showTable == TRUE){
      show(p/tableGrob(tabla))
    }
    else {
      show(p)
    }
  }
  else{
    show(tabla)
  }
}
```

* Resultados antes:

```{r}
defectos <-c(rep("E",62),rep("B",15),rep("F",3),rep("A",10),rep("C",20),rep("D",10))

qualityTools::paretoChart(defectos)
```

* Resultados ahora:

```{r}
ParetoChart_(defectos)
```

Podemos utilizar parámetros para mostrar la tabla o la gráfica:

```{r}
# Mostrar solo la gráfica
ParetoChart_(defectos, showTable = FALSE)

# Mostrar solo la tabla
ParetoChart_(defectos, showPlot = FALSE)
```

Podemos cambiar los colores de los puntos y las barras:

```{r}
ParetoChart_(defectos, col='blue', border='green')
```

## Fase 2: Medir

### 1. Función cg 

Para poder implementar esta función, primero debemos modificar 3 funciones que se utilizan en esta función macro.

Además utilizaremos los siguientes datos de pruebas:

```{r}
x <- c(9.991, 10.013, 10.001, 10.007, 10.010, 10.013, 10.008, 10.017, 10.005, 10.005, 10.002, 10.017, 10.005, 10.002, 9.996, 10.011, 10.009, 10.006, 10.008, 10.003, 10.002, 10.006, 10.010, 9.992, 10.013)

target = 10.003
tolerance = c(9.903, 10.103)
ref.interval = pnorm(3) - pnorm(-3)
facCg = 0.2
facCgk = 0.1 
n = 0.2
type = "b"
col = "black"
pch = 19
#xlim = NULL
#ylim = NULL
conf.level = 0.95
cex.val = 1.5
```

```{r}
sd = sd(x)
mean = mean(x)
ref.ar = qnorm(ref.interval, mean, sd) - qnorm(1 - ref.interval,mean, sd)
quant1 = qnorm((1 - ref.interval)/2, mean, sd)
quant2 = qnorm(ref.interval + (1 - ref.interval)/2, mean,sd)
xlim = c(0, length(x))
ylim = c(min(x, target - n/2 * (abs(diff(tolerance))), quant1, quant2),
         max(x, target + n/2 * (abs(diff(tolerance))), quant1, quant2))
```

#### CgRunChart

```{r, echo=FALSE}
cg_RunChart <- function (x, target, tolerance, ref.interval, facCg, facCgk,
                         n = 0.2, type = "b", col = "black", pch = 19,
                         xlim = NULL, ylim = NULL, main = "Run Chart",
                         conf.level = 0.95, cgOut = TRUE)
{
  if (missing(x)) {
    stop("x must be given as a vector")
  }

  if (missing(target)) {
    target <- mean(x)
    targetmissing <- FALSE
  } else {
    targetmissing <- TRUE
  }

  if (missing(ref.interval)) {
    ref.interval <- qnorm(0.99865) - qnorm(0.00135)
  }

  sd <- sd(x)
  mean <- mean(x)
  ref.ar <- qnorm(ref.interval, mean, sd) - qnorm(1 - ref.interval, mean, sd)

  if (missing(facCg)) {
    facCg <- 0.2
  }

  if (missing(facCgk)) {
    facCgk <- 0.1
  }

  if (missing(tolerance)) {
    width <- ref.ar/facCg
    tolerance <- numeric(2)
    tolerance[1] <- mean - width/2
    tolerance[2] <- mean + width/2
  }

  quant1 <- qnorm((1 - ref.interval)/2, mean, sd)
  quant2 <- qnorm(ref.interval + (1 - ref.interval)/2, mean, sd)

  if (length(tolerance) != 2) {
    stop("tolerance has wrong length")
  }

  if (missing(xlim)) {
    xlim <- c(0, length(x))
  }

  if (missing(ylim)) {
    ylim <- c(min(x, target - n/2 * (abs(diff(tolerance))), quant1, quant2),
              max(x, target + n/2 * (abs(diff(tolerance))), quant1, quant2))
  }

  if (missing(main)) {
    main <- "Run Chart"
  }

  Cg <- (facCg * tolerance[2]-tolerance[1])/ref.interval
  Cgk <- (facCgk * abs(target-mean(x))/(ref.interval/2))

  # Create a data frame for plotting
  df <- data.frame(x = x, y = x)

  # Add target line
  df$y_target <- target

  # Calculate the upper and lower control limits
  df$y_lower <- quant1
  df$y_upper <- quant2
  # Calculate the tolerance limits
  df$y_tolerance_lower <- tolerance[1]
  df$y_tolerance_upper <- tolerance[2]

  # Calculate the mean
  df$y_mean <- mean

  # Calculate the Cg and Cgk values
  df$Cg <- Cg
  df$Cgk <- Cgk

  # Create the ggplot
  # 1. Principal plot and target line
  p <- ggplot(df, aes(x = seq_along(x), y = x)) +
    geom_point(color = col, shape = pch) +
    geom_line(color = col, linetype = "solid") +
    scale_x_continuous(limits = c(xlim[1] - 0.05 * xlim[2], xlim[2]), expand = c(0, 0)) +
    labs(title = main, x = "Index", y = "x") +
    theme_minimal() + theme(plot.title = element_text(hjust = 0.5,face = "bold"))+
    geom_hline(aes(yintercept = target)) # Linea target

  # 2. Red Plot (Lowess)
  p <- p + geom_smooth(method = "loess", color = "red", se = FALSE, span = 1.25, size = 0.25,)

  # 3. Green lines
  p <- p + geom_hline(aes(yintercept = mean), linetype = "dashed", color = "seagreen")+  #center line
    geom_hline(aes(yintercept = quant1), linetype = "dashed", color = "seagreen") + # Bottom line
    geom_hline(aes(yintercept = quant2), linetype = "dashed", color = "seagreen")   # Top line
  # 4. Xtar +- 0.1
  p <- p + geom_hline(yintercept = c(target + n/2 * (abs(diff(tolerance))), target - n/2 * (abs(diff(tolerance)))), color = "#012B78", linetype = "solid") # Agregar líneas
  #Label
  p <- p + scale_y_continuous(limits = ylim, expand = c(0, 0),sec.axis =
                                sec_axis(~ .,breaks = c(target,mean,quant1,quant2,target + n/2 * (abs(diff(tolerance))),
                                                        target - n/2 * (abs(diff(tolerance)))),
                                         labels=c("target",
                                                  expression(bar(x)),
                                                  substitute(x[a * b], list(a = round(((1 - ref.interval)/2) * 100, 3), b = "%")),
                                                  substitute(x[a * b], list(a = round(((ref.interval + (1 - ref.interval)/2)) * 100,3), b = "%")),
                                                  substitute(x[tar] + a, list(a = round(n/2, 4))),
                                                  substitute(x[tar] - a, list(a = round(n/2, 4)))))) +
    theme(axis.text.y.right = element_text(size = 15))

  # Label  Cg and Cgk
  if (cgOut == TRUE) {
    caja <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.border = element_blank()
      ) +
      xlim(c(0.25,0.26)) + ylim(c(0.24, 0.31))

    caja <- caja +
      annotate('text', x = 0.25, y = 0.30,
               label = paste("Cg: ", round(Cg,digits = 6)),
               parse = TRUE, size = 3, hjust = 0) +
      annotate('text', x = 0.25, y = 0.25,
               label = paste("Cgk:", round(Cgk,digits = 6)),
               parse = TRUE, size = 3, hjust = 0)

    p <- p + inset_element(caja, left = 0.7, right = 1, top = 1, bottom = 0.75)
    suppressMessages(show(p))
  }
  else{
    suppressMessages(show(p))
  }
  invisible(list(Cg, Cgk))
}
```

* Resultados antes:

```{r}
qualityTools::cgRunChart(x = x, target = target, tolerance = tolerance, 
           ref.interval = ref.interval, facCg = facCg, facCgk = facCgk, 
           n = n, type = type, col = col, pch = pch, xlim = xlim, 
           ylim = ylim, main = "Run Chart", conf.level = conf.level, cgOut = FALSE)
```

* Resultados Ahora:

```{r}
cg_RunChart(x = x, target = target, tolerance = tolerance, 
                    ref.interval = ref.interval, facCg = facCg, facCgk = facCgk, 
                    n = n, type = type, col = col, pch = pch, xlim = xlim, 
                    ylim = ylim, main = "Run Chart", conf.level = conf.level, cgOut = FALSE)
```

#### cgHist

```{r, echo=FALSE}
# Nueva función
cg_HistChart <- function (x, target, tolerance, ref.interval, facCg, facCgk,
                          n = 0.2, col, xlim, ylim, main, conf.level = 0.95, cgOut = TRUE)
{
  if (missing(x))
    stop("x must be given as a vector")
  if (missing(target)) {
    target = mean(x)
    targetmissing = FALSE
  }
  else targetmissing = TRUE
  if (missing(ref.interval))
    ref.interval = pnorm(3) - pnorm(-3)
  sd = sd(x)
  mean = mean(x)
  ref.ar = qnorm(ref.interval, mean, sd) - qnorm(1 - ref.interval,
                                                 mean, sd)
  if (missing(facCg))
    facCg = 0.2
  if (missing(facCgk))
    facCgk = 0.1
  if (missing(tolerance))
    warning("Missing tolerance! The specification limits are choosen to get Cg = 1")
  if (missing(tolerance)) {
    width = ref.ar/facCg
    tolerance = numeric(2)
    tolerance[1] = mean(x) - width/2
    tolerance[2] = mean(x) + width/2
  }
  quant1 = qnorm((1 - ref.interval)/2, mean, sd)
  quant2 = qnorm(ref.interval + (1 - ref.interval)/2, mean,
                 sd)
  if (length(tolerance) != 2)
    stop("tolerance has wrong length")
  if (missing(col))
    col = "lightblue"
  if (missing(xlim))
    xlim = c(0, length(x))
  if (missing(ylim))
    ylim = c(min(x, target - n/2 * (abs(diff(tolerance))),
                 quant1, quant2), max(x, target + n/2 * (abs(diff(tolerance))),
                                      quant1, quant2))
  if (missing(main))
    main = paste("Histogram of", deparse(substitute(x)),
                 "- target")

  Cg <- (facCg * tolerance[2]-tolerance[1])/ref.interval
  Cgk <- (facCgk * abs(target-mean(x))/(ref.interval/2))

  # Calculos previos
  x.c <- x - target
  temp <- hist(x.c, plot = FALSE)
  # Obtenemos la información para el histograma
  df <- data.frame(
    mid = temp$mids,
    density = temp$density
  )
  width <- diff(df$mid)[1] # Ancho de cada barra
  # Histograma
  p <- ggplot(df, aes(x = mid, y = density)) +
    geom_bar(stat = "identity", width = width, fill = "lightblue", color = "black", alpha = 0.5) +
    labs(y = "Density", x = "x.c", title = main) +
    theme_minimal() + theme(plot.title = element_text(hjust = 0.5,face = "bold"))+
    guides(color = guide_legend(title.position = "top", title.hjust = 0.5))
  # Linea x=0
  p <- p + geom_vline(xintercept = 0, color = "red")
  # Intervalos de Confianza - Azules
  test = t.test(x.c, mu = 0, conf.level = conf.level)
  p <- p + geom_vline(aes(xintercept = test$conf.int[1], color = "Confidence interval"), linetype = "dashed", col = "blue") +
    geom_vline(aes(xintercept = test$conf.int[2], color = "Confidence interval"), linetype = "dashed", col = "blue") +
    theme(legend.position = "none")
  # Curva de densidad
  p <- p + geom_line(data = data.frame(x = density(x.c)$x, y = density(x.c)$y), aes(x = x, y = y), color = "black", linewidth = 0.5)

  # Hipotesis, P_val y t_val
  caja <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
    theme_bw() +
    theme(
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.title = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.background = element_rect(fill = "transparent", color = NA),
      plot.background = element_rect(fill = "transparent", color = NA),
      panel.border = element_blank()
    ) +
    xlim(c(0.25,0.26)) + ylim(c(0.24, 0.36))

  caja <- caja +
    annotate('text', x = 0.25, y = 0.35,
             label = paste("H[0]==", "0"),
             parse = TRUE, size = 3, hjust = 0) +
    annotate('text', x = 0.25, y = 0.30,
             label = paste("t-value: ", round(test$statistic, digits = 3)),
             parse = TRUE, size = 3, hjust = 0) +
    annotate('text', x = 0.25, y = 0.25,
             label = paste("p-value: ", round(test$p.value, 3)),
             parse = TRUE, size = 3, hjust = 0)

  p <- p + inset_element(caja, left = 0, right = 0.35, top = 1, bottom = 0.65)

  # Añadir label del Cg y Cgk
  if (cgOut == TRUE) {
    caja <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.border = element_blank()
      ) +
      xlim(c(0.25,0.26)) + ylim(c(0.24, 0.31))

    caja <- caja +
      annotate('text', x = 0.25, y = 0.30,
               label = paste("Cg: ", round(Cg,digits = 6)),
               parse = TRUE, size = 3, hjust = 0) +
      annotate('text', x = 0.25, y = 0.25,
               label = paste("Cgk:", round(Cgk,digits = 6)),
               parse = TRUE, size = 3, hjust = 0)

    p <- p + inset_element(caja, left = 0.7, right = 1, top = 1, bottom = 0.75)
    show(p)
  }
  else{
    caja <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.border = element_blank()
      ) +
      xlim(c(0.25,0.26)) + ylim(c(0.24, 0.31))

    caja <- caja +
      annotate('text', x = 0.25, y = 0.30,
               label = "----- conf. int", size = 3, hjust = 0, colour = "blue")

    p <- p + inset_element(caja, left = 0.75, right = 1, top = 1, bottom = 0.75)
    show(p)
  }
  invisible(list(Cg, Cgk))
}
```

* Resultados Anteriores:

```{r}
qualityTools::cgHist(x = x, target = target, tolerance = tolerance, ref.interval = ref.interval, 
       facCg = facCg, facCgk = facCgk, n = n, col = "lightblue", 
       xlim = xlim, ylim = ylim, main = paste("Histogram of", 
                                              deparse(substitute(x)), "- target"), conf.level
       = conf.level, cgOut = FALSE)
```

* Resultados Ahora:

```{r}
cg_HistChart(x = x, target = target, tolerance = tolerance, ref.interval = ref.interval, 
            facCg = facCg, facCgk = facCgk, n = n, col = "lightblue", 
            xlim = xlim, ylim = ylim, main = paste("Histogram of", 
                                                   deparse(substitute(x)), "- target"),
            conf.level = conf.level, cgOut = FALSE)
```


#### cgToleranceView

```{r, echo=FALSE}
# Nueva Función
cg_ToleranceChart <- function (x, target, tolerance, ref.interval, facCg, facCgk,
                               n = 0.2, type, col, pch, xlim, ylim, main, conf.level = 0.95,
                               cgOut = TRUE)
{
  if (missing(x))
    stop("x must be given as a vector")
  if (missing(target)) {
    target = mean(x)
    targetmissing = FALSE
  }
  else targetmissing = TRUE
  if (missing(ref.interval))
    ref.interval = pnorm(3) - pnorm(-3)
  sd = sd(x)
  mean = mean(x)
  ref.ar = qnorm(ref.interval, mean, sd) - qnorm(1 - ref.interval,
                                                 mean, sd)
  if (missing(facCg))
    facCg = 0.2
  if (missing(facCgk))
    facCgk = 0.1
  if (missing(tolerance))
    warning("Missing tolerance! The specification limits are choosen to get Cg = 1")
  if (missing(tolerance)) {
    width = ref.ar/facCg
    tolerance = numeric(2)
    tolerance[1] = mean(x) - width/2
    tolerance[2] = mean(x) + width/2
  }
  quant1 = qnorm((1 - ref.interval)/2, mean, sd)
  quant2 = qnorm(ref.interval + (1 - ref.interval)/2, mean,
                 sd)
  if (length(tolerance) != 2)
    stop("tolerance has wrong length")
  if (missing(type))
    type = "b"
  if (missing(col))
    col = 1
  if (missing(pch))
    pch = 19
  if (missing(xlim))
    xlim = c(0, length(x))
  if (missing(ylim))
    ylim = c(min(x, target - n/2 * (abs(diff(tolerance))),
                 quant1, quant2), max(x, target + n/2 * (abs(diff(tolerance))),
                                      quant1, quant2))
  if (missing(main))
    main = "Tolerance View"
  Cg <- (facCg * tolerance[2]-tolerance[1])/ref.interval
  Cgk <- (facCgk * abs(target-mean(x))/(ref.interval/2))

  # Gráfica
  p <- ggplot(data.frame(x = 1:length(x), y = x), aes(x = x, y = y)) +
    geom_point(color = col, shape = pch) +
    geom_line(color = col, linetype = "solid")+
    geom_hline(aes(yintercept = target), linetype = "dashed", color = "red") +
    geom_hline(aes(yintercept = tolerance[1]), linetype = "dashed", color = "blue") +
    geom_hline(aes(yintercept = tolerance[2]), linetype = "dashed", color = "blue") +
    geom_hline(aes(yintercept = (target + n/2 * (tolerance[2] - tolerance[1]))), color = "black") +
    geom_hline(aes(yintercept = (target - n/2 * (tolerance[2] - tolerance[1]))), color = "black") +
    scale_color_manual(values = c("Data" = col)) +
    labs(x = "", y = "x", color = "Variable", title = main)+
    theme_bw()+theme(plot.title = element_text(hjust = 0.5,face = "bold"))+
    theme(legend.position = "none")

  if (cgOut == TRUE) {
    caja <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.border = element_blank()
      ) +
      xlim(c(0.25,0.26)) + ylim(c(0.24, 0.31))

    caja <- caja +
      annotate('text', x = 0.25, y = 0.30,
               label = paste("Cg: ", round(Cg,digits = 6)),
               parse = TRUE, size = 3, hjust = 0) +
      annotate('text', x = 0.25, y = 0.25,
               label = paste("Cgk:", round(Cgk,digits = 6)),
               parse = TRUE, size = 3, hjust = 0)

    p <- p + inset_element(caja, left = 0.7, right = 1, top = 1, bottom = 0.75)
    show(p)
  }
  else{
    show(p)
  }
  invisible(list(Cg, Cgk))
}
```

* Resultados Antes:

```{r}
qualityTools::cgToleranceView(x = x, target = target, tolerance = tolerance, 
                ref.interval = ref.interval, facCg = facCg, facCgk = facCgk, 
                n = n, type = type, col = col, pch = pch, xlim = xlim, 
                ylim = ylim, main = "Tolerance View", conf.level = conf.level, cgOut = TRUE)
```

* Resultados Ahora:

```{r}
cg_ToleranceChart(x = x, target = target, tolerance = tolerance, 
                 ref.interval = ref.interval, facCg = facCg, facCgk = facCgk, 
                 n = n, type = type, col = col, pch = pch, xlim = xlim, 
                 ylim = ylim, main = "Tolerance View", conf.level = conf.level, cgOut = TRUE)
```

#### Funcion cg

Ahora la función `cg` se modificará de la siguiente forma: 

```{r, echo=FALSE}
# Funcion Nueva
cg_ <- function (x, target, tolerance, ref.interval, facCg, facCgk, n = 0.2,
                   type, col, pch, xlim, ylim, conf.level = 0.95, cex.val = 1.5)
{
    old.par <- par(no.readonly = TRUE)
    if (missing(x))
      stop("x must be given as a vector")
    if (missing(target)) {
      target = mean(x)
      targetmissing = FALSE
    }
    else
      targetmissing = TRUE
    if (missing(ref.interval))
      ref.interval = pnorm(3) - pnorm(-3)
    sd = sd(x)
    mean = mean(x)
    ref.ar = qnorm(ref.interval, mean, sd) - qnorm(1 - ref.interval,
                                                   mean, sd)
    if (missing(facCg))
      facCg = 0.2
    if (missing(facCgk))
      facCgk = 0.1
    if (missing(tolerance))
      warning("Missing tolerance! The specification limits are choosen to get Cg = 1")
    if (missing(tolerance)) {
      width = ref.ar / facCg
      tolerance = numeric(2)
      tolerance[1] = mean(x) - width / 2
      tolerance[2] = mean(x) + width / 2
    }
    quant1 = qnorm((1 - ref.interval) / 2, mean, sd)
    quant2 = qnorm(ref.interval + (1 - ref.interval) / 2, mean,
                   sd)
    if (length(tolerance) != 2)
      stop("tolerance has wrong length")
    if (missing(type))
      type = "b"
    if (missing(col))
      col = 1
    if (missing(pch))
      pch = 19
    if (missing(xlim))
      xlim = c(0, length(x))
    if (missing(ylim))
      ylim = c(min(x, target - n / 2 * (abs(diff(
        tolerance
      ))),
      quant1, quant2),
      max(x, target + n / 2 * (abs(diff(
        tolerance
      ))),
      quant1, quant2))
    Cg <- (facCg * tolerance[2] - tolerance[1]) / ref.interval
    Cgk <- (facCgk * abs(target - mean(x)) / (ref.interval / 2))

    # Plots

    # RunChart
    df1 <- data.frame(x = x, y = x)
    df1$y_target <- target
    df1$y_lower <- quant1
    df1$y_upper <- quant2
    df1$y_tolerance_lower <- tolerance[1]
    df1$y_tolerance_upper <- tolerance[2]
    df1$y_mean <- mean
    df1$Cg <- Cg
    df1$Cgk <- Cgk
    p1 <- ggplot(df1, aes(x = seq_along(x), y = x)) +
      geom_point(color = col, shape = pch) +
      geom_line(color = col, linetype = "solid") +
      scale_x_continuous(limits = c(xlim[1] - 0.05 * xlim[2], xlim[2]),
                         expand = c(0, 0)) +
      labs(title = "Run Chart", x = "Index", y = "x") +
      theme_minimal() + theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
      geom_hline(aes(yintercept = target)) +
      geom_smooth(
        method = "loess",
        color = "red",
        se = FALSE,
        span = 1.25,
        size = 0.25
      ) +
      geom_hline(aes(yintercept = mean),
                 linetype = "dashed",
                 color = "seagreen") +  #center line
      geom_hline(aes(yintercept = quant1),
                 linetype = "dashed",
                 color = "seagreen") + # Bottom line
      geom_hline(aes(yintercept = quant2),
                 linetype = "dashed",
                 color = "seagreen") +
      geom_hline(
        yintercept = c(target + n / 2 * (abs(diff(
          tolerance
        ))), target - n / 2 * (abs(diff(
          tolerance
        )))),
        color = "#012B78",
        linetype = "solid"
      ) +
      scale_y_continuous(
        limits = ylim,
        expand = c(0, 0),
        sec.axis =
          sec_axis(
            ~ .,
            breaks = c(
              target,
              mean,
              quant1,
              quant2,
              target + n / 2 * (abs(diff(tolerance))),
              target - n / 2 * (abs(diff(tolerance)))
            ),
            labels = c(
              "target",
              expression(bar(x)),
              substitute(x[a * b], list(a = round(((1 - ref.interval) / 2
              ) * 100, 3), b = "%")),
              substitute(x[a * b], list(a = round(((ref.interval + (1 - ref.interval) /
                                                      2)
              ) * 100,
              3), b = "%")),
              substitute(x[tar] + a, list(a = round(n / 2, 4))),
              substitute(x[tar] - a, list(a = round(n / 2, 4)))
            )
          )
      ) + theme(axis.text.y.right = element_text(size = 15))

    # HistChart
    x.c <- x - target
    temp <- hist(x.c, plot = FALSE)
    df3 <- data.frame(mid = temp$mids,
                      density = temp$density)
    width <- diff(df3$mid)[1] # Ancho de cada barra
    p3 <- ggplot(df3, aes(x = mid, y = density)) +
      geom_bar(
        stat = "identity",
        width = width,
        fill = "lightblue",
        color = "black",
        alpha = 0.5
      ) +
      labs(y = "Density", x = "x.c", title = paste("Histogram of",deparse(substitute(x)),"- target")) +
      theme_minimal() + theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
      guides(color = guide_legend(title.position = "top", title.hjust = 0.5)) +
      geom_vline(xintercept = 0, color = "red")

    test = t.test(x.c, mu = 0, conf.level = conf.level)
    p3 <-
      p3 + geom_vline(
        aes(xintercept = test$conf.int[1], color = "Confidence interval"),
        linetype = "dashed",
        col = "blue"
      ) +
      geom_vline(
        aes(xintercept = test$conf.int[2], color = "Confidence interval"),
        linetype = "dashed",
        col = "blue"
      ) +
      theme(legend.position = "none") +
      geom_line(
        data = data.frame(x = density(x.c)$x, y = density(x.c)$y),
        aes(x = x, y = y),
        color = "black",
        linewidth = 0.5
      )

    p3 <-
      p3 + annotation_custom(grob = grid::textGrob(
        label = c(expression(paste(H[0], " : Bias = 0"))),
        x = unit(0.05, "npc") + unit(0.05, "cm"),
        y = unit(1, "npc") - unit(0.05, "cm"),
        just = c("left", "top"),
        gp = grid::gpar(fontsize = 6, fontface = "bold")
      )) +
      annotation_custom(grob = grid::textGrob(
        label = c(paste("t-value: ", round(test$statistic, 3))),
        x = unit(0.05, "npc") + unit(0.05, "cm"),
        y = unit(1, "npc") - unit(0.4, "cm"),
        just = c("left", "top"),
        gp = grid::gpar(fontsize = 6)
      )) +
      annotation_custom(grob = grid::textGrob(
        label = c(paste("p-value: ", round(test$p.value, 3))),
        x = unit(0.05, "npc") + unit(0.05, "cm"),
        y = unit(1, "npc") - unit(0.65, "cm"),
        just = c("left", "top"),
        gp = grid::gpar(fontsize = 6)
      ))

    # Tolerance View
    p4 <-
      ggplot(data.frame(x = 1:length(x), y = x), aes(x = x, y = y)) +
      geom_point(color = col, shape = pch) +
      geom_line(color = col, linetype = "solid") +
      geom_hline(aes(yintercept = target),
                 linetype = "dashed",
                 color = "red") +
      geom_hline(aes(yintercept = tolerance[1]),
                 linetype = "dashed",
                 color = "blue") +
      geom_hline(aes(yintercept = tolerance[2]),
                 linetype = "dashed",
                 color = "blue") +
      geom_hline(aes(yintercept = (target + n / 2 * (
        tolerance[2] - tolerance[1]
      ))), color = "black") +
      geom_hline(aes(yintercept = (target - n / 2 * (
        tolerance[2] - tolerance[1]
      ))), color = "black") +
      scale_color_manual(values = c("Data" = col)) +
      labs(
        x = "",
        y = "x",
        color = "Variable",
        title = "Tolerance View"
      ) +
      theme_minimal() + theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
      theme(legend.position = "none")

    # Data Box
    p2 <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      annotate(
        'text',
        x = 0.25,
        y = 0.40,
        label = paste("bar(x)==", round(mean, 2)),
        parse = TRUE,
        size = 3,
        hjust = 0
      ) +
      annotate(
        'text',
        x = 0.25,
        y = 0.35,
        label = paste("s==", round(sd, 2)),
        parse = TRUE,
        size = 3,
        hjust = 0
      ) +
      annotate(
        'text',
        x = 0.25,
        y = 0.3,
        label = paste("target==", round(target, 5)),
        parse = TRUE,
        size = 3,
        hjust = 0
      ) +
      annotate(
        'text',
        x = 0.25,
        y = 0.25,
        label = paste("C[g]==", round(Cg, 2)),
        parse = TRUE,
        size = 3,
        hjust = 0
      ) +
      annotate(
        'text',
        x = 0.25,
        y = 0.20,
        label = paste("C[gk]==", round(Cgk, 2)),
        parse = TRUE,
        size = 3,
        hjust = 0
      ) +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
      ) +
      xlim(c(0.15, 0.5)) + ylim(c(0.1, 0.5))

    design <- "
  112
  113
  114
  "
    p <- p1 + p2 + p3 + p4 + plot_layout(design = design)

    suppressMessages(show(p))

    invisible(list(Cg, Cgk))
  }

```

* Resultados Antes:

```{r}
x <- c ( 9.991, 10.013, 10.001, 10.007, 10.010, 10.013, 10.008, 10.017, 10.005, 10.005, 10.002,
         10.017, 10.005, 10.002, 9.996, 10.011, 10.009 , 10.006, 10.008, 10.003, 10.002, 10.006, 
         10.010, 9.992, 10.013)

qualityTools::cg(x, target = 10.003, tolerance = c(9.903, 10.103))
```

* Resultados Ahora:

```{r}
cg_(x, target = 10.003, tolerance = c(9.903, 10.103))
```

## Fase 3: Analizar

#### Capacidad del proceso:

```{r, echo=FALSE}
# -------------- internals.r --------------
.confintbeta= function(xs, thethas, varmatrix, alpha) {
  
  th1= thethas[[1]]
  th2 =  thethas[[2]]
  
  prozent=ppoints(xs)
  
  perzentile=qbeta(prozent, th1, th2)
  
  h=1e-6
  dFdth1=(qbeta(prozent, th1, th2)-qbeta(prozent, th1+h, th2))/h
  dFdth2=(qbeta(prozent, th1, th2)-qbeta(prozent, th1, th2+h))/h
  
  Var = varmatrix[[1, 1]]*dFdth1^2 + 2*varmatrix[[1, 2]]*dFdth1*dFdth2 + varmatrix[[2, 2]]*dFdth2^2
  zalpha=qnorm(1-alpha/2)
  halfwidth = zalpha*sqrt(Var)
  
  lci=perzentile-halfwidth
  uci=perzentile+halfwidth
  
  bounds = list(lci, uci, perzentile)
  
  
  return (bounds)
}
.confintcauchy = function(xs, thethas, varmatrix, alpha) {
  
  th1= thethas[[1]]
  th2 =  thethas[[2]]
  
  prozent=ppoints(xs)
  
  perzentile=qcauchy(prozent, th1, th2)
  
  h=1e-6
  dFdth1=(qcauchy(prozent, th1, th2)-qcauchy(prozent, th1+h, th2))/h
  dFdth2=(qcauchy(prozent, th1, th2)-qcauchy(prozent, th1, th2+h))/h
  
  Var = varmatrix[[1, 1]]*dFdth1^2 + 2*varmatrix[[1, 2]]*dFdth1*dFdth2 + varmatrix[[2, 2]]*dFdth2^2
  zalpha=qnorm(1-alpha/2)
  halfwidth = zalpha*sqrt(Var)
  
  lci=perzentile-halfwidth
  uci=perzentile+halfwidth
  
  bounds = list(lci, uci, perzentile)
  
  return (bounds)
}
.confintexp=function(xs, thethas, varmatrix, alpha) {
  lambda=thethas[[1]]
  prozent=ppoints(xs)
  perzentile=qexp(prozent, lambda)
  logPerzentile = log(perzentile)
  zalpha=qnorm(1-alpha/2)
  halfwidth = zalpha*sqrt(varmatrix[[1, 1]]/lambda^2)
  lci = exp(logPerzentile - halfwidth);
  uci = exp(logPerzentile + halfwidth);
  
  bounds = list(lci, uci, perzentile)
  
  return (bounds)
  
}
.confintgamma= function(xs, thethas, varmatrix, alpha) {
  th1= thethas[[1]]
  th2 =  thethas[[2]]
  prozent=ppoints(xs)
  perzentile=qgamma(prozent, th1, th2)
  
  h=1e-6
  dFdth1=(qgamma(prozent, th1, th2)-qgamma(prozent, th1+h, th2))/h
  dFdth2=(qgamma(prozent, th1, th2)-qgamma(prozent, th1, th2+h))/h
  
  Var = varmatrix[[1, 1]]*dFdth1^2 + 2*varmatrix[[1, 2]]*dFdth1*dFdth2 + varmatrix[[2, 2]]*dFdth2^2
  zalpha=qnorm(1-alpha/2)
  halfwidth = zalpha*sqrt(Var)
  
  lci=perzentile-halfwidth
  uci=perzentile+halfwidth
  
  bounds = list(lci, uci, perzentile)
  
  return (bounds)
}
.confintlnorm=function(xs, thethas, varmatrix, alpha){
  th1= thethas[[1]]
  th2 =  thethas[[2]]
  
  prozent=ppoints(xs)
  
  perzentile=qlnorm(prozent, th1, th2)
  
  zp=qnorm(prozent)
  
  varPerzentile = varmatrix[[1, 1]]+2*varmatrix[[1, 2]]*zp+varmatrix[[2, 2]]*zp*zp
  
  zalpha=qnorm(1-alpha/2)
  lci=log(perzentile)-zalpha*sqrt(varPerzentile)
  uci=log(perzentile)+zalpha*sqrt(varPerzentile)
  
  bounds = list(exp(lci), exp(uci), perzentile)
  
  return (bounds)
  
}
.confintlogis= function(xs, thethas, varmatrix, alpha) {
  
  th1= thethas[[1]]
  th2 =  thethas[[2]]
  
  prozent=ppoints(xs)
  
  
  perzentile=qlogis(prozent, th1, th2)
  
  h=1e-6
  dFdth1=(qlogis(prozent, th1, th2)-qlogis(prozent, th1+h, th2))/h
  dFdth2=(qlogis(prozent, th1, th2)-qlogis(prozent, th1, th2+h))/h
  
  Var = varmatrix[[1, 1]]*dFdth1^2 + 2*varmatrix[[1, 2]]*dFdth1*dFdth2 + varmatrix[[2, 2]]*dFdth2^2
  zalpha=qnorm(1-alpha/2)
  halfwidth = zalpha*sqrt(Var)
  
  lci=perzentile-halfwidth
  uci=perzentile+halfwidth
  
  bounds = list(lci, uci, perzentile)
  
  return (bounds)
}
.confintnorm=function(xs, thethas, varmatrix, alpha){
  
  prozent=ppoints(xs)
  
  zp=qnorm(prozent)
  perzentile=qnorm(prozent, thethas[[1]], thethas[[2]])
  
  varPerzentile = varmatrix[[1, 1]]+2*varmatrix[[1, 2]]*zp+varmatrix[[2, 2]]*zp*zp
  
  zalpha=qnorm(1-alpha/2)
  lci=perzentile-zalpha*sqrt(varPerzentile)
  uci=perzentile+zalpha*sqrt(varPerzentile)
  
  bounds = list(lci, uci, perzentile)
  
  return (bounds)
}
.confintweibull= function(xs, thethas, varmatrix, alpha) {
  th1= thethas[[1]]
  th2 =  thethas[[2]]
  
  prozent=ppoints(xs)
  
  perzentile=qweibull(prozent, th1, th2)
  q=-log(1-prozent)
  logPerzentile=log(perzentile)
  logq=log(q)
  dB=1/th2
  dA=-1/(th1^2)
  
  Var = varmatrix[[1, 1]]*(dA*logq)^2 + 2*varmatrix[[1, 2]]*dB*dA*logq + varmatrix[[2, 2]]*dB^2
  zalpha=qnorm(1-alpha/2)
  halfwidth = zalpha*sqrt(Var)
  
  
  lci=exp(logPerzentile-halfwidth)
  uci=exp(logPerzentile+halfwidth)
  
  bounds = list(lci, uci, perzentile)
  
  # print(data.frame(prozent, uci, perzentile, lci))
  
  return (bounds)
}
.gamma3 = function(data) {
  n=length(data)
  data=sort(data)
  
  pEmp= (seq(1:n)-0.5)/n
  
  weight = 1 / sqrt(pEmp*(1-pEmp))
  
  thld = .99*min(data)
  shape=1
  scale=1
  
  gammaEst = function(param) {
    return( sum(weight*(pgamma(data-param[3], shape = exp(param[1]), scale = exp(param[2]))-pEmp)^2) )
  }
  
  paramEst = optim(c(shape, scale, thld), gammaEst, method = "Nelder-Mead")
  paramEst = paramEst$par
  return(list(shape = exp(paramEst[1]), scale = exp(paramEst[2]), threshold = paramEst[3]))
}
.lognormal3 = function(data) {
  
  n=length(data)
  data=sort(data)
  #compute the empirical cumulative distribution function of the data
  pEmp= (seq(1:n)-0.5)/n
  # will minimize the weighted sum of squared distances
  # so compute weights
  weight = 1 / sqrt(pEmp*(1-pEmp))
  
  # initial values for optimization
  thld = .99*min(data)
  mu0 = mean(log(data-thld))
  sigma0 = sd(log(data-thld))
  
  
  lnEst = function(param) {
    return( sum(weight*(plnorm(data-param[3], meanlog = param[1], sdlog = exp(param[2]))-pEmp)^2) )
  }
  
  logSigma0=log(sigma0)
  # optimize gammaEst using optim function
  paramEst = optim(c(mu0,logSigma0, thld), lnEst, method = "Nelder-Mead")
  param = paramEst$par
  
  return(list(meanlog = param[1], sdlog = exp(param[2]), threshold = param[3]))
}
.weibull3 = function(x){
  if(any(x < 0))
    stop("x must be positive")
  
  n = length(x)
  x = sort(x)
  p = ((1:n)-0.5)/n
  interval = c(0.75*min(x), 0.9999*min(x))
  
  wb3RSquared = function(th)
  {
    return(summary(lm(log(x-th) ~ log(-log(1-p))))$r.squared)
  }
  
  th = (optimize(wb3RSquared, interval = interval, maximum = TRUE))$maximum
  
  lm.1 = lm(log(x-th) ~ log(-log(1-p)))
  estimates = list(shape = 1/coef(lm.1)[[2]], scale = exp(coef(lm.1)[[1]]), threshold = th)
  return(estimates)
}
.charToDistFunc = function(distribution, type = "q") {                                                           
  fun = NULL
  if (identical("beta", distribution))
    fun = eval(parse(text = paste(type, "beta", sep = "")))
  if (identical("cauchy", distribution))
    fun = eval(parse(text = paste(type, "cauchy", sep = "")))
  if (identical("chi-squared", distribution))
    fun = eval(parse(text = paste(type, "chisq", sep = "")))
  if (identical("exponential", distribution))
    fun = eval(parse(text = paste(type, "exp", sep = "")))
  if (identical("f", distribution))
    fun = eval(parse(text = paste(type, "f", sep = "")))
  if (identical("geometric", distribution))
    fun = eval(parse(text = paste(type, "geom", sep = "")))
  if (identical("log-normal", distribution) || identical("lognormal", distribution))         ####
    fun = eval(parse(text = paste(type, "lnorm", sep = "")))
  if (identical("log-normal3", distribution) || identical("lognormal3", distribution))       ####
    fun = eval(parse(text = paste(type, "lnorm3", sep = "")))                              ####
  if (identical("logistic", distribution))
    fun = eval(parse(text = paste(type, "logis", sep = "")))
  if (identical("negative binomial", distribution))
    fun = eval(parse(text = paste(type, "nbinom", sep = "")))
  if (identical("normal", distribution))
    fun = eval(parse(text = paste(type, "norm", sep = "")))
  if (identical("poisson", distribution))
    fun = eval(parse(text = paste(type, "pois", sep = "")))
  if (identical("t", distribution))
    fun = eval(parse(text = paste(type, "t", sep = "")))
  if (identical("weibull", distribution))
    fun = eval(parse(text = paste(type, "weibull", sep = "")))
  if (identical("weibull3", distribution))                                                   ####
    fun = eval(parse(text = paste(type, "weibull3", sep = "")))                            ####
  if (identical("gamma", distribution))
    fun = eval(parse(text = paste(type, "gamma", sep = "")))
  if (identical("gamma3", distribution))
    fun = eval(parse(text = paste(type, "gamma3", sep = "")))
  return(fun)
}
# Funcion FitDistr y .MyADtest----
FitDistr <- function (x, densfun, start, ...){
  myfn <- function(parm, ...) -sum(log(dens(parm, ...)))
  mylogfn <- function(parm, ...) -sum(dens(parm, ..., log = TRUE))
  mydt <- function(x, m, s, df, log) dt((x - m)/s, df, log = TRUE) -
    log(s)
  Call <- match.call(expand.dots = TRUE)
  if (missing(start))
    start <- NULL
  dots <- names(list(...))
  dots <- dots[!is.element(dots, c("upper", "lower"))]
  if (missing(x) || length(x) == 0L || mode(x) != "numeric")
    stop("'x' must be a non-empty numeric vector")
  if (any(!is.finite(x)))
    stop("'x' contains missing or infinite values")
  if (missing(densfun) || !(is.function(densfun) || is.character(densfun)))
    stop("'densfun' must be supplied as a function or name")
  control <- list()
  n <- length(x)
  if (is.character(densfun)) {
    distname <- tolower(densfun)
    densfun <- switch(distname, beta = dbeta, cauchy = dcauchy,
                      `chi-squared` = dchisq, exponential = dexp, f = df,
                      gamma = dgamma, geometric = dgeom, `log-normal` = dlnorm,
                      lognormal = dlnorm, logistic = dlogis, `negative binomial` = dnbinom,
                      normal = dnorm, poisson = dpois, t = mydt, weibull = dweibull,
                      NULL)
    if (is.null(densfun))
      stop("unsupported distribution")
    if (distname %in% c("lognormal", "log-normal")) {
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "log-Normal"), domain = NA)
      if (any(x <= 0))
        stop("need positive values to fit a log-Normal")
      lx <- log(x)
      sd0 <- sqrt((n - 1)/n) * sd(lx)
      mx <- mean(lx)
      estimate <- c(mx, sd0)
      sds <- c(sd0/sqrt(n), sd0/sqrt(2 * n))
      names(estimate) <- names(sds) <- c("meanlog", "sdlog")
      vc <- matrix(c(sds[1]^2, 0, 0, sds[2]^2), ncol = 2,
                   dimnames = list(names(sds), names(sds)))
      names(estimate) <- names(sds) <- c("meanlog", "sdlog")
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dlnorm(x, mx, sd0, log = TRUE))), class = "FitDistr"))
    }
    if (distname == "normal") {
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "Normal"), domain = NA)
      sd0 <- sqrt((n - 1)/n) * sd(x)
      mx <- mean(x)
      estimate <- c(mx, sd0)
      sds <- c(sd0/sqrt(n), sd0/sqrt(2 * n))
      names(estimate) <- names(sds) <- c("mean", "sd")
      vc <- matrix(c(sds[1]^2, 0, 0, sds[2]^2), ncol = 2,
                   dimnames = list(names(sds), names(sds)))
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dnorm(x, mx,
                                                                 sd0, log = TRUE))), class = "FitDistr"))
    }
    if (distname == "poisson") {
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "Poisson"), domain = NA)
      estimate <- mean(x)
      sds <- sqrt(estimate/n)
      names(estimate) <- names(sds) <- "lambda"
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("lambda",
                                                              "lambda"))
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dpois(x, estimate,
                                                                 log = TRUE))), class = "FitDistr"))
    }
    if (distname == "exponential") {
      if (any(x < 0))
        stop("Exponential values must be >= 0")
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "exponential"), domain = NA)
      estimate <- 1/mean(x)
      sds <- estimate/sqrt(n)
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("rate",
                                                              "rate"))
      names(estimate) <- names(sds) <- "rate"
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dexp(x, estimate,
                                                                log = TRUE))), class = "FitDistr"))
    }
    if (distname == "geometric") {
      if (!is.null(start))
        stop(gettextf("supplying pars for the %s distribution is not supported",
                      "geometric"), domain = NA)
      estimate <- 1/(1 + mean(x))
      sds <- estimate * sqrt((1 - estimate)/n)
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("prob",
                                                              "prob"))
      names(estimate) <- names(sds) <- "prob"
      return(structure(list(estimate = estimate, sd = sds,
                            vcov = vc, n = n, loglik = sum(dgeom(x, estimate,
                                                                 log = TRUE))), class = "FitDistr"))
    }
    if (distname == "weibull" && is.null(start)) {
      if (any(x <= 0))
        stop("Weibull values must be > 0")
      lx <- log(x)
      m <- mean(lx)
      v <- var(lx)
      shape <- 1.2/sqrt(v)
      scale <- exp(m + 0.572/shape)
      start <- list(shape = shape, scale = scale)
      start <- start[!is.element(names(start), dots)]
    }
    if (distname == "gamma" && is.null(start)) {
      if (any(x < 0))
        stop("gamma values must be >= 0")
      m <- mean(x)
      v <- var(x)
      start <- list(shape = m^2/v, rate = m/v)
      start <- start[!is.element(names(start), dots)]
      control <- list(parscale = c(1, start$rate))
    }
    if (distname == "negative binomial" && is.null(start)) {
      m <- mean(x)
      v <- var(x)
      size <- if (v > m)
        m^2/(v - m)
      else 100
      start <- list(size = size, mu = m)
      start <- start[!is.element(names(start), dots)]
    }
    if (is.element(distname, c("cauchy", "logistic")) &&
        is.null(start)) {
      start <- list(location = median(x), scale = IQR(x)/2)
      start <- start[!is.element(names(start), dots)]
    }
    if (distname == "t" && is.null(start)) {
      start <- list(m = median(x), s = IQR(x)/2, df = 10)
      start <- start[!is.element(names(start), dots)]
    }
  }
  if (is.null(start) || !is.list(start))
    stop("")
  nm <- names(start)
  f <- formals(densfun)
  args <- names(f)
  m <- match(nm, args)
  if (any(is.na(m)))
    stop("'start' specifies names which are not arguments to 'densfun'")
  formals(densfun) <- c(f[c(1, m)], f[-c(1, m)])
  dens <- function(parm, x, ...) densfun(x, parm, ...)
  if ((l <- length(nm)) > 1L)
    body(dens) <- parse(text = paste("densfun(x,", paste("parm[",
                                                         1L:l, "]", collapse = ", "), ", ...)"))
  Call[[1L]] <- quote(stats::optim)
  Call$densfun <- Call$start <- NULL
  Call$x <- x
  Call$par <- start
  Call$fn <- if ("log" %in% args)
    mylogfn
  else myfn
  Call$hessian <- TRUE
  if (length(control))
    Call$control <- control
  if (is.null(Call$method)) {
    if (any(c("lower", "upper") %in% names(Call)))
      Call$method <- "L-BFGS-B"
    else if (length(start) > 1L)
      Call$method <- "BFGS"
    else Call$method <- "Nelder-Mead"
  }
  res <- eval.parent(Call)
  if (res$convergence > 0L)
    stop("optimization failed")
  vc <- solve(res$hessian)
  sds <- sqrt(diag(vc))
  structure(list(estimate = res$par, sd = sds, vcov = vc,
                 loglik = -res$value, n = n), class = "FitDistr")
}
.myADTest = function(x, distribution, ...) {                                                                     ####   .MYADTESTS-FUNCTION
  #require(MASS, quietly = TRUE)
  if (missing(distribution)) 
    distribution = "normal"
  data.name = names(x)
  if (is.data.frame(x)) 
    x = x[, 1]
  dots = list()
  parameter = NULL
  smaller = NULL
  pFun = NULL
  tableValue = FALSE
  A = 0
  x <- sort(x[complete.cases(x)])
  n = length(x)
  if (n < 8) 
    stop("sample size must be greater than 7")
  if (n > 40) 
    warning("sample size is greater than 40")
  if (is.character(distribution)) {
    pFun = .charToDistFunc(distribution, type = "p")
    distribution = tolower(distribution)
    if (is.null(pFun)) 
      stop(paste(deparse(substitute(distribution)), " is not supported!"))
  }
  else {
    pFun = match.fun(distribution)
  }                                                                      ####
  if (length(dots) == 0) {
    fittedDistr = MASS::fitdistr(x, distribution)
    parameter = fittedDistr$estimate
    if (distribution == "normal") {
      parameter["mean"] = mean(x)
      parameter["sd"] = sd(x)
    }
    p = do.call(pFun, c(list(x), as.list(parameter)))
  }
  else {
    p = pFun(x, ...)
  }
  h = (2 * seq(1:n) - 1) * (log(p) + log(1 - rev(p)))
  A = -n - mean(h)
  AA = (1 + 0.75/n + 2.25/n^2) * A
  if (AA < 0.2) {
    pval <- 1 - exp(-13.436 + 101.14 * AA - 223.73 * AA^2)
  }
  else if (AA < 0.34) {
    pval <- 1 - exp(-8.318 + 42.796 * AA - 59.938 * AA^2)
  }
  else if (AA < 0.6) {
    pval <- exp(0.9177 - 4.279 * AA - 1.38 * AA^2)
  }
  else {
    pval <- exp(1.2937 - 5.709 * AA + 0.0186 * AA^2)
  }
  if (identical(distribution, "cauchy")) {
    pval = NA
  }
  if (identical(distribution, "beta")) {
    pval = NA
  }
  if (identical(distribution, "chi-squared")) {
    pval = NA
  }
  if (identical(distribution, "f")) {
    pval = NA
  }
  if (identical(distribution, "t")) {
    pval = NA
  }
  if (identical(distribution, "geometric")) {
    pval = NA
  }
  if (identical(distribution, "poisson")) {
    pval = NA
  }
  if (identical(distribution, "negative-binomial")) {
    pval = NA
  }
  if (identical(distribution, "weibull")) {
    AWei = A * (1 + 1/sqrt(n))
    tableValue = TRUE
    smaller = TRUE
    if (AWei < 0.474) {
      pval = 0.25
      smaller = FALSE
    }
    if (AWei >= 0.474) 
      pval = 0.25
    if (AWei >= 0.637) 
      pval = 0.1
    if (AWei >= 0.757) 
      pval = 0.05
    if (AWei >= 0.877) 
      pval = 0.025
    if (AWei >= 1.038) 
      pval = 0.01
  }
  if (identical(distribution, "exponential")) {
    AExp = A * (1 + 0.6/n)
    pval = NA
    if (0.95 < AExp) {
      pval = exp(0.731 - 3.009 * AExp + 0.15 * AExp^2)
    }
    if (0.51 < AExp & AExp < 0.95) {
      pval = exp(0.9209 - 3.353 * AExp + 0.3 * AExp^2)
    }
    if (0.26 < AExp & AExp < 0.51) {
      pval = 1 - exp(-6.1327 + 20.218 * AExp - 18.663 * AExp^2)
    }
    if (AExp < 0.26) {
      pval = 1 - exp(-12.2204 + 67.459 * AExp - 110.3 * AExp^2)
    }
  }
  if (identical(distribution, "logistic")) {
    ALogist = A * (1 + 0.25/n)
    tableValue = TRUE
    smaller = TRUE
    if (ALogist < 0.426) {
      pval = 0.25
      smaller = FALSE
    }
    if (ALogist >= 0.426) {
      pval = 0.25
    }
    if (ALogist >= 0.563) {
      pval = 0.1
    }
    if (ALogist >= 0.66) {
      pval = 0.05
    }
    if (ALogist >= 0.769) {
      pval = 0.025
    }
    if (ALogist >= 0.906) {
      pval = 0.01
    }
    if (ALogist >= 1.1) {
      pval = 0.005
    }
  }
  if (identical(distribution, "gamma")) {
    tableValue = TRUE
    gammaDF = data.frame(c(1, 2, 3, 4, 5, 6, 8, 10, 12, 15, 20, Inf), c(0.486, 0.477, 0.475, 
                                                                        0.473, 0.472, 0.472, 0.471, 0.471, 0.471, 0.47, 0.47, 0.47), c(0.657, 0.643, 0.639, 0.637, 
                                                                                                                                       0.635, 0.635, 0.634, 0.633, 0.633, 0.632, 0.632, 0.631), c(0.786, 0.768, 0.762, 0.759, 
                                                                                                                                                                                                  0.758, 0.757, 0.755, 0.754, 0.754, 0.754, 0.753, 0.752), c(0.917, 0.894, 0.886, 0.883, 
                                                                                                                                                                                                                                                             0.881, 0.88, 0.878, 0.877, 0.876, 0.876, 0.875, 0.873), c(1.092, 1.062, 1.052, 1.048, 
                                                                                                                                                                                                                                                                                                                       1.045, 1.043, 1.041, 1.04, 1.039, 1.038, 1.037, 1.035), c(1.227, 1.19, 1.178, 1.173, 
                                                                                                                                                                                                                                                                                                                                                                                 1.17, 1.168, 1.165, 1.164, 1.163, 1.162, 1.161, 1.159))
    names(gammaDF) = c("m", 0.75, 0.9, 0.95, 0.975, 0.99, 0.995)
    critCheck <- gammaDF[min(which(gammaDF$m >= parameter["shape"])), 2:length(gammaDF)] > A
    if (any(critCheck)) {
      firPos <- min(which(critCheck))
    }
    else {
      firPos <- length(gammaDF)
    }
    if (firPos == 1) {
      pValue <- 1 - as.numeric(names(gammaDF)[2])
      pval = pValue
      pValue <- paste(">", pValue)
      smaller = FALSE
    }
    else {
      pValue <- 1 - as.numeric(names(gammaDF)[firPos])
      pval = pValue
      pValue <- paste("<=", pValue)
      smaller = TRUE
    }
  }
  out = list()
  out$data.name = data.name
  out$statistic = as.vector(data.frame(A = A))
  out$parameter = parameter
  out$p.value = as.vector(data.frame(p = pval))
  out$smaller = smaller
  out$tableValue = tableValue
  out$conf.int = NULL
  out$estimate = NULL
  temp = NULL
  if (is.character(distribution)) 
    temp = as.vector(distribution)
  else temp = deparse(substitute(distribution))
  names(temp) = "distribution"
  out$null.value = temp
  out$method = paste("Anderson Darling Test for", temp, "distribution")
  out$class = "adtest"
  invisible(out)
}
# Class Distr ----
Distr <- R6Class("Distr",
                 public = list(
                   x = NULL,
                   name = NULL,
                   parameters = NULL,
                   sd = NULL,
                   n = NULL,
                   loglik = NULL,
                   
                   initialize = function(x, name, parameters, sd, n, loglik) {
                     self$x <- x
                     self$name <- name
                     self$parameters <- parameters
                     self$sd <- sd
                     self$n <- n
                     self$loglik <- loglik
                   },
                   
                   plot = function(main = NULL, xlab = NULL, xlim = NULL, ylim = NULL, ylab = NULL, line.col = "red", box=TRUE,line.width = 1, ...)
                   {
                     object <- self
                     xVals <- object$x
                     parameters <- object$parameters
                     lq <- NULL
                     uq <- NULL
                     y <- NULL
                     
                     if (missing(line.col)) {
                       line.col <- "red"
                     }
                     if (missing(line.width)) {
                       line.width <- 1
                     }
                     if (missing(main)) {
                       main <- object$name
                     }
                     if (missing(xlab)) {
                       xlab <- "x"
                     }
                     if (missing(ylab)) {
                       ylab <- "Density"
                     }
                     
                     distr <- object$name
                     qFun <- .charToDistFunc(distr, type = "q")
                     dFun <- .charToDistFunc(distr, type = "d")
                     adTestStats <- .myADTest(xVals, distr)
                     
                     if (class(adTestStats) == "adtest") {
                       A <- adTestStats$statistic
                       p <- adTestStats$p.value
                     } else {
                       A <- NA
                       p <- NA
                     }
                     
                     histObj <- hist(xVals, plot = FALSE)
                     df <- data.frame(
                       mid = histObj$mids,
                       density = histObj$density
                     )
                     width <- diff(df$mid)[1]
                     
                     if (missing(xlim)) {
                       lq <- do.call(qFun, c(list(1e-04), as.list(parameters)))
                       uq <- do.call(qFun, c(list(0.9999), as.list(parameters)))
                       xlim <- range(lq, uq, xVals)
                     }
                     
                     xPoints <- seq(xlim[1], xlim[2], length = 200)
                     yPoints <- do.call(dFun, c(list(xPoints), as.list(parameters)))
                     
                     if (missing(ylim)) {
                       ylim <- range(0, histObj$density, yPoints)
                     }
                     
                     # Histograma
                     p1 <- ggplot(df, aes(x = mid, y = density)) +
                       geom_bar(stat = "identity", width = width, fill = "lightblue", color = "black", alpha = 0.5) +
                       labs(y = ylab, x = xlab, title = main) + xlim(xlim) + ylim(ylim) +
                       theme_minimal() + theme(plot.title = element_text(hjust = 0.5,face = "bold"))+
                       guides(color = guide_legend(title.position = "top", title.hjust = 0.5))+
                       geom_line(data = data.frame(x = xPoints, y = yPoints), aes(x = x, y = y), color = line.col, linewidth = line.width) + # densidad
                       theme(legend.position = "none")
                     
                     # Caja de Info
                     if (box==FALSE) {
                       p1
                     }
                     else {
                       p2 <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
                         theme_bw() +
                         theme(
                           axis.text = element_blank(),
                           axis.ticks = element_blank(),
                           axis.title = element_blank(),
                           panel.grid.major = element_blank(),
                           panel.grid.minor = element_blank()
                         ) +
                         xlim(c(0.25,0.26)) + ylim(c(0.19, 0.36))
                       {
                         # n y A
                         p2 <- p2 +
                           annotate('text', x = 0.25, y = 0.25,
                                    label = paste("A==", round(as.numeric(A), digits = 3)),
                                    parse = TRUE, size = 3, hjust = 0)
                         # p
                         if (!is.null(adTestStats$smaller) && adTestStats$smaller){
                           p2 <- p2 +
                             annotate('text',x = 0.25,y = 0.20,
                                      label = paste("p<", round(as.numeric(p), digits =3)),
                                      parse = TRUE,size = 3,hjust = 0)
                         }
                         if (!is.null(adTestStats$smaller) && !adTestStats$smaller){
                           p2 <- p2 +
                             annotate('text',x = 0.25, y = 0.20,
                                      label = paste("p>=", round(as.numeric(p),digits = 3)),
                                      parse = TRUE,size = 3,hjust = 0)
                         }
                         if (is.null(adTestStats$smaller)){
                           p2 <- p2 +
                             annotate('text',x = 0.25,y = 0.20,
                                      label = paste("p==", round(as.numeric(p), digits = 3)),
                                      parse = TRUE,size = 3,hjust = 0)
                         }
                         
                         # mean y sd
                         p2 <- p2 + annotate('text', x = 0.25, y = 0.35,
                                             label = paste("mean==", round(self$parameters[[1]], digits = 3)),
                                             parse = TRUE, size = 3, hjust = 0) +
                           annotate('text', x = 0.25, y = 0.30,
                                    label = paste("sd==", round(self$parameters[[2]], digits = 3)),
                                    parse = TRUE, size = 3, hjust = 0)
                         }
                       
                       p1 + inset_element(p2, left = 0.7, right = 1, top = 1, bottom = 0.60)
                     }
                   }
                 )
)

# Class DistrCollection ----
DistrCollection <- R6::R6Class("DistrCollection",
                               public = list(
                                 distr = NULL,
                                 initialize = function() {
                                   self$distr <- list()
                                 },
                                 add = function(distr) {
                                   self$distr <- append(self$distr, list(distr))
                                 },
                                 get = function(i) {
                                   self$distr[[i]]
                                 },
                                 show = function() {
                                   cat("\n")
                                   for (i in seq_along(self$distr)) {
                                     temp <- self$distr[[i]]
                                     cat("\n")
                                     cat("fitted distribution is", temp$name, ":\n")
                                     print(temp$parameters)
                                     cat("\n")
                                   }
                                 },
                                 summary = function() {
                                   numDist <- length(self$distr)
                                   gofMatrix <- data.frame(matrix(nrow = numDist, ncol = 3))
                                   names(gofMatrix) <- c("Distribution", "A", "p.value")
                                   cat("\n------ Fitted Distribution and estimated parameters ------\n")
                                   for (i in seq_along(self$distr)) {
                                     distrObj <- self$distr[[i]]
                                     x <- distrObj$x
                                     distribution <- distrObj$name
                                     parameters <- distrObj$parameters
                                     statistic <- NA
                                     p.value <- NA
                                     temp <- .myADTest(x, distribution)
                                     try(statistic <- as.numeric(temp$statistic), silent = TRUE)
                                     try(p.value <- as.numeric(temp$p.value), silent = TRUE)
                                     gofMatrix[i, ] <- c(distribution, as.numeric(statistic), as.numeric(p.value))
                                     cat("\n")
                                     cat("fitted distribution is", distribution, ":\n")
                                     print(parameters)
                                   }
                                   cat("\n")
                                   cat("\n------ Goodness of Fit - Anderson Darling Test ------\n")
                                   cat("\n")
                                   gofMatrixPrint <- gofMatrix
                                   gofMatrixPrint[, 2] <- signif(as.numeric(gofMatrixPrint[, 2]), 4)
                                   gofMatrixPrint[, 3] <- signif(as.numeric(gofMatrixPrint[, 3]), 4)
                                   print(gofMatrixPrint)
                                 },
                                 plot = function(xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL, line.col = "red", line.width = 1, box = TRUE , ...) {
                                   distrList <- self$distr
                                   numDist <- length(self$distr)
                                   numColWin <- ceiling(numDist/2)
                                   if (missing(xlim)) {
                                     xlim <- .xyLimits(self)$xlim
                                   }
                                   if (missing(ylim)) {
                                     ylim <- .xyLimits(self)$ylim
                                   }
                                   if (missing(line.col)) {
                                     line.col <- "red"
                                   }
                                   if (missing(line.width)) {
                                     line.width <- 1
                                   }
                                   p <- distrList[[1]]$plot(xlab = xlab, ylab = ylab, line.col = line.col, line.width = line.width, box = box)
                                   for (i in 2:length(distrList)) {
                                     p <- p+distrList[[i]]$plot(xlab = xlab, ylab = ylab, line.col = line.col, line.width = line.width, box = box)
                                   }
                                   p
                                 }
                               )
)


# Funcion Distribution ----
distribution <- function(x = NULL, distrib = "weibull", start, ...) {
  distr_coll <- DistrCollection$new()
  if (is.character(distrib))
    distrib = tolower(distrib)
  allDistr = c("beta", "cauchy", "chi-squared", "exponential", "f", "gamma", "geometric", "log-normal", "logistic", "negative binomial", "normal", "poisson",
               "t", "weibull")
  if (distrib %in% allDistr){
    distrVec = distrib
  }
  else{distrVec = c("normal")}
  if (identical(distrib, "all"))
    distrVec = allDistr
  if (identical(distrib, "quality"))
    distrVec = c("normal", "log-normal", "exponential", "weibull")
  for (i in seq(along = distrVec)) {
    temp <- suppressWarnings(FitDistr(x, densfun = distrVec[i]))
    fit <- Distr$new(x = x,
                     name = distrVec[i],
                     parameters = temp$estimate,
                     sd = temp$sd,
                     loglik = temp$loglik,
                     n = length(x))
    distr_coll$add(fit)
  }
  return(distr_coll)
}

# Funciones auxiliares
.sdSg = function(x, grouping = NULL, method = c("NOWEIGHT", "MVLUE", "RMSDF"), na.rm = TRUE, DB = TRUE) {
  DB = FALSE
  if (!is.data.frame(x) && !is.vector(x) && is.numeric(x))
    stop("x needs to be either a data.frame or a vector and numeric")
  if (is.null(grouping)) {
    if (is.data.frame(x))
      return(sd(x[, 1]))
    else return(sd(x))
  }
  else grouping = as.data.frame(grouping)
  group = unique(grouping)
  sdVec = numeric(length = length(group))
  for (i in 1:nrow(group)) {
    if (is.data.frame(x))
      temp = x[group[i, 1] == grouping[, 1], 1]
    if (is.vector(x))
      temp = x[group[i, 1] == grouping[, 1]]
    sdVec[i] = sd(temp, na.rm = T)/.c4(length(temp[!is.na(temp)]))
    if (DB) {
      print(group[i, 1])
      print(temp)
      print(length(temp[!is.na(temp)]))
    }
  }
  if (DB) {
    print(paste("std.dev: ", mean(sdVec)))
    print(sdVec)
  }
  return((mean(sdVec)))
}
.lfkp = function(wholeList, filterList) {
  if (!is.list(wholeList))
    stop(paste(deparse(substitute(wholeList)), "is not a list!"))
  if (length(wholeList) == 0)
    return(wholeList)
  if (!is.list(filterList))
    stop(paste(deparse(substitute(filterList)), "is not a list!"))
  if (length(filterList) == 0)
    return(filterList)
  logVec = lapply(names(wholeList), "%in%", names(filterList))
  filteredList = wholeList[unlist(logVec)]
  return(filteredList)
}
.lfrm = function(wholeList, filterList) {
  if (!is.list(wholeList))
    stop(paste(deparse(substitute(wholeList)), "is not a list!"))
  if (length(wholeList) == 0)
    return(wholeList)
  if (!is.list(filterList))
    stop(paste(deparse(substitute(filterList)), "is not a list!"))
  if (length(filterList) == 0)
    return(wholeList)
  logVec = lapply(names(wholeList), "%in%", names(filterList))
  filteredList = wholeList[!unlist(logVec)]
  return(filteredList)
}
# Funcion .xyLimits -------------------
.xyLimits = function(distrCollection, lowerquantile = 0.001, upperquantile = 0.999) {
  x <- NULL
  y <- NULL
  for (i in seq_along(distrCollection$distr)) {
    object <- distrCollection$distr[[i]]
    xValues <- object$x
    parameters <- object$parameters
    distr <- object$name
    qFun <- .charToDistFunc(distr, type = "q")
    dFun <- .charToDistFunc(distr, type = "d")
    lq <- do.call(qFun, c(list(lowerquantile), as.list(parameters)))
    uq <- do.call(qFun, c(list(upperquantile), as.list(parameters)))
    x <- range(x, xValues, lq, uq)
    histObj <- hist(xValues, plot = FALSE)
    xPoints <- seq(x[1], x[2], length = 200)
    yPoints <- do.call(dFun, c(list(xPoints), as.list(parameters)))
    y <- range(y, 0, histObj$density, yPoints)
  }
  invisible(list(xlim = x, ylim = y))
}

# Funcion qqPlot ---------------------
qqPlot <- function(x, y, confbounds = TRUE, alpha, main, xlab, ylab, xlim, ylim, border = "red", bounds.col = "black", bounds.lty = 1, start, grapic = TRUE, axis.y.right = FALSE, bw.theme = FALSE,...){
  DB = FALSE
  parList = list()
  if (is.null(parList[["col"]])){
    parList$col = 1:2
  }
  if (is.null(parList[["pch"]])){
    parList$pch = 19
  }
  if (is.null(parList[["lwd"]])){
    parList$lwd = 0.5
  }
  if (is.null(parList[["cex"]])){
    parList$cex = 1
  }
  if(inherits(x, "DistrCollection")){
    distList <- x$distr
    grap <- qqPlot(distList[[1]]$x, grapic = FALSE, ylab = "", xlab = "", main = paste(distList[[1]]$name,"distribution"))
    for (i in 2:length(distList)){
      aux <- qqPlot(distList[[i]]$x, grapic = FALSE, ylab = "", xlab = "", main = paste(distList[[i]]$name,"distribution"))
      grap$plot <-  grap$plot + aux$plot
    }
    show(grap$plot + plot_annotation(title = "QQ Plot for a Collection Distribution"))
    invisible()
  }
  else{
    if (missing(y))
      y = "normal"
    if(missing(alpha))
      alpha = 0.05
    if (alpha <=0 || alpha >=1)
      stop(paste("alpha should be between 0 and 1!"))
    if (missing(main))
      main = paste("QQ Plot for", deparse(substitute(y)), "distribution")
    if (missing(xlab))
      xlab = paste("Quantiles for", deparse(substitute(x)))
    if (missing(ylab))
      ylab = paste("Quantiles from", deparse(substitute(y)), "distribution")
    if (is.numeric(y)) {
      cat("\ncalling (original) qqplot from namespace stats!\n")
      return(stats::qqplot(x, y, ...))
    }
    qFun = NULL
    theoretical.quantiles = NULL
    xs = sort(x)
    distribution = tolower(y)
    distWhichNeedParameters = c("weibull", "logistic", "gamma","exponential", "f",
                                "geometric", "chi-squared", "negative binomial",
                                "poisson")
    
    threeParameterDistr = c("weibull3", "lognormal3", "gamma3")
    threeParameter = distribution %in% threeParameterDistr
    if(threeParameter) distribution = substr(distribution, 1, nchar(distribution)-1)
    if(is.character(distribution)){
      qFun = .charToDistFunc(distribution, type = "q")
      if (is.null(qFun))
        stop(paste(deparse(substitute(y)), "distribution could not be found!"))
    }
    # Puntos teoricos
    theoretical.probs = ppoints(xs)
    # Quantiles
    xq = NULL
    yq = quantile(xs, prob = c(0.25, 0.75))
    
    
    dots <- list(...)
    
    if(TRUE){
      if (DB)
        print("TODO: Pass the estimated parameters correctly")
      fitList = .lfkp(parList, formals(qFun))
      fitList$x = xs
      fitList$densfun = distribution
      if(!missing(start))
        fitList$start = start
      if(DB){
        print(fitList)
        print("Ende")
      }
      if(!threeParameter){
        fittedDistr = do.call(FitDistr, fitList)
        parameter = fittedDistr$estimate
        
        #save the distribution parameter#
        thethas = fittedDistr$estimate
        # save the cariance-covariance matrix
        varmatrix = fittedDistr$vcov
        
      }else{
        parameter = do.call(paste(".",distribution, "3", sep = ""), list(xs) )    ####
        threshold = parameter$threshold
      }
      
      parameter = .lfkp(as.list(parameter), formals(qFun))
      params = .lfkp(parList, formals(qFun))
      parameter = .lfrm(as.list(parameter), params)
      parameter = c(parameter, params)
      theoretical.quantiles = do.call(qFun, c(list(c(theoretical.probs)), parameter))
      
      if(!threeParameter){
        confIntCapable = c("exponential", "log-normal", "logistic", "normal", "weibull", "gamma", "beta", "cauchy")
        getConfIntFun = .charToDistFunc(distribution, type = ".confint")
        if(confbounds == TRUE){
          if(distribution %in% confIntCapable){
            confInt = getConfIntFun(xs, thethas, varmatrix, alpha)
          }
        }
      }
      
      xq <- do.call(qFun, c(list(c(0.25, 0.75)), parameter))
      if (DB) {
        print(paste("parameter: ", parameter))
        print(xq)
      }
    }
    else {
      params =.lfkp(parList, formals(qFun))
      params$p = theoretical.probs
      theoretical.quantiles = do.call(qFun, params)
      params$p = c(0.25, 0.75)
      xq = do.call(qFun, params)
    }
    
    params =.lfkp(parList, c(formals(plot.default), par()))
    
    if(!threeParameter){
      params$y = theoretical.quantiles
    }else{
      params$y = theoretical.quantiles+threshold
    }
    params$x = xs
    params$xlab = xlab
    params$ylab = ylab
    params$main = main
    if (!(is.null(params$col[1]) || is.na(params$col[1])))
      params$col = params$col[1]
    
    params$lwd = 1
    
    ############ Desde Aquí comienza la gráfica ############
    p <- ggplot(data = data.frame(x=params$x, y=params$y), mapping=aes(x=x, y=y)) +
      geom_point() + labs(x = xlab, y = ylab, title = main) + theme_minimal()
    
    params =.lfkp(parList, c(formals(abline), par()))
    params$a = 0
    params$b = 1
    params$col = border
    p <- p + geom_abline(intercept = params$a, slope = params$b, col = params$col, lwd = params$lwd)
    
    if(!threeParameter){
      if(confbounds == TRUE){
        if(distribution %in% confIntCapable){
          params =.lfkp(parList, c(formals(lines), par()))
          params$x = confInt[[3]]
          params$y = confInt[[1]]
          params$col = bounds.col
          params$lty = bounds.lty
          # La curva de abajo
          p <- p + geom_line(data = data.frame(x=params$x, y=params$y), aes(x = x, y = y),
                             col = params$col, lty = params$lty, lwd = params$lwd)
          params$x = confInt[[3]]
          params$y = confInt[[2]]
          params$col = bounds.col
          params$lty = bounds.lty
          # curva de arriba
          p <- p + geom_line(data = data.frame(x=params$x, y=params$y), aes(x = x, y = y),
                             col = params$col, lty = params$lty, lwd = params$lwd)
        }
      }
    }
    if(axis.y.right){
      p <- p + scale_y_continuous(position = "right")
    }
    if(bw.theme){
      p <- p + theme_bw()
    }
    if(main == ""){
      p <- p + labs(title = NULL)
    }
    if(grapic){
      show(p)
      invisible(list(x = theoretical.quantiles, y = xs, int = params$a, slope = params$b, plot = p))
    }
    else{
      invisible(list(x = theoretical.quantiles, y = xs, int = params$a, slope = params$b, plot = p))
    }
  }
}

```


```{r, echo=FALSE}
# nueva función
pcr_ <- function (x, distribution = "normal", lsl, usl, target, boxcox = FALSE,
                  lambda = c(-5, 5), main, xlim, ylim, grouping = NULL, std.dev = NULL,
                  conf.level = 0.9973002, start, lineWidth = 1, lineCol = "red",
                  lineType = "solid", specCol = "red3", specWidth = 1, cex.text = 2,
                  cex.val = 1.5, cex.col = "darkgray", plot = TRUE, bounds.lty = 3,
                  bounds.col = "red", ...) {
  DB = FALSE
  data.name = deparse(substitute(x))[1]
  
  parList = list(...)
  if (is.null(parList[["col"]]))
    parList$col = "lightblue"
  if (is.null(parList[["border"]]))
    parList$border = 1
  if (is.null(parList[["lwd"]]))
    parList$lwd = 1
  if (is.null(parList[["cex.axis"]]))
    parList$cex.axis = 1.5
  if (missing(lsl))
    lsl = NULL
  if (missing(usl))
    usl = NULL
  if (missing(target))
    target = NULL
  if (missing(lambda))
    lambda = c(-5, 5)
  if (!is.numeric(lambda))
    stop("lambda needs to be numeric")
  if (any(x < 0) && any(distribution == c("beta", "chi-squared",
                                          "exponential", "f", "geometric", "lognormal", "log-normal",
                                          "negative binomial", "poisson", "weibull", "gamma")))
    stop("choosen distribution needs all values in x to be > 0!")
  if (any(x > 1) && distribution == "beta")
    stop("choosen distribution needs all values in x to be between 0 and 1!")
  
  paramsList = vector(mode = "list", length = 0)
  estimates = vector(mode = "list", length = 0)
  varName = deparse(substitute(x))
  dFun = NULL
  pFun = NULL
  qFun = NULL
  cp = NULL
  cpu = NULL
  cpl = NULL
  cpk = NULL
  ppt = NULL
  ppl = NULL
  ppu = NULL
  xVec = numeric(0)
  yVec = numeric(0)
  
  if (is.vector(x))
    x = as.data.frame(x)
  any3distr = FALSE
  not3distr = FALSE
  
  if (distribution == "weibull3" || distribution == "lognormal3" ||
      distribution == "gamma3")
    any3distr = TRUE
  if (distribution != "weibull3" && distribution != "lognormal3" &&
      distribution != "gamma3")
    not3distr = TRUE
  if (boxcox) {
    distribution = "normal"
    if (length(lambda) >= 2) {
      temp = boxcox(x[, 1] ~ 1, lambda = seq(min(lambda),
                                             max(lambda), 1/10), plotit = FALSE)
      i = order(temp$y, decreasing = TRUE)[1]
      lambda = temp$x[i]
    }
    x = as.data.frame(x[, 1]^lambda)
  }
  numObs = nrow(x)
  if (!is.null(grouping))
    if (is.vector(grouping))
      grouping = as.data.frame(grouping)
  center = colMeans(x)
  if (!is.null(x) & !is.null(grouping)) {
    if (nrow(x) != nrow(grouping))
      stop(paste("length of ", deparse(substitute(grouping)),
                 " differs from length of ", varName))
  }
  if (missing(main))
    if (boxcox)
      main = paste("Process Capability using box cox transformation for",
                   varName)
  else main = paste("Process Capability using", as.character(distribution),
                    "distribution for", varName)
  if (is.null(std.dev)) {
    if (is.null(grouping))
      std.dev = .sdSg(x)
    else std.dev = .sdSg(x, grouping)
  }
  if (conf.level < 0 | conf.level > 1)
    stop("conf.level must be a value between 0 and 1")
  confHigh = conf.level + (1 - conf.level)/2
  confLow = 1 - conf.level - (1 - conf.level)/2
  if (DB) {
    print(paste("confHigh:", confHigh))
    print(paste("confLow:", confLow))
  }
  distWhichNeedParameters = c("weibull", "logistic", "gamma",
                              "exponential", "f", "geometric", "chi-squared", "negative binomial",
                              "poisson")
  if (is.character(distribution)) {
    dis = distribution
    if (identical(distribution, "weibull3"))
      dis = "weibull3"
    if (identical(distribution, "gamma3"))
      dis = "gamma3"
    if (identical(distribution, "lognormal3"))
      dis = "lognormal3"
    qFun = .charToDistFunc(dis, type = "q")
    pFun = .charToDistFunc(dis, type = "p")
    dFun = .charToDistFunc(dis, type = "d")
    if (is.null(qFun) & is.null(pFun) & is.null(dFun))
      stop(paste(deparse(substitute(y)), "distribution could not be found!"))
  }
  if (TRUE) {
    if (DB)
      print("TODO: Pass the estimated parameters correctly")
    fitList = vector(mode = "list", length = 0)
    fitList$x = x[, 1]
    fitList$densfun = dis
    if (!missing(start))
      fitList$start = start
    if (not3distr) {
      fittedDistr = do.call(FitDistr, fitList)
      estimates = as.list(fittedDistr$estimate)
      paramsList = estimates
    }
    if (distribution == "weibull3") {
      paramsList = .weibull3(x[, 1])
      estimates = paramsList
    }
    if (distribution == "lognormal3") {
      paramsList = .lognormal3(x[, 1])
      estimates = paramsList
    }
    if (distribution == "gamma3") {
      paramsList = .gamma3(x[, 1])
      estimates = paramsList
    }
    if (DB)
      print(paste("parameter: ", paramsList))
  }
  paramsList = c(paramsList, .lfkp(parList, formals(qFun)))
  if (distribution == "normal") {
    paramsList$mean = center
    paramsList$sd = std.dev
    estimates = paramsList
  }
  if (boxcox) {
    if (!is.null(lsl))
      lsl = lsl^lambda
    if (!is.null(usl))
      usl = usl^lambda
    if (!is.null(target))
      target = target^lambda
  }
  if (is.null(lsl) && is.null(usl)) {
    paramsList$p = confLow
    lsl = do.call(qFun, paramsList)
    paramsList$p = confHigh
    usl = do.call(qFun, paramsList)
  }
  
  if (identical(lsl, usl))
    stop("lsl == usl")
  if (!is.null(lsl) && !is.null(target) && target < lsl)
    stop("target is less than lower specification limit")
  if (!is.null(usl) && !is.null(target) && target > usl)
    stop("target is greater than upper specification limit")
  if (!is.null(lsl) && !is.null(usl))
    if (lsl > usl) {
      temp = lsl
      lsl = usl
      usl = temp
    }
  paramsList$p = c(confLow, 0.5, confHigh)
  paramsListTemp = .lfkp(paramsList, formals(qFun))
  qs = do.call(qFun, paramsListTemp)
  paramsListTemp = .lfkp(paramsList, formals(pFun))
  if (!is.null(lsl) && !is.null(usl))
    cp = (usl - lsl)/(qs[3] - qs[1])
  if (!is.null(usl)) {
    cpu = (usl - qs[2])/(qs[3] - qs[2])
    paramsListTemp$q = usl
    ppu = 1 - do.call(pFun, paramsListTemp)
  }
  if (!is.null(lsl)) {
    cpl = (qs[2] - lsl)/(qs[2] - qs[1])
    paramsListTemp$q = lsl
    ppl = do.call(pFun, paramsListTemp)
  }
  cpk = min(cpu, cpl)
  ppt = sum(ppl, ppu)
  if (DB == TRUE) {
    print(cp)
    print(cpk)
    print(cpu)
    print(cpl)
    print(ppu)
    print(ppl)
    print(ppt)
  }
  
  if(plot==TRUE){
    # ----------------------------- IF PLOT == TRUE -----------------------------------------------------------
    
    if (missing(xlim)) {
      xlim <- range(x[, 1], usl, lsl)
      xlim <- xlim + diff(xlim) * c(-0.2, 0.2)
    }
    xVec <- seq(min(xlim), max(xlim), length = 200)
    dParamsList = .lfkp(paramsList, formals(dFun))
    dParamsList$x = xVec
    
    yVec = do.call(dFun, dParamsList)
    histObj <- hist(x[, 1], plot = FALSE)
    if (missing(ylim)) {
      ylim <- range(histObj$density, yVec)
      ylim <- ylim + diff(ylim) * c(0, 0.05)
    }
    
    # 1. Histograma --------------------------------------------------------------------------
    # Calculos previos
    x.c <- x[, 1]
    temp <- hist(x.c, plot = FALSE)
    # Obtenemos la información para el histograma
    df <- data.frame(
      mid = temp$mids,
      density = temp$density
    )
    width <- diff(df$mid)[1] # Ancho de cada barra
    # Histograma
    p1 <- ggplot(df, aes(x = mid, y = density)) +
      geom_bar(stat = "identity", width = width, fill = "lightblue", color = "black", alpha = 0.5) +
      labs(y = "", x = "", title = "") +
      theme_minimal() + theme(plot.title = element_text(hjust = 0.5,face = "bold"))+
      guides(color = guide_legend(title.position = "top", title.hjust = 0.5))+
      geom_line(data = data.frame(x = xVec, y = yVec), aes(x = x, y = y), color = "red", linewidth = 0.5) + # densidad
      geom_vline(aes(xintercept = usl, color = "Confidence interval"), linetype = "dashed", col = "red") + # USL
      geom_vline(aes(xintercept = lsl, color = "Confidence interval"), linetype = "dashed", col = "red") + # LSL
      theme(legend.position = "none")
    
    #  etiquetas de los límites
    if (!is.null(lsl) & !is.null(usl)){
      p1 <- p1 +
        scale_x_continuous(limits = xlim, expand = c(0, 0),
                           sec.axis = sec_axis(~ ., breaks = c(lsl, usl),
                                               labels = c(paste("LSL =",format(lsl, digits = 3)), paste("USL =",format(usl, digits = 3)))
                           )) +
        theme(axis.text.y.right = element_text(size = 15))
    }else{
      if(!is.null(lsl)){
        p1 <- p1 +
          scale_x_continuous(limits = xlim, expand = c(0, 0),
                             sec.axis = sec_axis(~ ., breaks = lsl, labels = paste("LSL =",format(lsl, digits = 3)) )) +
          theme(axis.text.y.right = element_text(size = 15))
      }
      if(!is.null(usl)){
        p1 <- p1 +
          scale_x_continuous(limits = xlim, expand = c(0, 0),
                             sec.axis = sec_axis(~ ., breaks = usl,labels = paste("USL =",format(usl, digits = 3)))) +
          theme(axis.text.y.right = element_text(size = 15))
      }
    }
    
    # 2. Cajita de info Cp's --------------------------------------------------------------------------
    p2 <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
      ) +
      xlim(c(0.24, 0.26)) + ylim(c(0.21, 0.43))
    {
      if(is.null(cpu))
        p2 <- p2 + annotate('text', x = 0.25, y = 0.40,
                            label = paste("C[pkU]==", "*"),
                            parse = TRUE, size = 3.5, hjust = 0.5)
      else p2 <- p2 + annotate('text', x = 0.25, y = 0.40,
                               label = paste("C[pkU]==", round(cpu, 2)),
                               parse = TRUE, size = 3.5, hjust = 0.5)
      if(is.null(cpl))
        p2 <- p2 + annotate('text', x = 0.25, y = 0.35,
                            label = paste("C[pkL]==", "*"),
                            parse = TRUE, size = 3.5, hjust = 0.5)
      else
        p2 <- p2 + annotate('text', x = 0.25, y = 0.35,
                            label = paste("C[pkL]==", round(cpl, 2)),
                            parse = TRUE, size = 3.5, hjust = 0.5)
      if(is.null(cpk))
        p2 <- p2 + annotate('text', x = 0.25, y = 0.30,
                            label = paste("C[pk]==", "*"),
                            parse = TRUE, size = 3.5, hjust = 0.5)
      else
        p2 <- p2 + annotate('text', x = 0.25, y = 0.30,
                            label = paste("C[pk]==", round(cpk, 2)),
                            parse = TRUE, size = 3.5, hjust = 0.5)
      if(is.null(cp))
        p2 <- p2 + annotate('text', x = 0.25, y = 0.25,
                            label = paste("C[p]==", "*"),
                            parse = TRUE, size = 3.5, hjust = 0.5)
      else
        p2 <- p2 + annotate('text',x = 0.25,y = 0.25,
                            label = paste("C[p]==", round(cp, 2)),
                            parse = TRUE,size = 3.5,hjust = 0.5)
      }
    
    
    # 3. Cajita de info n, means, sd --------------------------------------------------------------------------
    index = 1:(length(estimates) + 3)
    names(x) = data.name
    if(not3distr){
      names(x) = data.name
      adTestStats = .myADTest(x, distribution)
      A = numeric()
      p = numeric()
      if (adTestStats$class == "adtest"){
        A = adTestStats$statistic$A
        p = adTestStats$p.value$p
      }
      
      # Caja de Info
      p3 <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
        theme_bw() +
        theme(
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          axis.title = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()
        ) +
        xlim(c(0.24, 0.26)) + ylim(c(0.21, 0.43))
      {
        # n y A
        p3 <- p3 + annotate('text', x = 0.25, y = 0.40,
                            label = paste("n==", numObs),
                            parse = TRUE, size = 3, hjust = 0.5) +
          annotate('text', x = 0.25, y = 0.35,
                   label = paste("A==", format(as.numeric(A), digits = 3)),
                   parse = TRUE, size = 3, hjust = 0.5)
        
        # p
        if (!is.null(adTestStats$smaller) && adTestStats$smaller){
          p3 <- p3 + annotate(
            'text',
            x = 0.25,
            y = 0.30,
            label = paste("p<", format(as.numeric(p), digits =3)),
            parse = TRUE,
            size = 3,
            hjust = 0.5
          )
        }
        if (!is.null(adTestStats$smaller) && !adTestStats$smaller){
          p3 <- p3 + annotate(
            'text',
            x = 0.25,
            y = 0.30,
            label = paste("p>=", format(as.numeric(p),digits = 3)),
            parse = TRUE,
            size = 3,
            hjust = 0.5
          )
        }
        if (is.null(adTestStats$smaller)){
          p3 <- p3 + annotate(
            'text',
            x = 0.25,
            y = 0.30,
            label = paste("p==", format(as.numeric(p), digits = 3)),
            parse = TRUE,
            size = 3,
            hjust = 0.5
          )
        }
        
        # mean y sd
        p3 <- p3 + annotate('text', x = 0.25, y = 0.25,
                            label = paste("mean==", format(estimates[[1]], digits = 3)),
                            parse = TRUE, size = 3, hjust = 0.5) +
          annotate('text', x = 0.25, y = 0.20,
                   label = paste("sd==", format(estimates[[2]], digits = 3)),
                   parse = TRUE, size = 3, hjust = 0.5)
        }
    }
    if(any3distr){
      p3 <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
        theme_bw() +
        theme(
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          axis.title = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()
        ) +
        xlim(c(0.24, 0.26)) + ylim(c(0.21, 0.43))
      {
        # n y A
        p3 <- p3 + annotate('text', x = 0.25, y = 0.40,
                            label = paste("n==", numObs),
                            parse = TRUE, size = 3, hjust = 0.5) +
          annotate('text', x = 0.25, y = 0.35,
                   label = paste("A = ", "*"),
                   parse = FALSE, size = 3, hjust = 0.5) +
          annotate('text', x = 0.25, y = 0.30,
                   label = paste("p = ", "*"),
                   parse = FALSE, size = 3, hjust = 0.5) +
          annotate('text', x = 0.25, y = 0.25,
                   label = paste("mean==", format(estimates[[1]], digits = 3)),
                   parse = TRUE, size = 3, hjust = 0.5) +
          annotate('text', x = 0.25, y = 0.20,
                   label = paste("sd==", format(estimates[[2]], digits = 3)),
                   parse = TRUE, size = 3, hjust = 0.5)
        }
    }
    
    # 4. qqPlot --------------------------------------------------------------------------
    p4 <- qqPlot(x[, 1], y = distribution, xlab = "", ylab = "", main = "",
                 axes = FALSE, bounds.lty = bounds.lty, bounds.col = bounds.col, grapic = FALSE, axis.y.right = TRUE, bw.theme = TRUE)
    
    # Unimos las 4 primeras gráficas
    main_plot <- p1 + (p2 / p3 / p4$plot) + plot_layout(widths = c(5, 1))
    
    # 5. Cajita de info 4 (Expected Fraction Nonconforming) --------------------------------------------------------------------------
    p5 <- ggplot(data.frame(x = c(-1, 1),y = c(0.5, 5)), aes(x = x, y = y)) +
      theme_bw() +
      ggtitle("Expected Fraction Nonconforming") +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.title = element_text(hjust = 0.5, vjust = -0.5,margin = margin(b = -12),size = 10)
      )
    
    p5_left <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.border = element_blank()
      ) +
      xlim(c(0.25,0.26)) + ylim(c(0.24, 0.36))
    {
      p5_left <- p5_left +
        annotate('text', x = 0.25, y = 0.35, label = "-----", size = 3, hjust = 0, colour = "white")
      # Pt
      p5_left <- p5_left +
        annotate("text", x = 0.25, y = 0.33, label = paste("p[t]==", format(ppt, digits = 6)),
                 parse = TRUE, size = 3.5, hjust = 0)
      # PL
      if(is.null(ppl)){
        p5_left <- p5_left +
          annotate("text", x = 0.25, y = 0.3, label = paste("p[L]==", "0"),
                   parse = TRUE, size = 3.5, hjust = 0)
      }else{
        p5_left <- p5_left +
          annotate("text", x = 0.25, y = 0.3, label = paste("p[L]==", format(ppl, digits = 6)),
                   parse = TRUE, size = 3.5, hjust = 0)
      }
      # PU
      if(is.null(ppu)){
        p5_left <- p5_left +
          annotate("text", x = 0.25, y = 0.27, label = paste("p[U]==", "0"),
                   parse = TRUE, size = 3.5, hjust = 0)
      }else{
        p5_left <- p5_left +
          annotate("text", x = 0.25, y = 0.27, label = paste("p[U]==", format(ppu, digits = 6)),
                   parse = TRUE, size = 3.5, hjust = 0)
      }
      }
    
    p5_right <- ggplot(data = data.frame(x = 0, y = 0), aes(x, y)) +
      theme_bw() +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.border = element_blank()
      ) +
      xlim(c(0.25,0.26)) + ylim(c(0.24, 0.36))
    {
      p5_right <- p5_right +
        annotate('text', x = 0.25, y = 0.35, label = "-----", size = 3, hjust = 0, colour = "white")
      
      # ppm
      p5_right <- p5_right +
        annotate("text", x = 0.25, y = 0.33, label = paste("ppm==", format(ppt * 1e+06, digits = 6)),
                 parse = TRUE, size = 3.5, hjust = 0)
      if(is.null(ppl)){
        p5_right <- p5_right +
          annotate("text", x = 0.25, y = 0.3, label = paste("ppm==", "0"),
                   parse = TRUE, size = 3.5, hjust = 0)
      }else{
        p5_right <- p5_right +
          annotate("text", x = 0.25, y = 0.3, label = paste("ppm==", format(ppl * 1e+06, digits = 6)),
                   parse = TRUE, size = 3.5, hjust = 0)
      }
      if(is.null(ppu)){
        p5_right <- p5_right +
          annotate("text", x = 0.25, y = 0.27, label = paste("ppm==", "0"),
                   parse = TRUE, size = 3.5, hjust = 0)
      }else{
        p5_right <- p5_right +
          annotate("text", x = 0.25, y = 0.27, label = paste("ppm==", format(ppu * 1e+06, digits = 6)),
                   parse = TRUE, size = 3.5, hjust = 0)
      }
      }
    
    p5 <- p5 + inset_element(p5_left, left = 0, right = 0.5, top = 0,  bottom = 0.80)+
      inset_element(p5_right, left = 0.5, right = 1, top = 0,  bottom = 0.80)
    
    # Caja info 6. Observed --------------------------------------------------------------------------
    obsL = 0
    obsU = 0
    p6 <- ggplot(data.frame(x = 0,y = 0), aes(x = x, y = y)) +
      theme_bw() +
      ggtitle("Observed") +
      theme(
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5, vjust = -0.5,margin = margin(b = -12), size = 10)
      ) +
      xlim(c(0.24, 0.26)) + ylim(c(0.27, 0.36))
    if (!is.null(lsl)){
      obsL = (sum(x < lsl)/length(x)) * 1e+06
      p6 <- p6 + annotate("text", x = 0.25, y = 0.31, label = paste("ppm==", format(obsL, digits = 6)),
                          parse = TRUE, size = 3.5, hjust = 0.5)
    } else{
      p6 <- p6 + annotate("text", x = 0.25, y = 0.31, label = paste("ppm==", 0),
                          parse = TRUE, size = 3.5, hjust = 0.5)
    }
    if (!is.null(usl)){
      obsU = (sum(x > usl)/length(x)) * 1e+06
      p6 <- p6 + annotate("text", x = 0.25, y = 0.28, label = paste("ppm==", format(obsU, digits = 6)),
                          parse = TRUE, size = 3.5, hjust = 0.5)
    } else{
      p6 <- p6 + annotate("text", x = 0.25, y = 0.28, label = paste("ppm==", 0),
                          parse = TRUE, size = 3.5, hjust = 0.5)
    }
    p6 <- p6 + annotate("text", x = 0.25, y = 0.34, label = paste("ppm==", format(obsL + obsU, digits = 6)),
                        parse = TRUE, size = 3.5, hjust = 0.5)
    
    # UNION --------------------------------------------------------------------------
    box_bottom <- p5 + p6 + plot_layout(widths = c(2, 1))
    main_plot <- p1 / box_bottom + plot_layout(heights = c(1, 0.5))
    box_right <- p2 / p3 / p4$plot
    box_right <- box_right/plot_spacer()
    main_plot <- (main_plot | box_right) + plot_layout(ncol = 2, widths = c(5, 1))
    main_plot <- main_plot + plot_annotation(
      title = main,
      theme = theme(plot.title = element_text(hjust = 0.5))
    )
    if(not3distr){
      print(adTestStats)
      show(main_plot)
      invisible(list(lambda = lambda, cp = cp, cpk = cpk,
                     cpl = cpl, cpu = cpu, ppt = ppt, ppl = ppl, ppu = ppu,
                     A = A, usl = usl, lsl = lsl, target = target, plot = main_plot))
    }else{
      show(main_plot)
      invisible(list(lambda = lambda, cp = cp, cpk = cpk,
                     cpl = cpl, cpu = cpu, ppt = ppt, ppl = ppl, ppu = ppu,
                     usl = usl, lsl = lsl, target = target, plot = main_plot))
    }
  }
  ## ---------------- end if plot == true --------------------------------------------------------------------------
  invisible(list(lambda = lambda, cp = cp, cpk = cpk, cpl = cpl,
                 cpu = cpu, ppt = ppt, ppl = ppl, ppu = ppu, usl = usl,
                 lsl = lsl, target = target, plot = main_plot))
}
```


1. Distribución Normal

```{r, results='hide'}
set.seed(1234)
datos <- rnorm(20, mean = 20)
pcr_(datos, "normal", lsl = 17, usl = 23)
```





[["cambio-de-funciones.html", "Capítulo 6 Cambio de Funciones 6.1 Fase 1: Definir 6.2 Fase 2: Medir 6.3 Fase 3: Analizar", " Capítulo 6 Cambio de Funciones .scroll-100 { max-height: 100px; overflow-y: auto; background-color: inherit; } 6.1 Fase 1: Definir 6.1.1 1. Función Pareto Resultados antes: defectos &lt;-c(rep(&quot;E&quot;,62),rep(&quot;B&quot;,15),rep(&quot;F&quot;,3),rep(&quot;A&quot;,10),rep(&quot;C&quot;,20),rep(&quot;D&quot;,10)) qualityTools::paretoChart(defectos) ## ## Frequency 62 20 15 10 10 3 ## Cum. Frequency 62 82 97 107 117 120 ## Percentage 51.7% 16.7% 12.5% 8.3% 8.3% 2.5% ## Cum. Percentage 51.7% 68.3% 80.8% 89.2% 97.5% 100.0% ## ## Frequency 62.00000 20.00000 15.00000 10.000000 10.000000 3.0 ## Cum. Frequency 62.00000 82.00000 97.00000 107.000000 117.000000 120.0 ## Percentage 51.66667 16.66667 12.50000 8.333333 8.333333 2.5 ## Cum. Percentage 51.66667 68.33333 80.83333 89.166667 97.500000 100.0 Resultados ahora: ParetoChart_(defectos) Podemos utilizar parámetros para mostrar la tabla o la gráfica: # Mostrar solo la gráfica ParetoChart_(defectos, showTable = FALSE) # Mostrar solo la tabla ParetoChart_(defectos, showPlot = FALSE) ## E C B A D F ## Frequency 62.00 20.00 15.00 10.00 10.00 3.0 ## Cum.Frequency 62.00 82.00 97.00 107.00 117.00 120.0 ## Percentage 51.67 16.67 12.50 8.33 8.33 2.5 ## Cum.Percentage 51.67 68.33 80.83 89.17 97.50 100.0 Podemos cambiar los colores de los puntos y las barras: ParetoChart_(defectos, col=&#39;blue&#39;, border=&#39;green&#39;) 6.2 Fase 2: Medir 6.2.1 1. Función cg Para poder implementar esta función, primero debemos modificar 3 funciones que se utilizan en esta función macro. Además utilizaremos los siguientes datos de pruebas: x &lt;- c(9.991, 10.013, 10.001, 10.007, 10.010, 10.013, 10.008, 10.017, 10.005, 10.005, 10.002, 10.017, 10.005, 10.002, 9.996, 10.011, 10.009, 10.006, 10.008, 10.003, 10.002, 10.006, 10.010, 9.992, 10.013) target = 10.003 tolerance = c(9.903, 10.103) ref.interval = pnorm(3) - pnorm(-3) facCg = 0.2 facCgk = 0.1 n = 0.2 type = &quot;b&quot; col = &quot;black&quot; pch = 19 #xlim = NULL #ylim = NULL conf.level = 0.95 cex.val = 1.5 sd = sd(x) mean = mean(x) ref.ar = qnorm(ref.interval, mean, sd) - qnorm(1 - ref.interval,mean, sd) quant1 = qnorm((1 - ref.interval)/2, mean, sd) quant2 = qnorm(ref.interval + (1 - ref.interval)/2, mean,sd) xlim = c(0, length(x)) ylim = c(min(x, target - n/2 * (abs(diff(tolerance))), quant1, quant2), max(x, target + n/2 * (abs(diff(tolerance))), quant1, quant2)) 6.2.1.1 CgRunChart Resultados antes: qualityTools::cgRunChart(x = x, target = target, tolerance = tolerance, ref.interval = ref.interval, facCg = facCg, facCgk = facCgk, n = n, type = type, col = col, pch = pch, xlim = xlim, ylim = ylim, main = &quot;Run Chart&quot;, conf.level = conf.level, cgOut = FALSE) Resultados Ahora: cg_RunChart(x = x, target = target, tolerance = tolerance, ref.interval = ref.interval, facCg = facCg, facCgk = facCgk, n = n, type = type, col = col, pch = pch, xlim = xlim, ylim = ylim, main = &quot;Run Chart&quot;, conf.level = conf.level, cgOut = FALSE) ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. 6.2.1.2 cgHist Resultados Anteriores: qualityTools::cgHist(x = x, target = target, tolerance = tolerance, ref.interval = ref.interval, facCg = facCg, facCgk = facCgk, n = n, col = &quot;lightblue&quot;, xlim = xlim, ylim = ylim, main = paste(&quot;Histogram of&quot;, deparse(substitute(x)), &quot;- target&quot;), conf.level = conf.level, cgOut = FALSE) Resultados Ahora: cg_HistChart(x = x, target = target, tolerance = tolerance, ref.interval = ref.interval, facCg = facCg, facCgk = facCgk, n = n, col = &quot;lightblue&quot;, xlim = xlim, ylim = ylim, main = paste(&quot;Histogram of&quot;, deparse(substitute(x)), &quot;- target&quot;), conf.level = conf.level, cgOut = FALSE) 6.2.1.3 cgToleranceView Resultados Antes: qualityTools::cgToleranceView(x = x, target = target, tolerance = tolerance, ref.interval = ref.interval, facCg = facCg, facCgk = facCgk, n = n, type = type, col = col, pch = pch, xlim = xlim, ylim = ylim, main = &quot;Tolerance View&quot;, conf.level = conf.level, cgOut = TRUE) Resultados Ahora: cg_ToleranceChart(x = x, target = target, tolerance = tolerance, ref.interval = ref.interval, facCg = facCg, facCgk = facCgk, n = n, type = type, col = col, pch = pch, xlim = xlim, ylim = ylim, main = &quot;Tolerance View&quot;, conf.level = conf.level, cgOut = TRUE) 6.2.1.4 Funcion cg Ahora la función cg se modificará de la siguiente forma: Resultados Antes: x &lt;- c ( 9.991, 10.013, 10.001, 10.007, 10.010, 10.013, 10.008, 10.017, 10.005, 10.005, 10.002, 10.017, 10.005, 10.002, 9.996, 10.011, 10.009 , 10.006, 10.008, 10.003, 10.002, 10.006, 10.010, 9.992, 10.013) qualityTools::cg(x, target = 10.003, tolerance = c(9.903, 10.103)) Resultados Ahora: cg_(x, target = 10.003, tolerance = c(9.903, 10.103)) 6.3 Fase 3: Analizar 6.3.0.1 Capacidad del proceso: Distribución Normal set.seed(1234) datos &lt;- rnorm(20, mean = 20) pcr_(datos, &quot;normal&quot;, lsl = 17, usl = 23) ## ## Anderson Darling Test for normal distribution ## ## data: datos ## A = 0.5722, mean = 19.749, sd = 1.014, p-value = 0.1191 ## alternative hypothesis: true distribution is not equal to normal ## Warning: Removed 1 rows containing missing values (`geom_text()`). 6.3.1 Función gageRRDesign y gageRR_ modificadas para trabajar con objetos R6 # Funciones auxiliares .aip &lt;- function(x.factor, trace.factor, response, fun = mean, type = c(&quot;l&quot;, &quot;p&quot;, &quot;b&quot;), legend = TRUE, trace.label = NULL, fixed = FALSE, xlab = deparse(substitute(x.factor)), ylab =&quot;Measurement&quot; , ylim = NULL, lty = 1:length(unique(trace.factor)), col = 1, pch = c(1L:9, 0, letters), xpd = NULL, leg.bg = par(&quot;bg&quot;), leg.bty = &quot;o&quot;, xtick = FALSE, xaxt = par(&quot;xaxt&quot;), axes = TRUE, title = &quot;&quot;, ...) { ylabel &lt;- paste(ylab ) type &lt;- match.arg(type) # Asegurarse de que los factores son realmente factores x.factor &lt;- factor(x.factor) trace.factor &lt;- factor(trace.factor) # Calcular los valores de celda cellNew &lt;- tapply(response, list(x.factor, trace.factor), fun) cellNew &lt;- as.data.frame(as.table(cellNew)) colnames(cellNew) &lt;- c(&quot;x.factor&quot;, &quot;trace.factor&quot;, &quot;response&quot;) # Convertir x.factor a numérico sólo para la visualización, pero mantenerlo como factor en los datos cellNew$x.numeric &lt;- as.numeric(cellNew$x.factor) # Crear el gráfico p &lt;- ggplot(cellNew, aes(x = x.numeric, y = response, group = trace.factor, color = trace.factor, shape = trace.factor, linetype = trace.factor)) + geom_line() + geom_point(size = 4) + # geom_text(aes(label = round(response, 2)), vjust = -0.5) + # Comentar o eliminar esta línea para ocultar números scale_x_continuous(breaks = unique(cellNew$x.numeric), labels = levels(cellNew$x.factor)) + # Etiquetas de x.factor labs(x = xlab, y = ylabel, title = title, color = trace.label, shape = trace.label, linetype = trace.label) + theme_minimal() if (!is.null(ylim)) { p &lt;- p + ylim(ylim) } if (legend) { p &lt;- p + theme(legend.position = &quot;top&quot;) } else { p &lt;- p + theme(legend.position = &quot;none&quot;) } print(p) invisible() } .c4 = function(n) { if (n &gt; 1 &amp;&amp; n &lt; 342) sqrt(2/(n - 1)) * (factorial(n/2 - 1)/factorial((n - 1)/2 - 1)) else stop(&quot;n needs to be bigger than 1 and smaller than 342&quot;) } # Definición de la clase gageRR gageRR &lt;- R6Class(&quot;gageRR&quot;, public = list( X = NULL, ANOVA = NULL, RedANOVA = NULL, method = NULL, Estimates = NULL, Varcomp = NULL, Sigma = NULL, GageName = NULL, GageTolerance = NULL, DateOfStudy = NULL, PersonResponsible = NULL, Comments = NULL, b = NULL, a = NULL, y = NULL, facNames = NULL, numO = NULL, numP = NULL, numM = NULL, initialize = function(X, ANOVA = NULL, RedANOVA = NULL, method = NULL, Estimates = NULL, Varcomp = NULL, Sigma = NULL, GageName = NULL, GageTolerance = NULL, DateOfStudy = NULL, PersonResponsible = NULL, Comments = NULL, b = NULL, a = NULL, y = NULL, facNames = NULL, numO = NULL, numP = NULL, numM = NULL) { self$X &lt;- X self$ANOVA &lt;- ANOVA self$RedANOVA &lt;- RedANOVA self$method &lt;- method self$Estimates &lt;- Estimates self$Varcomp &lt;- Varcomp self$Sigma &lt;- Sigma self$GageName &lt;- GageName self$GageTolerance &lt;- GageTolerance self$DateOfStudy &lt;- DateOfStudy self$PersonResponsible &lt;- PersonResponsible self$Comments &lt;- Comments self$b &lt;- b self$a &lt;- a self$y &lt;- y self$facNames &lt;- facNames self$numO &lt;- numO self$numP &lt;- numP self$numM &lt;- numM }, show = function() { print(as.data.frame(self$X)) }, subset = function(i, j) { return(self$X[i, j]) }, summary = function() { if (all(is.na(self$X$Measurement))) { cat(&quot;Gage R&amp;R Summary\\n&quot;) cat(&quot;-----------------\\n&quot;) cat(&quot;Method: &quot;, self$method, &quot;\\n&quot;) cat(&quot;Sigma: &quot;, self$Sigma, &quot;\\n&quot;) cat(&quot;Gage Name: &quot;, self$GageName, &quot;\\n&quot;) cat(&quot;Gage Tolerance: &quot;, self$GageTolerance, &quot;\\n&quot;) cat(&quot;Date of Study: &quot;, self$DateOfStudy, &quot;\\n&quot;) cat(&quot;Person Responsible: &quot;, self$PersonResponsible, &quot;\\n&quot;) cat(&quot;Comments: &quot;, self$Comments, &quot;\\n&quot;) cat(&quot;Operators: &quot;, self$numO, &quot;\\n&quot;) cat(&quot;Parts: &quot;, self$numP, &quot;\\n&quot;) cat(&quot;Measurements per Part: &quot;, self$numM, &quot;\\n&quot;) } else { cat(&quot;\\n&quot;) cat(&quot;Operators:\\t&quot;, self$numO, &quot;\\tParts:\\t&quot;, self$numP, &quot;\\n&quot;) cat(&quot;Measurements:\\t&quot;, self$numM, &quot;\\tTotal:\\t&quot;, nrow(self$X), &quot;\\n&quot;) cat(&quot;----------\\n&quot;) } return(invisible(self)) }, response = function() { return(self$X$Measurement) }, replace_response = function(value) { self$X$Measurement = value return(self) }, names = function() { return(names(as.data.frame(self))) }, as_data_frame = function() { return(as.data.frame(self)) }, get_tolerance = function() { return(unlist(self$GageTolerance)) }, set_tolerance = function(value) { if (!is.numeric(value)) stop(&quot;GageTolerance needs to be numeric&quot;) self$GageTolerance = value return(self) }, get_sigma = function() { return(unlist(self$Sigma)) }, set_sigma = function(value) { if (!is.numeric(value)) stop(&quot;Sigma needs to be numeric&quot;) self$Sigma = value return(self) } ) ) # función gageRRdesign modificada gageRRDesign = function(Operators = 3, Parts = 10, Measurements = 3, method = &quot;crossed&quot;, sigma = 6, randomize = TRUE) { # Validación de argumentos if (!is.numeric(sigma)) stop(&quot;sigma needs to be numeric&quot;) if (method != &quot;nested&quot; &amp;&amp; method != &quot;crossed&quot;) stop(&quot;Unknown method specified. Use &#39;method = nested&#39; or &#39;method = crossed&#39;.&quot;) Measurements &lt;- as.integer(Measurements) if (!is.numeric(Measurements) || Measurements &lt;= 0) stop(&quot;Number of Measurements per Part must be a positive integer.&quot;) opvec &lt;- factor() partvec &lt;- factor() yName &lt;- &quot;Measurement&quot; aName &lt;- &quot;Operator&quot; bName &lt;- &quot;Part&quot; abName &lt;- &quot;Operator:Part&quot; Operators &lt;- unique(Operators) Parts &lt;- unique(Parts) if (is.numeric(Operators)) opvec &lt;- factor(LETTERS[1:Operators[1]]) if (is.character(Operators)) opvec &lt;- factor(Operators) if (length(unique(opvec)) &gt; 26) stop(&quot;Too many Operators!&quot;) if (length(unique(opvec)) &lt; 2) stop(&quot;Not enough Operators&quot;) if (is.numeric(Parts)) partvec &lt;- factor(LETTERS[1:Parts[1]]) if (is.character(Parts)) partvec &lt;- factor(Parts) if (length(unique(partvec)) &gt; 26) stop(&quot;Too many Parts!&quot;) if (length(unique(partvec)) &lt; 2) stop(&quot;Too few Parts&quot;) Measurement &lt;- rep(NA, (length(opvec) * length(partvec) * Measurements)) outFrame &lt;- data.frame() if (method == &quot;crossed&quot;) { temp &lt;- expand.grid(opvec, partvec) o &lt;- rep(temp[, 1], Measurements) p &lt;- rep(temp[, 2], Measurements) } else { p &lt;- rep(sort(rep(partvec, length(opvec))), Measurements) o &lt;- (rep(opvec, length(Measurement) / length(opvec))) p &lt;- p[order(o,p)] o &lt;- o[order(o,p)] } if (randomize) outFrame &lt;- data.frame(StandardOrder = 1:length(Measurement), RunOrder = sample(1:length(Measurement), length(Measurement)), Operator = factor(o), Part = factor(p), Measurement) else outFrame &lt;- data.frame(StandardOrder = 1:length(Measurement), RunOrder = 1:length(Measurement), Operator = factor(o), Part = factor(p), Measurement) outFrame &lt;- outFrame[order(outFrame$RunOrder), ] # Valores predeterminados gageRRObj &lt;- gageRR$new( X = outFrame, ANOVA = NULL, RedANOVA = NULL, method = method, Estimates = NULL, Varcomp = NULL, Sigma = sigma, GageName = NULL, GageTolerance = NULL, DateOfStudy = Sys.Date(), PersonResponsible = NULL, Comments = NULL, b = factor(p), a = factor(o), y = as.numeric(Measurement), facNames = c(yName, aName, bName, abName), numO = length(unique(opvec)), # Número de operadores numP = length(unique(partvec)), # Número de partes numM = Measurements # Número de mediciones ) return(gageRRObj) } gageRR_ = function(gdo, method = &quot;crossed&quot;, sigma = 6, alpha = 0.25, DM = NULL, HM = NULL, tolerance = NULL, dig = 3, ...) { method &lt;- method yName &lt;- &quot;Measurement&quot; aName &lt;- &quot;Operator&quot; bName &lt;- &quot;Part&quot; abName &lt;- if(method == &quot;crossed&quot;) paste(aName, &quot;:&quot;, bName, sep = &quot;&quot;) else if(method == &quot;nested&quot;) paste(bName, &quot;(&quot;, aName, &quot;)&quot;, sep = &quot;&quot;) else NA bTobName &lt;- paste(bName, &quot;to&quot;, bName, sep = &quot; &quot;) if (is.null(tolerance)) tolerance &lt;- gdo$get_tolerance() y &lt;- gdo$X[[yName]] a &lt;- gdo$X[[aName]] b &lt;- gdo$X[[bName]] nestedFormula &lt;- as.formula(paste(yName, &quot;~&quot;, aName, &quot;/&quot;, bName)) crossedFormula &lt;- as.formula(paste(yName, &quot;~&quot;, aName, &quot;*&quot;, bName)) reducedFormula &lt;- as.formula(paste(yName, &quot;~&quot;, aName, &quot;+&quot;, bName)) if (method == &quot;nested&quot;) { numA &lt;- nlevels(a) numB &lt;- nlevels(b) numMPP &lt;- length(y) / (numB * numA) gdo$numO &lt;- numA gdo$numP &lt;- numB gdo$numM &lt;- numMPP fit &lt;- aov(nestedFormula, data = gdo$X) meanSq &lt;- anova(fit)[, 3] gdo$ANOVA &lt;- fit gdo$method &lt;- &quot;nested&quot; MSa &lt;- meanSq[1] MSab &lt;- meanSq[2] MSe &lt;- meanSq[3] Cerror &lt;- MSe Cb &lt;- (MSab - MSe) / numMPP Ca &lt;- (MSa - MSab) / (numB * numMPP) if (Ca &lt;= 0) Ca &lt;- 0 if (Cb &lt;= 0) Cb &lt;- 0 Cab &lt;- 0 totalRR &lt;- Ca + Cab + Cerror repeatability &lt;- Cerror reproducibility &lt;- Ca bTob &lt;- Cb totalVar &lt;- Cb + Ca + Cab + Cerror estimates &lt;- list(Cb = Cb, Ca = Ca, Cab = Cab, Cerror = Cerror) varcomp &lt;- list(totalRR = totalRR, repeatability = repeatability, reproducibility = reproducibility, bTob = bTob, totalVar = totalVar) gdo$Estimates &lt;- estimates gdo$Varcomp &lt;- varcomp } if (method == &quot;crossed&quot;) { numA &lt;- nlevels(a) numB &lt;- nlevels(b) numMPP &lt;- length(a) / (numA * numB) gdo$numO &lt;- numA gdo$numP &lt;- numB gdo$numM &lt;- numMPP fit &lt;- aov(crossedFormula, data = gdo$X) model &lt;- anova(fit) gdo$ANOVA &lt;- fit gdo$method &lt;- &quot;crossed&quot; MSb &lt;- MSa &lt;- MSab &lt;- MSe &lt;- 0 if (bName %in% row.names(model)) MSb &lt;- model[bName, &quot;Mean Sq&quot;] else warning(paste(&quot;missing factor&quot;, bName, &quot;in model&quot;)) if (aName %in% row.names(model)) MSa &lt;- model[aName, &quot;Mean Sq&quot;] else warning(paste(&quot;missing factor&quot;, aName, &quot;in model&quot;)) if (abName %in% row.names(model)) MSab &lt;- model[abName, &quot;Mean Sq&quot;] else warning(paste(&quot;missing interaction&quot;, abName, &quot;in model&quot;)) if (&quot;Residuals&quot; %in% row.names(model)) MSe &lt;- model[&quot;Residuals&quot;, &quot;Mean Sq&quot;] else warning(&quot;missing Residuals in model&quot;) Cb &lt;- Ca &lt;- Cab &lt;- Cerror &lt;- 0 Cb &lt;- (MSb - MSab) / (numA * numMPP) Ca &lt;- (MSa - MSab) / (numB * numMPP) Cab &lt;- (MSab - MSe) / numMPP Cerror &lt;- (MSe) gdo$RedANOVA &lt;- gdo$ANOVA if ((Cab &lt; 0) || (model[abName, &quot;Pr(&gt;F)&quot;] &gt;= alpha)) { redFit &lt;- aov(reducedFormula, data = gdo$X) model &lt;- anova(redFit) MSb &lt;- MSa &lt;- MSab &lt;- MSe &lt;- 0 if (bName %in% row.names(model)) MSb &lt;- model[bName, &quot;Mean Sq&quot;] else warning(paste(&quot;missing factor&quot;, bName, &quot;in model&quot;)) if (aName %in% row.names(model)) MSa &lt;- model[aName, &quot;Mean Sq&quot;] else warning(paste(&quot;missing factor&quot;, aName, &quot;in model&quot;)) if (&quot;Residuals&quot; %in% row.names(model)) MSe &lt;- model[&quot;Residuals&quot;, &quot;Mean Sq&quot;] else warning(&quot;missing Residuals in model&quot;) Cb &lt;- Ca &lt;- Cab &lt;- Cerror &lt;- 0 Cb &lt;- (MSb - MSe) / (numA * numMPP) Ca &lt;- (MSa - MSe) / (numB * numMPP) Cab &lt;- 0 Cerror &lt;- (MSe) gdo$RedANOVA &lt;- redFit } gdo$method &lt;- &quot;crossed&quot; Ca &lt;- max(0, Ca) Cb &lt;- max(0, Cb) Cab &lt;- max(0, Cab) totalRR &lt;- Ca + Cab + Cerror repeatability &lt;- Cerror reproducibility &lt;- Ca + Cab bTob &lt;- max(0, Cb) totalVar &lt;- Cb + Ca + Cab + Cerror estimates &lt;- list(Cb = Cb, Ca = Ca, Cab = Cab, Cerror = Cerror) varcomp &lt;- list(totalRR = totalRR, repeatability = repeatability, reproducibility = reproducibility, a = Ca, a_b = Cab, bTob = bTob, totalVar = totalVar) gdo$Estimates &lt;- estimates gdo$Varcomp &lt;- varcomp } cat(&quot;\\n&quot;) cat(paste(&quot;AnOVa Table - &quot;, gdo$method, &quot;Design\\n&quot;)) print(summary(gdo$ANOVA)) cat(&quot;\\n&quot;) cat(&quot;----------\\n&quot;) if (!identical(gdo$RedANOVA, gdo$ANOVA) &amp;&amp; gdo$method == &quot;crossed&quot;) { cat(paste(&quot;AnOVa Table Without Interaction - &quot;, gdo$method, &quot;Design\\n&quot;)) print(summary(gdo$RedANOVA)) cat(&quot;\\n&quot;) cat(&quot;----------\\n&quot;) } Source &lt;- names(gdo$Varcomp) Source[Source == &quot;repeatability&quot;] &lt;- &quot; repeatability&quot; Source[Source == &quot;reproducibility&quot;] &lt;- &quot; reproducibility&quot; Source[Source == &quot;a_b&quot;] &lt;- paste(&quot; &quot;, abName) Source[Source == &quot;a&quot;] &lt;- paste(&quot; &quot;, aName) Source[Source == &quot;bTob&quot;] &lt;- bTobName VarComp &lt;- round(as.numeric(gdo$Varcomp[c(1:length(gdo$Varcomp))]), 3) Contribution &lt;- round(as.numeric(gdo$Varcomp[c(1:length(gdo$Varcomp))]) / as.numeric(gdo$Varcomp[length(gdo$Varcomp)]), 3) VarComp &lt;- t(data.frame(gdo$Varcomp)) VarCompContrib &lt;- VarComp / gdo$Varcomp$totalVar Stdev &lt;- sqrt(VarComp) StudyVar &lt;- Stdev * gdo$Sigma StudyVarContrib &lt;- StudyVar / StudyVar[&quot;totalVar&quot;, ] SNR &lt;- 1 ptRatio &lt;- NULL temp &lt;- NULL if ((length(gdo$GageTolerance) &gt; 0) &amp;&amp; (gdo$GageTolerance &gt; 0)) { ptRatio &lt;- StudyVar / gdo$GageTolerance temp &lt;- data.frame(VarComp, VarCompContrib, Stdev, StudyVar, StudyVarContrib, ptRatio) names(temp)[6] &lt;- c(&quot;P/T Ratio&quot;) row.names(temp) &lt;- c(Source) } else { temp &lt;- data.frame(VarComp, VarCompContrib, Stdev, StudyVar, StudyVarContrib) row.names(temp) &lt;- c(Source) } cat(&quot;\\n&quot;) cat(&quot;Gage R&amp;R\\n&quot;) tempout &lt;- temp print(format(tempout, digits = dig)) cat(&quot;\\n&quot;) cat(&quot;---\\n&quot;) cat(&quot; * Contrib equals Contribution in %\\n&quot;) SNRTemp &lt;- sqrt(2) * (temp[bTobName, &quot;Stdev&quot;] / temp[&quot;totalRR&quot;, &quot;Stdev&quot;]) if (SNRTemp &gt; 1) SNR &lt;- SNRTemp cat(paste(&quot; **Number of Distinct Categories (truncated signal-to-noise-ratio) =&quot;, floor(SNR), &quot;\\n&quot;)) cat(&quot;\\n&quot;) invisible(gdo) } setMethod(&quot;plot&quot;, signature(x = &quot;gageRR&quot;), function(x, y, main=NULL, xlab=NULL, ylab=NULL, col, lwd, fun = mean, ...) { gdo &lt;- x yName &lt;- x$facNames[1] aName &lt;- x$facNames[2] bName &lt;- x$facNames[3] abName &lt;- paste(aName, &quot;:&quot;, bName, sep = &quot;&quot;) if (missing(col)) col &lt;- 2:(length(unique(gdo$b)) + 1) if (missing(lwd)) lwd &lt;- 1 temp &lt;- NULL Source &lt;- names(gdo$Varcomp) VarComp &lt;- round(as.numeric(gdo$Varcomp), 3) Contribution &lt;- round(as.numeric(gdo$Varcomp) / as.numeric(gdo$Varcomp[length(gdo$Varcomp)]), 3) VarComp &lt;- t(data.frame(gdo$Varcomp)) VarCompContrib &lt;- VarComp / gdo$Varcomp$totalVar Stdev &lt;- sqrt(VarComp) StudyVar &lt;- Stdev * gdo$Sigma StudyVarContrib &lt;- StudyVar / StudyVar[&quot;totalVar&quot;, ] if ((length(gdo$GageTolerance) &gt; 0) &amp;&amp; (gdo$GageTolerance &gt; 0)) { ptRatio &lt;- StudyVar / gdo$GageTolerance temp &lt;- data.frame(VarComp, VarCompContrib, Stdev, StudyVar, StudyVarContrib, ptRatio) contribFrame &lt;- data.frame(VarCompContrib, StudyVarContrib, ptRatio) names(temp)[6] &lt;- c(&quot;P/T Ratio&quot;) row.names(temp) &lt;- c(Source) SNR &lt;- sqrt(2 * (temp[&quot;bTob&quot;, &quot;VarComp&quot;] / temp[&quot;totalRR&quot;, &quot;VarComp&quot;])) } else { temp &lt;- data.frame(VarComp, VarCompContrib, Stdev, StudyVar, StudyVarContrib) contribFrame &lt;- data.frame(VarCompContrib, StudyVarContrib) } bTob &lt;- paste(bName, &quot;To&quot;, bName, sep = &quot;&quot;) Source[Source == &quot;bTob&quot;] &lt;- bTob row.names(contribFrame) &lt;- Source if (gdo$method == &quot;crossed&quot;) contribFrame &lt;- contribFrame[-match(c(&quot;totalVar&quot;, &quot;a&quot;, &quot;a_b&quot;), row.names(temp)), ] else contribFrame &lt;- contribFrame[-match(c(&quot;totalVar&quot;), row.names(temp)), ] numBars &lt;-ncol(contribFrame) # Convertir los datos en un formato adecuado contrib_df &lt;- as.data.frame(contribFrame) contrib_df$component &lt;- rownames(contribFrame) contrib_df &lt;- contrib_df %&gt;% rownames_to_column(var = &quot;Source&quot;) %&gt;% filter(Source != &quot;totalVar&quot;) ymax &lt;- max(max(contribFrame)) main1 &lt;- NA # Crear el gráfico # format for ggplot2 contribFrame_long &lt;- as.data.frame(contribFrame) contribFrame_long$Component &lt;- rownames(contribFrame_long) contribFrame_long &lt;- tidyr::gather(contribFrame_long, key = &quot;Metric&quot;, value = &quot;Value&quot;, -Component) # Components of Variation p1 &lt;- ggplot(contribFrame_long, aes(x = Component, y = Value, fill = Metric)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + labs(title = ifelse(is.null(main[1]), &quot;Components of Variation&quot;, main[1]), x = ifelse(is.null(xlab[1]), &quot;Component&quot;, xlab[1]), y = ifelse(is.null(ylab[1]), &quot;&quot;, ylab[1])) + theme_minimal() + scale_fill_manual(values = col[1:nlevels(factor(contribFrame_long$Metric))]) print(p1) #Measurement by part main2&lt;-NA if (gdo$method == &quot;crossed&quot;) { main2 &lt;- NA if (missing(main) || is.na(main[2])) main2 &lt;- paste(yName, &quot;by&quot;, bName) else main2 &lt;- main[2] xlab2 &lt;- NA if (missing(xlab) || is.na(xlab[2])) xlab2 &lt;- bName else xlab2 &lt;- xlab[2] ylab2 &lt;- NA if (missing(ylab) || is.na(ylab[2])) ylab2 &lt;- yName else ylab2 &lt;- ylab[2] p2 &lt;- ggplot(gdo$X, aes_string(x = bName, y = yName)) + geom_boxplot() + stat_summary(fun = median, geom = &quot;line&quot;, aes(group = 1), color = &quot;red&quot;, size = lwd) + stat_summary(fun = median, geom = &quot;point&quot;, color = &quot;red&quot;, size = 3) + labs(title = ifelse(is.null(main2), paste(yName, &quot;by&quot;, bName), main2), x = ifelse(is.null(xlab2), bName, xlab2), y = ifelse(is.null(ylab2), yName, ylab2)) + theme_minimal() print(p2) #Measurement by operator main3 = NA if (missing(main) || is.na(main[3])) main3 = paste(yName, &quot;by&quot;, aName) else main3 = main[3] xlab3 = NA if (missing(xlab) || is.na(xlab[3])) xlab3 = aName else xlab3 = xlab[3] ylab3 = NA if (missing(ylab) || is.na(ylab[3])) ylab3 = yName else ylab3 = ylab[3] p3 &lt;- ggplot(gdo$X, aes_string(x = aName, y = yName)) + geom_boxplot(aes(fill = factor(gdo$X[, 3]))) + stat_summary(fun = median, geom = &quot;line&quot;, aes(group = 1), color = &quot;red&quot;, size = lwd) + stat_summary(fun = median, geom = &quot;point&quot;, color = &quot;red&quot;, size = 3) + labs(title = ifelse(is.null(main[3]), paste(yName, &quot;by&quot;, aName), main[3]), x = ifelse(is.null(xlab[3]), aName, xlab[3]), y = ifelse(is.null(ylab[3]), yName, ylab[3]), fill = &quot;Factor&quot;) + theme_minimal() + scale_fill_manual(values = col) print(p3) #R chart main4 &lt;- NA if (missing(main) || is.na(main[4])) main4 &lt;- paste(&quot;Interaction&quot;, abName) else main4 &lt;- main[4] xlab4 &lt;- NA if (missing(xlab) || is.na(xlab[4])) xlab4 &lt;- colnames(gdo$X)[4] else xlab4 &lt;- xlab[4] ylab4 &lt;- NA if (missing(ylab) || is.na(ylab[4])) ylab4 &lt;- paste(as.character(body(match.fun(fun)))[2], &quot;of&quot;, colnames(gdo$X)[5]) else ylab4 &lt;- ylab[4] agg &lt;- aggregate(gdo$X[, yName], list(gdo$X[, aName], gdo$X[, bName]), FUN = mean) tab &lt;- table(agg[, 2]) sgSize &lt;- tab[1] old.par &lt;- par()$mar par(mar = c(5.1, 4.1, 4.1, 10.1)) .aip(gdo$X[, 4], gdo$X[, 3], response = gdo$X[, 5], xlab = xlab4, ylab = ylab4, title = &quot;Interaction Operator: Part&quot;, legend = TRUE,col = col, type = &quot;b&quot;, ...) par(mar = old.par) # Convertir datos a formato adecuado D3 &lt;- c(0, 0, 0, 0, 0, 0.076, 0.136, 0.184, 0.223, 0.256, 0.284, 0.308, 0.329, 0.348) D4 &lt;- c(0, 3.267, 2.574, 2.282, 2.115, 2.004, 1.924, 1.864, 1.816, 1.777, 1.744, 1.716, 1.692, 1.671, 1.652) # Calcular Rm, UCL, LCL helpRange &lt;-function(x) { return(diff(range(x))) } aggForLimits &lt;- aggregate(gdo$X[, yName], list(gdo$X[, aName], gdo$X[, bName]), FUN = helpRange) Rm &lt;- mean(aggForLimits[, 3]) UCL &lt;- D4[sgSize] * Rm LCL &lt;- D3[sgSize] * Rm agg &lt;- aggregate(gdo$X[, yName], list(gdo$X[, bName], gdo$X[, aName]), FUN = helpRange) tab &lt;- table(agg[, 2]) sgSize &lt;- tab[1] old.par &lt;- par()$mar par(mar = c(5.1, 4.1, 4.1, 10.1)) D3 &lt;- c(0, 0, 0, 0, 0, 0.076, 0.136, 0.184, 0.223, 0.256, 0.284, 0.308, 0.329, 0.348) D4 &lt;- c(0, 3.267, 2.574, 2.282, 2.115, 2.004, 1.924, 1.864, 1.816, 1.777, 1.744, 1.716, 1.692, 1.671, 1.652) # Calcular Rm, UCL, LCL helpRange &lt;- function(x) { return(diff(range(x))) } # Cálculo de los límites aggForLimits &lt;- aggregate(gdo$X[, yName], list(gdo$X[, aName], gdo$X[, bName]), FUN = helpRange) Rm &lt;- mean(aggForLimits[, 3]) # Calcular UCL y LCL sgSize &lt;- length(unique(gdo$X[, bName])) UCL &lt;- D4[sgSize] * Rm LCL &lt;- D3[sgSize] * Rm agg &lt;- aggregate(gdo$X[, yName], list(gdo$X[, bName], gdo$X[, aName]), FUN = helpRange) agg$Group.1 &lt;- factor(agg$Group.1, levels = unique(agg$Group.1)) # Crear el gráfico R Chart con ggplot2 p4 &lt;- ggplot(agg, aes(x = Group.1, y = x)) + geom_line() + # Eliminamos aes(group = Group.2) geom_point(aes(color = Group.2), size = 4) + ylim(0, max(max(agg[, 3]), UCL)) + theme_minimal() + geom_hline(yintercept = c(Rm, UCL, LCL), linetype = &quot;dashed&quot;, color = &quot;red&quot;) + annotate(&quot;text&quot;, x = length(agg[, 3]) + length(agg[, 3]) * 0.075, y = LCL, label = paste(&quot;LCL =&quot;, round(LCL, 2)), hjust = 0, vjust = 0) + annotate(&quot;text&quot;, x = length(agg[, 3]) + length(agg[, 3]) * 0.075, y = UCL, label = paste(&quot;UCL =&quot;, round(UCL, 2)), hjust = 0, vjust = 0) + annotate(&quot;text&quot;, x = length(agg[, 3]) + length(agg[, 3]) * 0.075, y = Rm, label = substitute(bar(R) == Rm, list(Rm = round(Rm, 2))), hjust = 0, vjust = 0) + geom_vline(xintercept = cumsum(tab) - 0.5, linetype = &quot;dashed&quot;) + scale_x_discrete(labels = agg$Group.2) print(p4) } }) Resultados antes: Resultados ahora: # Ejemplo de uso: # crear un objeto de la clase &#39;gageRR&#39; mi_gageRR &lt;- gageRR$new( X = data.frame( Operator = factor(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;A&quot;, &quot;B&quot;)), Part = factor(c(&quot;P1&quot;, &quot;P1&quot;, &quot;P2&quot;, &quot;P2&quot;, &quot;P3&quot;)), Measurement = c(10, 12, 11, 13, 9) ), ANOVA = NULL, # Esto puede ser NULL inicialmente y luego calcularlo RedANOVA = NULL, # Igual que ANOVA, puede ser NULL inicialmente method = &quot;crossed&quot;, Estimates = list(), Varcomp = list(), Sigma = 0.5, GageName = &quot;Gage1&quot;, GageTolerance = 0.1, DateOfStudy = &quot;2024-05-15&quot;, PersonResponsible = &quot;John Doe&quot;, Comments = &quot;Sample gage R&amp;R study&quot;, b = factor(c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;)), a = factor(c(&quot;P1&quot;, &quot;P1&quot;, &quot;P2&quot;, &quot;P2&quot;, &quot;P3&quot;)), y = c(10, 12, 11, 13, 9), facNames = c(&quot;Measurement&quot;, &quot;Operator&quot;, &quot;Part&quot;), numO = 3, numP = 3, numM = 2 ) # Crear el objeto gageRRObj design_example &lt;- gageRRDesign( Operators = 3, Parts = 10, Measurements = 3, method = &quot;crossed&quot;, sigma = 6, randomize = TRUE ) # Crear un diseño para el estudio de Gage design &lt;- gageRRDesign(Operators = 3, Parts = 10, Measurements = 3, method = &quot;crossed&quot;, sigma = 6, randomize = TRUE) design$X$Measurement &lt;- rnorm(nrow(design$X), mean = 10, sd = 2) # Ejecutar la función gageRR_ result &lt;- gageRR_( gdo = design, method = &quot;crossed&quot;, # método &quot;crossed&quot; sigma = 6, # sigma alpha = 0.25, # Nivel de significancia tolerance = NULL, # Tolerancia dig = 3 # Número de dígitos a mostrar en los resultados ) ## ## AnOVa Table - crossed Design ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Operator 2 0.64 0.321 0.113 0.8934 ## Part 9 68.67 7.629 2.687 0.0108 * ## Operator:Part 18 82.26 4.570 1.610 0.0866 . ## Residuals 60 170.35 2.839 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ---------- ## ## Gage R&amp;R ## VarComp VarCompContrib Stdev StudyVar StudyVarContrib ## totalRR 3.416 0.9095 1.848 11.09 0.954 ## repeatability 2.839 0.7559 1.685 10.11 0.869 ## reproducibility 0.577 0.1536 0.759 4.56 0.392 ## Operator 0.000 0.0000 0.000 0.00 0.000 ## Operator:Part 0.577 0.1536 0.759 4.56 0.392 ## Part to Part 0.340 0.0905 0.583 3.50 0.301 ## totalVar 3.756 1.0000 1.938 11.63 1.000 ## ## --- ## * Contrib equals Contribution in % ## **Number of Distinct Categories (truncated signal-to-noise-ratio) = 1 class(result) ## [1] &quot;gageRR&quot; &quot;R6&quot; plot(result) ## Warning: `aes_string()` was deprecated in ggplot2 3.0.0. ## ℹ Please use tidy evaluation idioms with `aes()`. ## ℹ See also `vignette(&quot;ggplot2-in-packages&quot;)` for more information. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. ## Error in get(as.character(FUN), mode = &quot;function&quot;, envir = envir): el objeto &#39;fun&#39; de modo &#39;function&#39; no fue encontrado "]]
